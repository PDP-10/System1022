


************************************************************************
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                             SYSTEM 1022                              *
*                                                                      *
*                                                                      *
*                                                                      *
*                       USER'S REFERENCE MANUAL                        *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                        Revision 4, May 1986                          *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
*                           SOFTWARE HOUSE                             *
*                                                                      *
*                      Cambridge, Massachusetts                        *
*                                                                      *
*                                                                      *
*                                                                      *
*                                                                      *
************************************************************************












































Copyright 1986 by Software House.  All rights reserved.

Software House, 1105 Massachusetts Avenue
Cambridge, Massachusetts 02138, USA

ISBN 0-912055-16-2

Printed in USA.

Revision 1:  October 1980
Revision 2:  October 1981
Revision 3:  September 1983
Revision 4:  May 1986














               To order any System 1022  documentation,
               call or write to:

                         Documentation Distribution
                         Software House
                         1105 Massachusetts Avenue
                         Cambridge, MA 02138
                         USA
                         (617)661-7023


























This manual reflects version  117B  of  System  1022.   Changes  since
Revision  3,  September l984, are marked with bars in the left margin.
Please send any comments or  suggestions  about  this  manual  to  the
Software House Documentation Department.



               Documentation Available for System 1022


Introductory Literature Kit____________ __________ ___

The Kit provides a cursory introduction to the  System.   Included  in
the Kit are:
        o A brief description of the major features in System 1022
        o A copy of The Data Base, the System 1022 newsletter                    ___ ____ ____
        o Two DATA DECISIONS reports which describe System 1022
          and Software House
        o The Price Schedule

User's Reference Manual______ _________ ______

The User's Reference Manual contains complete  information  about  the
interactive use of System 1022.  This is the primary documentation for
the  System.   This  manual  is  available   in   both   printed   and
machine-readable form.  450 pages.


Host Language User's Reference Manual____ ________ ______ _________ ______

The Host Language (HL) Manual contains information needed to write and
run  FORTRAN,  COBOL,  and MACRO application programs using the System
1022 subroutine library.  This manual is available in both printed and
machine-readable form.  150 pages.


Data Base Administrator's Manual____ ____ _______________ ______

The Data Base Administrator's (DBA's) Manual explains to the data base
administrator  how  to  install  and maintain System 1022.  The Manual
describes interfacing 1022 to host languages,  patching,  and  control
features  used  by  the  DBA.   The  Manual is specific to the current
version of 1022.   This  manual  is  available  in  both  printed  and
machine-readable form.  100 pages.


Primer______

The Primer introduces the interactive use of System 1022  to  the  new
user.  The Primer is available in printed form only.  140 pages.


Report Writer Manual:  Operation and Examples______ ______ _______  _________ ___ ________

The Report Writer Manual contains a collection of reports and detailed
descriptions  of  each  to  illustrate how custom reports are written.
The Manual is available in both printed and machine-readable form.  50
pages.



CHAPTER 1       DATA BASE CONCEPTS

        1.1     INTRODUCTION . . . . . . . . . . . . . . . . . . . 1-1
        1.2     FEATURE OVERVIEW . . . . . . . . . . . . . . . . . 1-1
        1.3     DATA BASE STRUCTURE  . . . . . . . . . . . . . . . 1-5
        1.4     SYSTEM 1022 OPTIONS  . . . . . . . . . . . . . . . 1-7
        1.5     TECHNICAL SUMMARY  . . . . . . . . . . . . . . . . 1-7


CHAPTER 2       GENERAL USE OF THE SYSTEM

        2.1     ENTERING AND LEAVING THE SYSTEM  . . . . . . . . . 2-1
        2.1.1     Interactive Startup  . . . . . . . . . . . . . . 2-1
        2.1.2     Startup By Programs  . . . . . . . . . . . . . . 2-1
        2.2     HELP . . . . . . . . . . . . . . . . . . . . . . . 2-2
        2.3     SUMMARY OF SYSTEM COMMANDS . . . . . . . . . . . . 2-3
        2.4     USING SYSTEM COMMANDS  . . . . . . . . . . . . .  2-12
        2.4.1     Command Structure  . . . . . . . . . . . . . .  2-13
        2.4.2     Automatic Startup File . . . . . . . . . . . .  2-14
        2.4.3     Interactive Continuations  . . . . . . . . . .  2-14
        2.4.4     Continuations In Command Files . . . . . . . . 2-14A
        2.4.5     Aborting A Multiline Command . . . . . . . . . 2-14A
        2.4.6     Alphanumeric Strings . . . . . . . . . . . . .  2-15
        2.4.7     Comments . . . . . . . . . . . . . . . . . . .  2-16
        2.4.8     Command Level  . . . . . . . . . . . . . . . .  2-16
        2.4.9     Command Files  . . . . . . . . . . . . . . . .  2-16
        2.4.10    Constant Values  . . . . . . . . . . . . . . .  2-19
        2.4.11    Immediate Commands . . . . . . . . . . . . . .  2-20
        2.4.11.1    #Z  Multiline Command Abort  . . . . . . . .  2-20
        2.4.11.2    #T  TRACE Mode Switch For Command Files  . .  2-20
        2.4.11.3    #TYPE   Command File Messages  . . . . . . .  2-20
        2.4.11.4    #COM  Command File Comments  . . . . . . . .  2-21
        2.4.12    Aborting Command Execution . . . . . . . . . .  2-21
        2.5     COMMAND PARAMETERS . . . . . . . . . . . . . . .  2-22
        2.5.1     File Descriptors . . . . . . . . . . . . . . .  2-22
        2.5.2     Data Set Descriptors . . . . . . . . . . . . . 2-22C
        2.5.3     Attribute Descriptors  . . . . . . . . . . . . 2-22D
        2.5.4     System Output Channels . . . . . . . . . . . .  2-24
        2.5.5     Expressions  . . . . . . . . . . . . . . . . .  2-25
        2.5.5.1     Overflow, Underflow And Zero Division 
                    Handling . . . . . . . . . . . . . . . . . .  2-28
        2.5.5.1.1     Overflow And Underflow Conditions. . . . .  2-29
        2.5.5.1.2     Suppressing Overflow/Underflow Messages  .  2-30
        2.5.5.1.3     Zero Division Handling.  . . . . . . . . .  2-30
        2.5.5.1.4     Suppressing Division-By-Zero Warning 
                      Messages . . . . . . . . . . . . . . . . .  2-31
        2.5.6     Comparison Of Expressions  . . . . . . . . . .  2-31
        2.5.7     Storing Expressions  . . . . . . . . . . . . .  2-31
        2.5.8     Date Expressions . . . . . . . . . . . . . . .  2-32
        2.5.9     System Functions . . . . . . . . . . . . . . .  2-33
        2.5.9.1     Totals And Statistics Functions  . . . . . .  2-34
        2.5.9.2     Arithmetic Functions . . . . . . . . . . . .  2-36
        2.5.9.3     Conversion Functions . . . . . . . . . . . .  2-36
        2.5.9.4     Text Conversion Functions  . . . . . . . . .  2-38
        2.5.9.4.1     $TEXT  . . . . . . . . . . . . . . . . . .  2-38



        2.5.9.4.2     $TEXTL And $TEXTR  . . . . . . . . . . . .  2-39
        2.5.9.5     String Functions . . . . . . . . . . . . . .  2-40
        2.5.9.5.1     String Functions In SORT . . . . . . . . .  2-46
        2.5.9.6     Date Functions . . . . . . . . . . . . . . .  2-46
        2.5.9.7     Monitor Functions  . . . . . . . . . . . . .  2-50
        2.5.10    System Variables . . . . . . . . . . . . . . .  2-51
        2.6     ERROR HANDLING . . . . . . . . . . . . . . . . .  2-66
        2.7     CHANNEL USAGE UNDER TOPS-10  . . . . . . . . . .  2-67
        2.8     INPUT FILE FORMATS . . . . . . . . . . . . . . .  2-68


CHAPTER 3       CREATING THE DATA BASE

        3.1     BUILDING A DATA SET  . . . . . . . . . . . . . . . 3-1
        3.1.1     Bundled And Unbundled Data Sets  . . . . . . . . 3-2
        3.2     DATA FILE  . . . . . . . . . . . . . . . . . . . . 3-3
        3.2.1     Record Formats . . . . . . . . . . . . . . . . . 3-4
        3.2.1.1     Delimited-field Input  . . . . . . . . . . . . 3-5
        3.2.2     Data Types . . . . . . . . . . . . . . . . . . . 3-5
        3.2.2.1     INTEGER  . . . . . . . . . . . . . . . . . . . 3-5
        3.2.2.2     DOUBLE INTEGER . . . . . . . . . . . . . . . . 3-6
        3.2.2.3     REAL . . . . . . . . . . . . . . . . . . . . . 3-6
        3.2.2.4     TEXT . . . . . . . . . . . . . . . . . . . . . 3-7
        3.2.2.5     DATE . . . . . . . . . . . . . . . . . . . . . 3-7
        3.2.2.5.1     Delimited Dates  . . . . . . . . . . . . . . 3-7
        3.2.2.5.2     All-numeric Dates  . . . . . . . . . . . . . 3-8
        3.2.2.5.2.1     Eight-Digit Dates  . . . . . . . . . . . . 3-8
        3.2.2.5.2.2     Six-Digit Dates  . . . . . . . . . . . . . 3-8
        3.2.2.5.2.3     Seven-Digit And Five-Digit Dates . . . . . 3-9
        3.2.2.5.2.4     Errors And Counted Dates . . . . . . . . . 3-9
        3.2.2.6     COMP . . . . . . . . . . . . . . . . . . . . . 3-9
        3.2.2.7     DOUBLE COMP  . . . . . . . . . . . . . . . .  3-10
        3.2.2.8     COMP1  . . . . . . . . . . . . . . . . . . .  3-10
        3.3     DESCRIPTION FILE . . . . . . . . . . . . . . . .  3-10
        3.3.1     Basic ATTRIBUTE Statements . . . . . . . . . .  3-11
        3.3.1.1     Attribute Names In ATTRIBUTE Statements  . .  3-11
        3.3.1.2     Data Types In ATTRIBUTE Statements . . . . .  3-12
        3.3.1.3     COLUMN Or LENGTH In ATTRIBUTE Statements . .  3-12
        3.3.1.4     FILLER Statement . . . . . . . . . . . . . .  3-12
        3.3.1.5     Keyed Attributes In ATTRIBUTE Statements . .  3-13
        3.3.2     More Complex ATTRIBUTE Statements  . . . . . .  3-14
        3.3.2.1     RANGE Clause In ATTRIBUTE Statements . . . .  3-14
        3.3.2.2     Special Data Types In ATTRIBUTE Statements .  3-15
        3.3.2.2.1     DATE OF ENTRY  . . . . . . . . . . . . . .  3-15
        3.3.2.2.2     DATE OF CHANGE . . . . . . . . . . . . . .  3-16
        3.3.2.2.3     INTEGER OF IDENTIFICATION  . . . . . . . .  3-16
        3.3.2.3     The KEYFILE Clause In ATTRIBUTE Statements 
                    (Large Data Sets)  . . . . . . . . . . . . .  3-16
        3.3.2.4     Error Handling Options In ATTRIBUTE 
                    Statements . . . . . . . . . . . . . . . . .  3-17
        3.3.2.5     Delimited Fields In ATTRIBUTE Statements . .  3-17
        3.3.2.6     Additive Attributes In ATTRIBUTE Statements   3-20
        3.3.2.7     Order Of ATTRIBUTE Statements  . . . . . . .  3-20
        3.3.3     Full Description File  . . . . . . . . . . . .  3-21
        3.3.4     LOADING SECTION Of The DMD . . . . . . . . . .  3-22



        3.3.4.1     DATA Statement In The DMD  . . . . . . . . .  3-23
        3.3.4.2     SET Statement In The DMD . . . . . . . . . .  3-23
        3.3.4.2.1     SET Statement Protection . . . . . . . . .  3-24
        3.3.4.2.2     The SET And AUXFILE Statements In A 
                      Multifile Data Set DMD (Large Data Sets) .  3-25
        3.3.4.2.2.1     Determining File Size  . . . . . . . . .  3-26
        3.3.4.3     RECMODE Statement In The DMD . . . . . . . .  3-27
        3.3.4.3.1     DELIMIT Clause In The DMD  . . . . . . . .  3-27
        3.3.4.3.2     ISAM Data Files  . . . . . . . . . . . . .  3-27
        3.3.4.4     LRECL Statement In The DMD . . . . . . . . .  3-28
        3.3.4.5     SCRATCH Statement In The DMD . . . . . . . .  3-28
        3.3.4.6     ALLOCATE Statement In The DMD  . . . . . . .  3-29
        3.3.4.7     NULL Statement In The DMD  . . . . . . . . .  3-30
        3.3.4.8     BLOCKSIZE Statement In The DMD . . . . . . .  3-30
        3.3.4.9     BLOCKED Statement In The DMD . . . . . . . .  3-30
        3.3.4.10    FORMFEED Statement In The DMD  . . . . . . .  3-31
        3.3.5     PARAMETER SECTION Of The DMD . . . . . . . . .  3-31
        3.3.5.1     ADDCLUSTER In The DMD  . . . . . . . . . . .  3-31
        3.3.5.2     ENQ In The DMD . . . . . . . . . . . . . . .  3-32
        3.3.5.3     RECLOCK/NORECLOCK Statement In The DMD . . .  3-32
        3.3.6     Example Of A Data Description File: TRUCKS.DMD  3-33
        3.3.7     Overlapping Attributes . . . . . . . . . . . .  3-35
        3.4     COMMANDS FOR BUILDING A DATA SET . . . . . . . .  3-37
        3.4.1     Bundled Vs. Unbundled Data Sets  . . . . . . .  3-37
        3.5     LOAD COMMAND . . . . . . . . . . . . . . . . . .  3-39
        3.5.1     LOAD Examples  . . . . . . . . . . . . . . . .  3-42
        3.5.2     Error Handling . . . . . . . . . . . . . . . .  3-44
        3.6     CREATE COMMAND . . . . . . . . . . . . . . . . .  3-45
        3.6.1     RELOCATE DATA Command  . . . . . . . . . . . .  3-48
        3.6.2     RELOCATE AUXFILE Command (Large Data Sets) . .  3-50
        3.7     DUMP COMMAND . . . . . . . . . . . . . . . . . .  3-51
        3.7.1     Extracting Records . . . . . . . . . . . . . .  3-53
        3.7.2     Changing The Type Of Data Set  . . . . . . . .  3-54
        3.7.3     Restructuring A Data Set . . . . . . . . . . .  3-55
        3.7.4     Examples Of The DUMP Command . . . . . . . . .  3-55
        3.7.5     Default Numeric-to-Display Conversions . . . .  3-57
        3.7.5.1     Binary Integer To Display Integer  . . . . .  3-57
        3.7.5.2     Binary Real To Display Real  . . . . . . . .  3-57
        3.7.5.3     Binary Date To Display Date  . . . . . . . .  3-58
        3.8     FILE CONVERSION  . . . . . . . . . . . . . . . .  3-58
        3.9     MULTIPLE DATA SETS PER FILE  . . . . . . . . . .  3-58


CHAPTER 4       EXAMINING THE DATA BASE

        4.1     CHOOSING THE DATA SET  . . . . . . . . . . . . . . 4-1
        4.1.1     OPEN Command . . . . . . . . . . . . . . . . . . 4-1
        4.1.2     DBSET Command  . . . . . . . . . . . . . . . . . 4-7
        4.1.3     CLOSE  Command . . . . . . . . . . . . . . . . . 4-8
        4.2     SELECTING RECORDS FOR EXAMINATION  . . . . . . . . 4-9
        4.2.1     FIND Command . . . . . . . . . . . . . . . . .  4-10
        4.2.1.1     Selection Conditions . . . . . . . . . . . .  4-10
        4.2.1.1.1     Relational Operators . . . . . . . . . . .  4-11
        4.2.1.1.2     Values . . . . . . . . . . . . . . . . . .  4-13
        4.2.1.1.3     Using Wildcards To Locate Text Values  . .  4-14



        4.2.1.2     Logical Operators  . . . . . . . . . . . . .  4-17
        4.2.1.3     Special Selection Conditions . . . . . . . .  4-21
        4.2.1.4     Collapsing The FIND Command  . . . . . . . .  4-23
        4.2.2     SAVE Command . . . .. . . . . . . . . . .  4-26
        4.2.3     DFIND Command  . . . . . . . . . . . . . . . .  4-26
        4.2.4     SEARCH Command . . . . . . . . . . . . . . . .  4-27
        4.2.5     SELECT Command . . . . . . . . . . . . . . . .  4-28
        4.2.6     GETREC Command . . . . . . . . . . . . . . . .  4-29
        4.2.7     DROP Command . . . . . . . . . . . . . . . . .  4-31
        4.2.8     MAP Command  . . . . . . . . . . . . . . . . .  4-32
        4.2.8.1     Multi-locator MAP  . . . . . . . . . . . . .  4-35
        4.2.9     JOIN Command . . . . . . . . . . . . . . . . .  4-36
        4.2.9.1     Multiple JOIN Matches  . . . . . . . . . . .  4-37
        4.2.9.2     CLEAR JOIN Command . . . . . . . . . . . . .  4-38
        4.2.9.3     ENABLE JOIN And DISABLE JOIN Commands  . . .  4-39
        4.2.9.4     Simplified MAP Command With Joined Data Sets  4-39
        4.2.9.5     INFORM JOIN Command  . . . . . . . . . . . .  4-40
        4.2.9.6     Joined Data Set Examples . . . . . . . . . .  4-40
        4.2.9.6.1     EXAMPLE 1: Table Lookup And Sort . . . . .  4-41
        4.2.9.6.2     EXAMPLE 2: Explicit MAP  . . . . . . . . .  4-41
        4.2.10    COLLECT Command  . . . . . . . . . . . . . . .  4-42
        4.2.10.1    Referencing Collections  . . . . . . . . . .  4-43
        4.2.10.2    Differences Between A Collection And A Data 
                    Set  . . . . . . . . . . . . . . . . . . . .  4-44
        4.2.10.2.1    SYSID In Collections . . . . . . . . . . .  4-45
        4.2.10.2.2    Commands Not Allowed With Collections  . .  4-45
        4.2.10.2.3    JOIN With Collections  . . . . . . . . . .  4-45
        4.2.11    CLEAR COLLECT Command  . . . . . . . . . . . .  4-45
        4.3     DISPLAYING THE DATA  . . . . . . . . . . . . . .  4-46
        4.3.1     PRINT Command  . . . . . . . . . . . . . . . .  4-47
        4.3.1.1     Print List . . . . . . . . . . . . . . . . .  4-48
        4.3.1.2     The ALL Option . . . . . . . . . . . . . . .  4-50
        4.3.1.3     Totals List  . . . . . . . . . . . . . . . .  4-51
        4.3.1.4     Printing And Totalling Real Values . . . . .  4-52
        4.3.1.5     Pretotals  . . . . . . . . . . . . . . . . .  4-53
        4.3.1.6     Output To Disk Files . . . . . . . . . . . .  4-54
        4.3.2     TYPE COMMAND . . . . . . . . . . . . . . . . .  4-56
        4.3.3     SORT Command . . . . . . . . . . . . . . . . .  4-56
        4.3.3.1     SORT Scratch Device  . . . . . . . . . . . .  4-58
        4.3.4     SORT KEY  Command  . . . . . . . . . . . . . .  4-59
        4.3.5     VALUES Command . . . . . . . . . . . . . . . .  4-59
        4.3.6     SPSS Command . . . . . . . . . . . . . . . . .  4-62
        4.3.6.1     SPSS Input . . . . . . . . . . . . . . . . .  4-62
        4.3.6.2     SPSS Subfiles  . . . . . . . . . . . . . . .  4-63
        4.3.6.3     Function Of The SPSS Command . . . . . . . .  4-63
        4.3.6.4     SPSS Command Format  . . . . . . . . . . . .  4-64


CHAPTER 5       UPDATING THE DATA BASE

        5.1     BASIC UPDATE COMMANDS  . . . . . . . . . . . . . . 5-1
        5.1.1     CHANGE Command . . . . . . . . . . . . . . . . . 5-1
        5.1.2     DELETE Command . . . . . . . . . . . . . . . . . 5-2
        5.1.3     UNDELETE Command . . . . . . . . . . . . . . . . 5-4
        5.1.4     ADD Command  . . . . . . . . . . . . . . . . . . 5-4



        5.1.5     UPTO Command . . . . . . . . . . . . . . . . . . 5-6
        5.1.6     BACKTO Command . . . . . . . . . . . . . . . . . 5-7
        5.2     PROCEDURES FOR LARGE-SCALE UPDATES . . . . . . . . 5-7
        5.2.1     UPDATE Command . . . . . . . . . . . . . . . . . 5-8
        5.2.2     The ALLOCATE Command . . . . . . . . . . . . .  5-8B
        5.2.3     Purpose Of The KEY And UNKEY Commands  . . . . . 5-9
        5.2.4     KEY Command  . . . . . . . . . . . . . . . . . . 5-9
        5.2.5     UNKEY Command  . . . . . . . . . . . . . . . .  5-11
        5.2.6     OPTIMIZE Command . . . . . . . . . . . . . . .  5-13
        5.2.7     APPEND Command . . . . . . . . . . . . . . . .  5-14
        5.2.7.1     The DESC Clause  . . . . . . . . . . . . . . 5-16A
        5.2.8     TRANSACT Command . . . . . . . . . . . . . . .  5-18
        5.2.8.1     Introduction   . . . . . . . . . . . . . . .  5-18
        5.2.8.2     Introductory Example Of Transact . . . . . .  5-19
        5.2.8.3     Supplying Transaction Records  . . . . . . .  5-20
        5.2.8.4     Applying Transaction Fields  . . . . . . . .  5-21
        5.2.8.5     Locating Master Records  . . . . . . . . . .  5-21
        5.2.8.6     Options On The Match . . . . . . . . . . . .  5-23
        5.2.8.7     Handling Multiple Matches On The Locator(s)   5-25
        5.2.8.8     Tailoring Transactions . . . . . . . . . . .  5-26
        5.3     DATA BASE DAMAGE . . . . . . . . . . . . . . . .  5-32
        5.3.1     Incomplete Updates . . . . . . . . . . . . . .  5-32
        5.3.2     System 1022 Or Operating System Bugs . . . . .  5-35
        5.4     MULTIPLE ACCESS OF A DATA SET  . . . . . . . . .  5-36
        5.4.1     Waiting For Update Access  . . . . . . . . . .  5-39
        5.4.1.1     Retry For Update Access  . . . . . . . . . .  5-40
        5.4.1.2     ENQ -- Queue For Update Access . . . . . . .  5-40
        5.4.1.2.1     SYSDEQFAST . . . . . . . . . . . . . . . .  5-41
        5.4.1.2.2     Interrupts With ENQ  . . . . . . . . . . .  5-41
        5.4.2     Consistency In Updates . . . . . . . . . . . .  5-44
        5.4.3     System Protection For Interactive Simultaneous 
                  Updates  . . . . . . . . . . . . . . . . . . .  5-45
        5.4.4     Record-Level Locking . . . . . . . . . . . . .  5-46
        5.4.4.1     Record-level Locking   . . . . . . . . . . .  5-47
        5.4.4.1.1     Enabling Record-level Locking For A Data 
                      Set  . . . . . . . . . . . . . . . . . . .  5-47
        5.4.4.1.2     Locking Records With GETREC $LOCK  . . . .  5-48
        5.4.4.1.3     Locking Records With LOCK ON RECORD  . . .  5-49
        5.4.4.2     User-defined Locks On A Data Set   . . . . .  5-50
        5.4.4.2.1     Userlocks With Collections   . . . . . . .  5-53


CHAPTER 6       PRINT FORMATS

        6.1     FORMAT STRUCTURE . . . . . . . . . . . . . . . . . 6-1
        6.2     NUMERIC FORMATS  . . . . . . . . . . . . . . . . . 6-2
        6.2.1     I - Integer Format . . . . . . . . . . . . . . . 6-4
        6.2.2     O - Octal Format   . . . . . . . . . . . . . . . 6-6
        6.2.3     F - Floating Point Format  . . . . . . . . . . . 6-6
        6.2.4     E - Exponential Format . . . . . . . . . . . . . 6-7
        6.2.5     Omitting The Specification . . . . . . . . . . . 6-9
        6.2.6     Scale Factors  . . . . . . . . . . . . . . . . . 6-9
        6.3     D - DATE OUTPUT FORMATS  . . . . . . . . . . . .  6-10
        6.4     TEXT FORMATS . . . . . . . . . . . . . . . . . .  6-10
        6.4.1     A - ASCII Specification For Text . . . . . . .  6-10



        6.4.2     S - Scrolling Specification  . . . . . . . . .  6-11
        6.4.2.1     Appending To A Scrolled Field  . . . . . . .  6-12
        6.4.2.2     Special Scrolling Options  . . . . . . . . .  6-13
        6.4.3     G - General Purpose Format . . . . . . . . . .  6-14
        6.5     LITERALS . . . . . . . . . . . . . . . . . . . .  6-15
        6.5.1     NH - Hollerith Specification . . . . . . . . .  6-15
        6.5.2     Quoted Literals  . . . . . . . . . . . . . . .  6-15
        6.6     P - PICTURE EDITING  . . . . . . . . . . . . . .  6-16
        6.6.1     Numeric Control Group  . . . . . . . . . . . .  6-16
        6.6.2     Decimal Point Alignment Group  . . . . . . . .  6-19
        6.6.3     Special Editing Group  . . . . . . . . . . . .  6-19
        6.6.4     Combinations With Other Formats  . . . . . . .  6-22
        6.6.5     Picture Contractions . . . . . . . . . . . . . 6-22A
        6.6.6     Limitations On The Picture . . . . . . . . . .  6-23
        6.7     POSITIONAL SPECIFICATIONS  . . . . . . . . . . .  6-23
        6.7.1     X - Blanks . . . . . . . . . . . . . . . . . .  6-23
        6.7.2     T And NT - Horizontal Tabs . . . . . . . . . .  6-23
        6.7.3     Slash Character (/) - New Lines  . . . . . . .  6-24
        6.7.4     Paper Motion Control (C) . . . . . . . . . . .  6-25
        6.7.5     $ - Operations Control . . . . . . . . . . . .  6-26
        6.8     REPEATED GROUPS WITHIN FORMATS . . . . . . . . .  6-26
        6.9     ENDING A FORMAT  . . . . . . . . . . . . . . . .  6-27
        6.10    SUMMARY OF OUTPUT FORMAT TYPES . . . . . . . . .  6-29


CHAPTER 7       SPECIAL COMMANDS AND FEATURES

        7.1     INFORM COMMAND . . . . . . . . . . . . . . . . . . 7-2
        7.1.1     Option: ADMIT [ <user-id> ]  . . . . . . . . . . 7-3
        7.1.2     Option: ATTRIBUTE <attribute-name> [LENGTH]  . . 7-3
        7.1.3     Option: AUDIT  . . . . . . . . . . . . . . . . . 7-4
        7.1.4     Option: BASE . . . . . . . . . . . . . . . . . . 7-4
        7.1.5     Option: COLLECT [ NAME ] . . . . . . . . . . . . 7-4
        7.1.6     Option: COLLECT NUMBER . . . . . . . . . . . . . 7-5
        7.1.7     Option: DAMAGE . . . . . . . . . . . . . . . . . 7-5
        7.1.8     Option: DATA . . . . . . . . . . . . . . . . . . 7-5
        7.1.9     Option: DMX  . . . . . . . . . . . . . . . . . . 7-5
        7.1.10    Option: FILES  . . . . . . . . . . . . . . . . . 7-9
        7.1.11    Option: JOIN [ NAME ]  . . . . . . . . . . . .  7-10
        7.1.12    Option: JOIN NUMBER  . . . . . . . . . . . . .  7-10
        7.1.13    Option: NAMES  . . . . . . . . . . . . . . . .  7-10
        7.1.14    Option: STATUS . . . . . . . . . . . . . . . .  7-11
        7.1.15    Option: STRUCTURE  . . . . . . . . . . . . . .  7-11
        7.1.16    Option: STRUCTURE DATA . . . . . . . . . . . .  7-12
        7.1.17    Option: STRUCTURE LENGTH . . . . . . . . . . .  7-13
        7.1.18    Option: STRUCTURE TABLE  . . . . . . . . . . .  7-13
        7.1.19    Option: VERSION  . . . . . . . . . . . . . . .  7-15
        7.2     KEY $CHECKSUM, KEY $SCAN, AND KEY $VERIFY  . . .  7-15
        7.3     CONTROL-E  . . . . . . . . . . . . . . . . . . .  7-17
        7.4     USING TECO FROM WITHIN THE SYSTEM  . . . . . . .  7-18
        7.5     SOS AND EDIT COMMANDS  . . . . . . . . . . . . .  7-20
        7.5.1     SOS And EDIT On TOPS-10  . . . . . . . . . . .  7-20
        7.5.2     SOS And EDIT On TOPS-20  . . . . . . . . . . .  7-20
        7.6     MODIFY COMMAND . . . . . . . . . . . . . . . . .  7-21
        7.7     SET COMMAND  . . . . . . . . . . . . . . . . . .  7-22



        7.7.1     BUFFER Option  . . . . . . . . . . . . . . . .  7-23
        7.7.2     ERRCHAR Option . . . . . . . . . . . . . . . .  7-24
        7.7.3     ERROR Option . . . . . . . . . . . . . . . . .  7-24
        7.7.4     FILERR Option  . . . . . . . . . . . . . . . .  7-24
        7.7.5     FMSG And FERR Options  . . . . . . . . . . . .  7-25
        7.7.6     PROMPT Option  . . . . . . . . . . . . . . . .  7-26
        7.7.7     SCRATCH Option . . . . . . . . . . . . . . . .  7-27
        7.7.8     TAPE Option  . . . . . . . . . . . . . . . . .  7-28
        7.8     INTERPROGRAM COMMUNICATION . . . . . . . . . . .  7-29
        7.8.1     RUN Command  . . . . . . . . . . . . . . . . .  7-29
        7.8.2     TMPFILE Command  . . . . . . . . . . . . . . .  7-29
        7.8.3     PUSH Command . . . . . . . . . . . . . . . . .  7-30
        7.9     FILE COMMAND . . . . . . . . . . . . . . . . . .  7-31
        7.10    USERCALL COMMAND . . . . . . . . . . . . . . . .  7-32


CHAPTER 8       DATA PROGRAMMING LANGUAGE

        8.1     PL1022 . . . . . . . . . . . . . . . . . . . . . . 8-1
        8.2     SUMMARY OF PL1022 COMMANDS AND STATEMENTS  . . . . 8-2
        8.3     RUNNING A PL1022 PROGRAM . . . . . . . . . . . . . 8-3
        8.3.1     Interactive PL1022 . . . . . . . . . . . . . . . 8-3
        8.4     USING 1022 COMMANDS IN PL1022  . . . . . . . . . . 8-4
        8.5     BOOLEAN EXPRESSIONS  . . . . . . . . . . . . . . . 8-5
        8.5.1     Multiple Matching Values . . . . . . . . . . . . 8-5
        8.6     STATEMENT LABELS . . . . . . . . . . . . . . . . . 8-6
        8.6.1     GOTO Statement . . . . . . . . . . . . . . . . . 8-7
        8.7     IF STATEMENTS  . . . . . . . . . . . . . . . . . . 8-7
        8.7.1     IF Statements With Labels  . . . . . . . . . . . 8-7
        8.7.2     Structured IF Statement  . . . . . . . . . . . . 8-8
        8.7.2.1     IF Statement Applied To A Single Command . . . 8-8
        8.7.2.2     IF THEN Statement With A Block Of Commands.  . 8-8
        8.7.2.3     IF--ELSEIF--ELSE Statements  . . . . . . . . . 8-9
        8.7.2.4     Nesting IF Statements  . . . . . . . . . . .  8-10
        8.7.2.5     Ending Commands And Compound IF Statements .  8-11
        8.7.3     IF Statement Compatibility . . . . . . . . . .  8-11
        8.8     REPEAT STATEMENT . . . . . . . . . . . . . . . .  8-12
        8.9     WHILE STATEMENT  . . . . . . . . . . . . . . . .  8-12
        8.10    LEAVE STATEMENT  . . . . . . . . . . . . . . . .  8-13
        8.10.1    GETREC Statement . . . . . . . . . . . . . . .  8-14
        8.10.1.1    LEAVE With GETREC  . . . . . . . . . . . . .  8-15
        8.11    SUBROUTINES IN THE PL1022 PROGRAM  . . . . . . .  8-16
        8.11.1    PL1022 STOP Statement  . . . . . . . . . . . .  8-17
        8.12    VARIABLES IN PL1022  . . . . . . . . . . . . . .  8-17
        8.12.1    DEFINE Command . . . . . . . . . . . . . . . .  8-18
        8.12.1.1    Lower Subscript Bounds . . . . . . . . . . .  8-19
        8.12.1.2    Multiple Definitions Of Type . . . . . . . .  8-19
        8.12.1.3    Initial Values And Redefinition  . . . . . .  8-20
        8.12.2    LET Command  . . . . . . . . . . . . . . . . .  8-20
        8.12.3    ACCEPT Command . . . . . . . . . . . . . . . .  8-21
        8.12.4    EVALUATE Command . . . . . . . . . . . . . . .  8-22
        8.12.5    CLEAR Command  . . . . . . . . . . . . . . . .  8-22
        8.12.6    Assignments Using The EQ Clause  . . . . . . .  8-23
        8.12.7    Variables In 1022 Commands . . . . . . . . . .  8-23
        8.13    COMMAND FILES IN PL1022 PROGRAMS . . . . . . . .  8-24



        8.14    NESTED PL1022 PROGRAMS . . . . . . . . . . . . .  8-25
        8.15    MULTIPLE DATA SETS . . . . . . . . . . . . . . .  8-25
        8.15.1    Alternate Data Set Reference . . . . . . . . .  8-26
        8.15.2    DBSET Statement  . . . . . . . . . . . . . . .  8-27
        8.15.2.1    Implicit DBSET At Labels . . . . . . . . . .  8-27
        8.15.2.2    Implicit DBSET In Structured Blocks  . . . .  8-28
        8.15.3    MAP Command In PL1022 Programs . . . . . . . .  8-30
        8.15.4    OPEN In PL1022 Programs  . . . . . . . . . . .  8-31
        8.16    DEBUGGING PL1022 PROGRAMS  . . . . . . . . . . .  8-34
        8.17    COMPILE AND PERFORM  . . . . . . . . . . . . . .  8-35
        8.17.1    The COMPILE Command  . . . . . . . . . . . . .  8-35
        8.17.2    The Environment  . . . . . . . . . . . . . . .  8-36
        8.17.2.1    Data Set Matching  . . . . . . . . . . . . .  8-37
        8.17.2.2    Variables  . . . . . . . . . . . . . . . . .  8-39
        8.17.2.3    Recommended Procedures . . . . . . . . . . .  8-40
        8.17.3    The PERFORM Command  . . . . . . . . . . . . .  8-42
        8.17.4    Error Handling . . . . . . . . . . . . . . . .  8-44


CHAPTER 9       REPORT GENERATION

        9.1     SUMMARY OF REPORT COMMANDS AND FEATURES  . . . . . 9-1
        9.2     USING REPORT OUTPUT AS PROGRAM INPUT . . . . . . . 9-4
        9.3     WRITING A REPORT PROGRAM . . . . . . . . . . . . . 9-4
        9.4     SIMPLE REPORT PROGRAM STRUCTURE  . . . . . . . . . 9-5
        9.5     PAGE FORMATTING COMMANDS . . . . . . . . . . . . . 9-8
        9.5.1     HEADING And FOOTING Commands . . . . . . . . . . 9-9
        9.5.2     BODY, PAGE, And TYPAGE Commands  . . . . . . .  9-10
        9.5.3     Paged Output Outside Of Reports  . . . . . . .  9-11
        9.6     BASIC ON CHANGE COMMANDS . . . . . . . . . . . .  9-12
        9.7     EXAMPLE OF A THREE LEVEL REPORT  . . . . . . . .  9-16
        9.8     COMPLETING A HIERARCHY . . . . . . . . . . . . .  9-19
        9.9     PRETOTALS IN SIMPLE REPORT PROGRAMS  . . . . . .  9-20
        9.10    ADVANCED REPORT PROGRAM STRUCTURE  . . . . . . .  9-20
        9.10.1    SECTION INITIAL  . . . . . . . . . . . . . . .  9-21
        9.10.2    SECTION GETREC . . . . . . . . . . . . . . . .  9-22
        9.10.2.1    Empty Section Getrec . . . . . . . . . . . .  9-23
        9.10.2.2    Nonempty Section Getrec  . . . . . . . . . .  9-23
        9.10.2.3    User GETRECs . . . . . . . . . . . . . . . .  9-23
        9.10.3    SECTION HEADING  . . . . . . . . . . . . . . .  9-24
        9.10.4    SECTION PRINT  . . . . . . . . . . . . . . . .  9-25
        9.10.5    SECTION TOTALS . . . . . . . . . . . . . . . .  9-25
        9.10.6    SECTION FINAL  . . . . . . . . . . . . . . . .  9-26
        9.10.7    Sectioned Report Example . . . . . . . . . . .  9-27
        9.11    PROGRAMMED ON CHANGE FEATURES  . . . . . . . . .  9-28
        9.11.1    GOTO Clause  . . . . . . . . . . . . . . . . .  9-28
        9.11.2    EVALUATE Clause  . . . . . . . . . . . . . . .  9-29
        9.11.3    PRETOTAL Clause  . . . . . . . . . . . . . . .  9-30
        9.11.4    Restrictions On Pretotals In Report Programs .  9-32
        9.11.5    Jumping Around An ON CHANGE  . . . . . . . . .  9-33
        9.11.6    Generating Distributed Totals  . . . . . . . .  9-34
        9.12    SUMMARY REPORTS  . . . . . . . . . . . . . . . .  9-36
        9.13    MULTIPLE DATA SET REPORTS  . . . . . . . . . . .  9-37
        9.13.1    Class 1: Investigating Other Data Sets . . . .  9-39



        9.13.2    Class 2: Structuring A Report With Two Data 
                  Sets . . . . . . . . . . . . . . . . . . . . .  9-41
        9.13.2.1    A Report Structured At Three Levels  . . . .  9-44
        9.13.3    Class 3: Hierarchical Totals . . . . . . . . .  9-46
        9.14    REPORT EXECUTION SEQUENCE  . . . . . . . . . . .  9-48
        9.15    CUSTOM REPORTS . . . . . . . . . . . . . . . . .  9-50


CHAPTER 10      THE AUDIT TRAIL

        10.1    INTRODUCTION . . . . . . . . . . . . . . . . . .  10-1
        10.1.1    When To Use Audit Trails . . . . . . . . . . .  10-1
        10.1.2    Command Summary  . . . . . . . . . . . . . . .  10-2
        10.2    TYPES OF AUDIT TRAILS  . . . . . . . . . . . . .  10-3
        10.2.1    Choosing Between Roll Forward And Roll Backward 10-4
        10.3    AUDIT TRAIL FILES  . . . . . . . . . . . . . . .  10-5
        10.3.1    One Data Set To One Audit File . . . . . . . .  10-5
        10.3.2    One Data Set To Many Audit Files . . . . . . .  10-5
        10.3.3    Many Data Sets For One Audit File  . . . . . .  10-5
        10.3.4    Mixtures Of Audit Modes  . . . . . . . . . . .  10-6
        10.4    OPERATION  . . . . . . . . . . . . . . . . . . .  10-6
        10.4.1    Audit On Demand  . . . . . . . . . . . . . . .  10-6
        10.4.2    Audit With Locked Audit File . . . . . . . . .  10-7
        10.4.3    Audit Entries For Readonly Access  . . . . . .  10-7
        10.4.4    Checkpoints  . . . . . . . . . . . . . . . . .  10-8
        10.4.5    Recovering Damaged Data Sets . . . . . . . . .  10-8
        10.4.5.1    The Roll Forward Or Backward Operation . . .  10-9
        10.5    AUDIT QUICK FIX  . . . . . . . . . . . . . . . . 10-10
        10.6    ADMINISTERING RECOVERY . . . . . . . . . . . . . 10-10
        10.6.1    Who Can Recover A Data Set . . . . . . . . . . 10-10
        10.6.2    Automatic Or Manual Recovery . . . . . . . . . 10-11
        10.6.3    Restricting A Damaged Data Set . . . . . . . . 10-11
        10.7    RESOURCES USED BY AUDIT  . . . . . . . . . . . . 10-12
        10.8    DELETING AUDIT FILES . . . . . . . . . . . . . . 10-12
        10.9    AUDIT COMMANDS . . . . . . . . . . . . . . . . . 10-13
        10.9.1    AUDIT START  . . . . . . . . . . . . . . . . . 10-13
        10.9.2    AUDIT LIST . . . . . . . . . . . . . . . . . . 10-14
        10.9.3    AUDIT BACKUP . . . . . . . . . . . . . . . . . 10-16
        10.9.4    AUDIT FORWARD  . . . . . . . . . . . . . . . . 10-17
        10.9.5    AUDIT MERGE  . . . . . . . . . . . . . . . . . 10-17
        10.9.6    AUDIT CHECKPOINT . . . . . . . . . . . . . . . 10-18
        10.9.7    AUDIT COMMENT  . . . . . . . . . . . . . . . . 10-19
        10.9.8    AUDIT CLEAR  . . . . . . . . . . . . . . . . . 10-19
        10.9.9    AUDIT RECOVERY . . . . . . . . . . . . . . . . 10-19
        10.9.10   AUDIT FIX  . . . . . . . . . . . . . . . . . . 10-20


CHAPTER 11      SECURITY

        11.1    ESTABLISHING DATA BASE SECURITY  . . . . . . . .  11-1
        11.1.1    The ADMIT Command  . . . . . . . . . . . . . .  11-2
        11.1.1.1    The ADMIT CLASS PASSWORD Command . . . . . .  11-4
        11.1.1.2    The ADMIT <user-id> Command On TOPS-10 . . .  11-5
        11.1.1.3    The ADMIT <user-id> Command On TOPS-20 . . .  11-7
        11.1.2    Altering Security  . . . . . . . . . . . . .  11-10A



        11.1.2.1    Editing ADMIT Provisions At Monitor Level   11-10A
        11.1.2.2    Adding ADMIT Commands On TOPS-10 . . . . . . 11-11
        11.1.2.3    Adding ADMIT Commands On TOPS-20 . . . . . . 11-12
        11.1.2.4    The ADMIT CLEAR Command  . . . . . . . . . . 11-13
        11.1.2.4.1    ADMIT <user-id> CLEAR On TOPS-10 . . . . . 11-15
        11.1.2.4.2    ADMIT <user-id> CLEAR On TOPS-20 . . . . . 11-16
        11.1.2.5    The ADMIT OWNER Command  . . . . . . . . . . 11-17
        11.1.3    The PERMIT Command . . . . . . . . . . . . . . 11-18


CHAPTER 12      PC INTERFACE: CREATING DIF AND WKS FILES

        12.1    INTRODUCTION . . . . . . . . . . . . . . . . . .  12-1
        12.2    DIF FILES  . . . . . . . . . . . . . . . . . . .  12-1
        12.2.1    The INIT DIF Command . . . . . . . . . . . . .  12-1
        12.2.2    Printing To A 1022 DIF File  . . . . . . . . .  12-3
        12.2.2.1    Data Type Conversion . . . . . . . . . . . .  12-3
        12.2.2.2    Print Formats  . . . . . . . . . . . . . . .  12-4
        12.2.2.3    Example  . . . . . . . . . . . . . . . . . .  12-4
        12.2.2.4    Data-Positioning Information . . . . . . . .  12-8
        12.3    WKS FILES  . . . . . . . . . . . . . . . . . . .  12-9
        12.3.1    The INIT 123 Command . . . . . . . . . . . . .  12-9
        12.3.2    Printing To A WKS File . . . . . . . . . . . . 12-12
        12.3.2.1    Data Type Conversion . . . . . . . . . . . . 12-12
        12.3.2.2    Print Formats  . . . . . . . . . . . . . . . 12-13
        12.3.2.2.1    L Format . . . . . . . . . . . . . . . . . 12-14
        12.3.2.2.2    Other Formats  . . . . . . . . . . . . . . 12-17
        12.3.2.2.3    Other Formats  . . . . . . . . . . . . . . 12-17
        12.3.2.2.3.1    X, /, And $ Formats  . . . . . . . . . . 12-17
        12.3.2.2.3.2    Other 1022 Formats . . . . . . . . . . . 12-21
        12.3.2.3    Example  . . . . . . . . . . . . . . . . . . 12-22
        12.3.2.4    Data-Positioning Options . . . . . . . . . . 12-25


APPENDIX A      SYSTEM 1022 FILE NAME EXTENSIONS


APPENDIX B      SYSTEM 1022 RESERVED WORDS


APPENDIX C      1022 TIME DESCRIPTOR


APPENDIX D      SEGMENTATION


APPENDIX E      SYSTEM 1022 ERROR MESSAGES

        E.1     TYPE 1: COMMAND SCANNER ERRORS (CS)  . . . . . . . E-1
        E.2     TYPE 2: FIND AND SAVE ERRORS (FI)  . . . . . . .  E-20
        E.3     TYPE 3: FILE DAMAGED ERRORS (FD) . . . . . . . .  E-21
        E.4     TYPE 4: OPEN ERRORS (OP) . . . . . . . . . . . .  E-21
        E.5     TYPE 5: MISCELLANEOUS ERRORS (MI)  . . . . . . .  E-23
        E.6     TYPE 6: FORMAT OR PRINT OUTPUT ERRORS (FO) . . .  E-26
        E.7     TYPE 7: UPDATE ERRORS (UP) . . . . . . . . . . . E-28A



        E.8     TYPE 8: SORT ERRORS (SO) . . . . . . . . . . . . E-28C
        E.9     TYPE 9: I/O ERRORS (IO)  . . . . . . . . . . . . E-28D
        E.10    TYPE 10: FATAL SYSTEM ERRORS (SY)  . . . . . . .  E-30
        E.11    TYPE 11: OUT OF CORE ERRORS (CO) . . . . . . . .  E-31
        E.12    TYPE 12: PL1022 ERRORS (PL)  . . . . . . . . . .  E-32
        E.13    TYPE 14: HOST LANGUAGE ERRORS (HL) . . . . . . .  E-33
        E.14    TYPE 15: LOAD AND APPEND ERRORS (LD) . . . . . .  E-36
        E.15    TYPE 16: TRANSACT ERRORS (TR)  . . . . . . . . .  E-39
        E.16    TYPE 18: AUDIT ERRORS (AU) . . . . . . . . . . .  E-39
        E.17    TYPE 19: DEBUGGING ERRORS (DB) . . . . . . . . .  E-41
        E.18    TYPE 20: SPSS INTERFACE ERRORS (SP)  . . . . . .  E-42
        E.19    TYPE 21: COMPILE/PERFORM ERRORS (CP) . . . . . .  E-42


APPENDIX F      SYSTEM 1022 WARNING MESSAGES


APPENDIX G      STANDARD FORM FOR SIMPLE REPORTS


APPENDIX H      SYSTEM 1022 FATAL ERRORS


APPENDIX I      SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM 
                VARIABLES













                                 CHAPTER 1

                             DATA BASE CONCEPTS



   1.1  INTRODUCTION

   System 1022 is a general purpose data management software system  that
   operates on DECsystem-10 and DECSYSTEM-20 computers.

   It is easy to  use  interactively  and  in  sophisticated  application
   programs.   It is a tool that brings data base management to those who
   use the data, yet satisfies the needs  of  professional  managers  and
   application system designers.

   Related data sets  are  easily  linked  for  combined  management  and
   reporting  of information.  System 1022 creates and updates large (and
   small) data collections.   A  very  fast  retrieval  capability  gives
   immediate  access  to  data  in the largest collections of records.  A
   comprehensive report writer displays  this  data  with  any  level  of
   formatting and analysis.



   1.2  FEATURE OVERVIEW

   1. Data Preparation

      Data files are described using a  free-format,  English-based  Data
      Description  Language  (DDL).   The DDL specifies the structure and
      input format of a data file.  This data file is  processed  into  a
      self-contained  file  of  compressed  data  and  System  1022  data
      structures.  Alternately, the description produces a separate  file
      for  1022  data structures and directly accesses the original file.
      Thus, the user may work with one compressed 1022 file  of  data  or
      may  immediately  access  an  external  file  used in other program
      systems.  A collection of data organized by 1022 is called  a  data
      set.

      The things which are not specified are as important as those  which
      are.  Related data sets are not defined in one complex description.
      They may be processed together at any time and need not  be  linked
      when  created.   Programs  need  not  be recompiled when fields are
      added to a data set or when related data sets  are  changed.   This
   DATA BASE CONCEPTS                                            Page 1-2
   Revision 4


      separation  of data and processing means quick development of large
      systems using many related collections of data.

      Data need not exist first to create a data  set.   The  description
      can  produce a data set with no data, and the user can add the data
      with  interactive  commands,  program  systems,  or   System   1022
      utilities.


   2. Data Retrieval

      There are no complex rules about retrieving data from a System 1022
      data set.

      The FIND command locates records through indexes  which  are  built
      and  maintained entirely by 1022.  The user chooses which items are
      indexed at any time during the life of the data set.  Many  indexes
      are easily combined in a FIND command to select interesting subsets
      of the data without anticipating what these subsets  will  be.   No
      long  searches  are  done by FIND;  most FINDs take under 1 second.
      Using the FIND command does not take much  study;   conditions  are
      specified  naturally  in  a  free-format  statement without complex
      constructions.

      The SEARCH command  complements  the  FIND  command.   It  searches
      sequentially  through  records  and  selects  those which match the
      specified conditions.  A SEARCH starts  from  a  group  of  records
      selected  by  FIND  and narrows the selection.  Thus, the user need
      not index everything in a data set, only the items which are  major
      keys to the data.


   3. Data Update

      The CHANGE  command  changes  fields  in  records  which  the  user
      selects.   It  can  update  one  record or many records in a group.
      Indexes are maintained automatically when data values  are  changed
      by any 1022 command.

      The DELETE command  deactivates  selected  records;   the  UNDELETE
      command  restores  them to use.  The ADD command places new records
      into the data set;  it is sometimes used interactively to  build  a
      data  set  from  the  start.  The APPEND command adds to a data set
      from other files or data sets.

      The DUMP command creates a  data  set  or  a  data  file  from  the
      selected records in a data set;  deleted records are not preserved,
      and the DUMPed data set or file may have a structure different than
      the source.

      The TRANSACT command executes large-scale updates.  Information  in
      another file or data set is processed as transactions to the master
      data set.  Update operations and key maintenance  are  done  in  an
   DATA BASE CONCEPTS                                            Page 1-3
   Revision 4


      especially efficient way.

      The AUDIT capabilities of System 1022 protect large data sets which
      are  often updated.  AUDIT writes journal files which can restore a
      data set after  a  computer  or  program  failure  has  interrupted
      updating  operations.   AUDIT  can recover a data set automatically
      after an interruption of updating by one or more users.


   4. Data Analysis and Reporting

      The  user  displays  data  with  the  PRINT  and   TYPE   commands.
      Arithmetic  expressions  may be used freely to display data and may
      use  1022  functions  which  total,   average,   compute   standard
      deviations,  take  square  roots,  and  return  minimum and maximum
      values in the data.

      The SPSS command writes information from selected records  directly
      to  an  SPSS  file  for  analysis.   SPSS  is the trademark for the
      Statistical Package  for  the  Social  Sciences,  from  SPSS  Inc.,
      Chicago,  Illinois.   SPSS  is  in wide use on DECsystem computers.
      Complex statistical analysis is done  easily  by  combining  System
      1022 with the analytical function of SPSS.

      The SORT command defines a sort order for processed data  which  is
      independent  of  any  physical order.  Sorting is done according to
      numeric and text  values  and  also  according  to  expressions  of
      numeric values.

      A complete output formatter  controls  the  presentation  of  data.
      Fields  are  quickly  specified with formats as in FORTRAN, or they
      are specified in detail with PICTURE formats  similar  to  ones  in
      COBOL.   Scrolled  output handles large fields of comments or lists
      of data.

      The  REPORT  system  presents  hierarchical  reports.    The   user
      specifies  page  sizes,  page headings, and page footings.  Row and
      column totals and other functions are done with standard arithmetic
      expressions.   The  data  is  analyzed  according  to any number of
      groups and subgroups;  individual group  headings  and  totals  are
      available   at   all   levels.   A  simple  report  structure  does
      straightforward reporting without programming.   The  most  complex
      reports  include  additional  commands which work with the standard
      report functions and give complete control to the user.


   5. Command Language Programs

      Most interactive  commands  may  be  grouped  for  execution  as  a
      program.   A  structured  internal  programming  language,  PL1022,
      provides control over program execution.  Procedures  are  prepared
|     using  any  text editor and the user has the option of saving these
|     on either uncompiled or precompiled files for later execution.
   DATA BASE CONCEPTS                                            Page 1-4
   Revision 4


|     The USE command executes interactive commands that  are  stored  in
|     sequence  on  an  uncompiled  file.   The  PERFORM command executes
|     procedures that  have  been  previously  compiled  by  the  COMPILE
|     command.   In  either  case,  often  used  parts of commands can be
|     included by direct reference by the @ construction  without  typing
      them  repeatedly.   A  command  file  can  contain references which
      supply parts of  commands  from  the  terminal  immediately  before
      execution.


   6. Host Language Programs

      The features of System 1022  are  available  as  subroutines  which
      interface with FORTRAN, COBOL, and MACRO language programs.

      The  subroutines  follow  the  same  plan  as   interactive   1022.
      Experience  with  one  system  carries  over  to  the  other.   The
      subroutines are easy to use  under  the  conventions  of  the  host
      language.  No pre-processor or special constructions are required.

      The user may write  efficient  customized  application  systems  to
      handle   the  most  complex  data  management  problems,  including
      real-time maintenance of hierarchical and network data structures.

      The interface to a host  language  is  described  in  the  separate
      "System 1022 Host Language User's Reference Manual".


   7. Multiple Data sets

      Many data sets are processed simultaneously to relate  their  data.
      The  relationships  between  them are determined by simple, visible
      matchings between common indexed fields.  The JOIN command  relates
      two data sets.  The MAP command selects records in another data set
      based on indexed values in common with currently selected records.

      One or more fields in a record  can  be  the  basis  for  selecting
      associated  records.   Networks  of any complexity can be formed by
      linking data sets on many fields.  The  programmer  or  interactive
      user  must  know  only  the relationships between the data he works
      with;  he is not affected by other relationships which are  not  of
      interest.

      Data may be retrieved and displayed from more than one data set  at
      the  same  time.  Reports on many data sets follow the hierarchical
      structure of those data sets.  The COLLECT command allows many data
      sets of the same structure to be treated as a single data set.


   8. Stability of Data

      The data records in a System 1022 data set  are  stored  in  simple
      structures  without  many  pointers  and  links.  The complexity is
   DATA BASE CONCEPTS                                            Page 1-5
   Revision 4


      removed to the index tables which organize the data.   The  indexes
      may  be  disrupted  by  system failures, but the data is stable and
      retrievable.

      Indexes are not necessary to retrieve data.  The data need only  be
      written  to  another  data  set  as  the worst result of a computer
      failure during update.  This is done with the  DUMP  command  which
      produces  another  data set directly and without programming.  Most
      often, the DUMP is unnecessary and only  the  indexes  need  to  be
      rebuilt using the KEY command.



   1.3  DATA BASE STRUCTURE

   The following definitions of data base structures use a personnel file
   as  an  example.   The  personnel  file  contains  data  about company
   employees.

   The smallest unit of data  is  an  attribute,  item,  or  field.   For                                      _________   ____       _____
   example,  these  might  be an employee's NAME, AGE or SEX.  Attributes
   may contain text information such as NAME or may be  numeric  such  as
   AGE or SALARY.

   A record is a collection of related attributes which are stored  as  a     ______
   unit.   For  example,  there  is  one  record for each employee in the
   company.  A particular name, age or sex is not of interest by  itself,
   but it is of interest when it is collected to describe an employee.

   A data set is a collection of records having the same attributes.  The     ____ ___
   structure of all records in a data set is the same;  the order, length
   and type of attributes do not vary from record to record.

   A file is a collection of data stored by the computer system which has     ____
   a  name  for referencing it.  The data in a file can be of any type or
   organization.  System 1022 stores one or more data  sets  on  a  file.
|  Sites  licensing  the  Large  Data  Sets Module (LDS) have the further
|  option of splitting a single data set over multiple files.

   A data base is one or more  data  sets  on  one  or  more  files.   It     ____ ____
   strictly  means the data sets which hold information about the related
   parts of a larger entity, those data sets which are commonly processed
   together  because  changes  in  one  imply  changes in the others.  It
   loosely means all data stored in data sets which relate in any way  to
   the activities of the user.

   A  data  base  has  different  records  for  different  parts  of  its
   structure.  One record might relate to many records in another part of
   the data base.  System 1022 relates records in different data sets  by
   matching  them  on common values in the data.  The data provides links
   from record to record;  no hidden links are built by 1022.

   The following example shows employee  records  (EMPLEE),  job  history
   DATA BASE CONCEPTS                                            Page 1-6
   Revision 4


   records  (JOBHST) and children records (CHILD).  Each group of records
   is a separate data set.  The  example  below  shows  the  relationship
   between  them  derived  by  matching  the  records  by  EMPL_ID.   The
   underscore character in attribute names is part of the names.
   Data set: EMPLEE     A record for each employee in the company

      EMPL_ID    NAME          AGE SEX ADDRESS

      037567     JOHNSON, R.   33  M   15 CHESTNUT
      016992     MORRIS, K.    22  F   1126 OGILVIE
      012381     PACKARD, J.   44  M   312 ELM


   Data set: JOBHST    A record for each job reference provided  by  each
                       employee, matched to employee record by EMPL_ID

      EMPL_ID    REF_NAME        ST_DATE     END_DATE

      037567     INTERCO         06/01/76    08/15/77
      037567     PARTSNEW CO     10/01/77    05/01/79
      012381     AJAX INC        06/01/69    08/01/79


   Data set: CHILD     A record for each child of an employee, matched to
                       the employee by EMPL_ID

      EMPL_ID    CH_NAME         CH_AGE CH_SEX

      016992     ARNOLD          05     M
      016992     MARY            03     F
      012381     ALICE           10     F
      012381     WILLIAM         16     M


                              ._______________.
                              |               |
                              |    EMPLEE     |
                              |               |
                              |_______________|
                                     /\        
                                    /  \       
                                   /    \      
                                  /      \     
                                 /        \    
                  ._______________.       ._______________.
                  |               |       |               |
                  |    JOBHST     |       |     CHILD     |
                  |               |       |               |
                  |_______________|       |_______________|
                   
                   
                    Sample System 1022 Data Base Structure
   DATA BASE CONCEPTS                                            Page 1-7
   Revision 4


|  1.4  SYSTEM 1022 OPTIONS
|  
|  Sites may elect to license any or  all  of  the  following  additional
|  System 1022 modules:
|  
|        *  Audit Trail Journaling, which provides  complete  backup  and
|           recovery procedures to assure the safety of the data.
|  
|        *  Data Base Access Accounting, which offers built-in accounting
|           and reports features for billing and planning purposes.
|  
|        *  Data Base Security, which allows the data set  owner  precise
|           control over access to the data.
|  
|        *  Host Language Interface, which offers direct access  to  both
|           the  stand-alone  system  and  to the host language (FORTRAN,
|           COBOL, and the like).
|  
|        *  The Large Data Sets Module, which allows storage of more than
|           134,000,000 records in a single data set and the distribution
|           of the data set over multiple files.
|  
|  The System 1022 INFORM VERSION command returns a list of  the  modules
|  at your site.



   1.5  TECHNICAL SUMMARY

   1. Disk Storage Requirements      ____ _______ ____________

   Interactive System                   TOPS-20:  480 pages;
                                        TOPS-10:  3900 blocks

   Host Language System                 TOPS-20:  420 pages;
                                        TOPS-10:  1750 blocks


   2. Operating System Compatibility      _________ ______ _____________

   TOPS-10                              Native code.

   TOPS-20                              Native code.


   3. Program Structure      _______ _________

   Interactive System                   TOPS-20 4 segments, TOPS-10
                                        15 segments dynamically linked
                                        at runtime
   DATA BASE CONCEPTS                                            Page 1-8
   Revision 4


   Host Language System          Subroutine library loaded with user
                                 program (nonreentrant) or system
                                 segment dynamically linked at
                                 runtime (reentrant)


   4. Memory Requirements      ______ ____________

   Interactive System            TOPS-10:  26K segmented, 52K
                                 nonsegmented.
                                 TOPS-20:  120 pages.  These sizes
                                 are for program storage;
                                 additional memory is dynamically
                                 allocated for data storage.

   Host Language System          TOPS-10:  20-26K (nonreentrant) or
                                 26K (reentrant)
                                 TOPS-20:  40-52 pages
                                 (nonreentrant) or 52 pages
                                 (reentrant)
   5. Data sets      ____ ____

   Maximum number of records in
      one data set:              262,143
|                                134,000,000 with the Large Data
|                                Sets Module

   Maximum number of attributes: limited by memory,
                                  approximately 3,000 maximum

   Maximum data set file size:   65,535 pages (262,143 blocks)
|                                67,000,000 pages (268,000,000 blocks)
|                                with the Large Data Sets Module

   Maximum number of characters
   per text attribute:           5000

   Maximum number of data set
      files open at one time:    TOPS-10:  64; TOPS-20 limited only
                                 by memory and monitor resources

   Maximum length of keyed text: 80 characters

   Maximum logical record length:  64000 characters
   DATA BASE CONCEPTS                                              Page 1-9
   Revision 4


   6. Host Languages      ____ _________

|  FORTRAN-10 (FORTRAN-20)       V10 FOROTS and earlier

   FORTRAN-40                    All versions

   COBOL                         V13 LIBOL and earlier

   MACRO-10 (MACRO-20)           All versions


   DATA BASE CONCEPTS                                             Page 2-10
   Revision 4


   Jackson












                                  CHAPTER 2

                          GENERAL USE OF THE SYSTEM



   2.1  ENTERING AND LEAVING THE SYSTEM

   2.1.1  Interactive Startup

   To enter System 1022, type the DECsystem-10 command:

        R 1022

   or the DECSYSTEM-20 command:

        1022

   Other versions of System 1022 may  be  available  to  you  on  special
   device  names,  or  by  a  different  program  name.   Ask your System
   Administrator.

   1022 responds with an asterisk (*)  when  it  is  ready  to  accept  a
   command.

   To leave System 1022, type the command  QUIT  or  EXIT.   System  1022                                           _         __
   closes any output files and data sets, and returns the user to monitor
   level.  During updating, vital information is held in computer  memory
   and  is  not  written to the data set until the end of the update.  If
   the user interrupts an update with Control-C,  the  data  set  may  be
   damaged.  Take care to use QUIT or EXIT faithfully.



   2.1.2  Startup By Programs

   Other programs may transfer control to System 1022  without  producing
   terminal  output.   If  System 1022 is started at the regular starting
   address plus 1, 1022 does not  type  the  normal  message.   It  reads
   commands from the file ###LNK.TMP, where ### is the user's job number.
   A RUN command could appear on this file to transfer  control  back  to
   the calling program.
   GENERAL USE OF THE SYSTEM                                     Page 2-2
   Revision 4


   2.2  HELP

   The HELP  command  displays  on-line  information  about  System  1022
   features and commands.  Type HELP to see a list of topics covered.

        HELP<RET>

   To learn about a particular topic, type HELP  and  the  topic  keyword
   given  in  the  list.  For example, to learn about the SEARCH command,
   type

        HELP SEARCH<RET>

   System 1022 then displays a  message  that  explains  how  the  SEARCH
   command  works,  including  the command's syntax and an example of its
   use.

   Some HELP messages direct you to related  topics.   For  example,  the
   HELP  message  for  SEARCH directs the user to "See also FIND, SELECT"
   which are related  commands  that  also  have  HELP  messages.   Other
   messages  are  followed  by  a  listing  of  subtopics  for additional
   information.  To read  a  subtopic,  type  HELP,  the  original  topic
   keyword, and then the subtopic keyword.

   For example, to read about the 20-USER-ID subtopic listed at  the  end
   of the HELP message for ADMIT, type

        HELP ADMIT 20-USER-ID<RET>

   Subtopics of subtopics work in a similar way:

        HELP ADMIT 20-USER-ID CLEAR<RET>

   displays information about the CLEAR option  of  the  ADMIT  <user-id>
   command on TOPS-20.

   Keywords may be abbreviated to  the  shortest  character  string  that
   uniquely  identifies them.  For example, to read the message for JOIN,
   you may type

        HELP J<RET>

   because JOIN is the only keyword that begins with J.   Similarly,  the
   HELP command

        HELP TRANSACT DUPLICATES MASTER

   may be abbreviated to

        HELP TR D M

   because TRANSACT is the only keyword beginning with TR, DUPLICATES  is
   the  only  keyword  beginning  with  D  that  can  follow  the keyword
   GENERAL USE OF THE SYSTEM                                     Page 2-3
   Revision 4


   TRANSACT, and MASTER is the only keyword beginning  with  M  that  can
   follow the keyword DUPLICATES.

   Abbreviations that could identify more than one keyword result  in  an
   error message.  For example, when you type

        HELP SE<RET>

   the following message appears:

      Ambiguous keyword -- legal options:
               SEARCH
               SELECT
               SET
      ? (CS204) Ambiguous help keyword

   You may type the HELP command at the 1022 prompt at any point during a
   session.   The  1022 environment is preserved.  The message remains on
   display until you type another command.



   2.3  SUMMARY OF SYSTEM COMMANDS

   The commands in System 1022  are  summarized  below.   The  underlined
   portion of each command is the minimum acceptable abbreviation for the
   command.  Commands restricted to PL1022 or report programs are  marked
   by  a  single  asterisk  (*).  Commands not allowed in either of these
   programs are marked by two asterisks (**).  All other commands, unless
   otherwise noted, may be used anywhere within 1022.



        Command                       Description        _______                       ___________


        ACCEPT            Reads a variable value from the terminal.        __

        ADD               Adds a new record to the data set.        _

        ADMIT             Defines access privileges to the data  set        ___
                          for different user groups.

        ALLOCATE          Assigns more disk blocks for  writing  new        ___
                          records.

        APPEND            Adds new records  to  the  data  set  from        ___
                          another file.

        AUDIT BACKUP      Restores a data set by using  the  damaged        ___   ______
                          set and an audit file.

   GENERAL USE OF THE SYSTEM                                     Page 2-4
   Revision 4


        AUDIT CHECK       The same as AUDIT CHECKPOINT.        ___   _____

        AUDIT CHECKPOINT  Generates a checkpoint in an audit file.        ___   __________

        AUDIT CLEAR       Turns off the AUTO option of AUDIT START.        ___   _____

        AUDIT COMMENT     Inserts a comment into the audit file.        ___   _______

        AUDIT FIX         Restores a damaged data set  to  the  last        ___   ___
                          checkpoint in the audit file.

        AUDIT FORWARD     Restores a data set by using a backup copy        ___   _______
                          of the set and an audit trail.

        AUDIT LIST        Lists audit trail entries.        ___   ____

     ** AUDIT MERGE       Merges audit files together.        ___   _____

        AUDIT RECOVERY    Determines System actions in the event  of        ___   ________
                          data set damage while using audit trails.

        AUDIT START       Turns on the audit trail.        ___   _____

        BACKTO            Makes the current data set compatible with        ______
                          a previous version of System 1022.

        BODY              Sets the body size  for  a  report  output        ____
                          page.

      * CALL              Executes a subroutine in a PL1022 program.        ____

        CHANGE            Changes values of specified attributes  in        _
                          selected records.

     ** CLEAR             Deletes all user defined variables.        _____

     ** CLEAR COLLECT     Removes collection definitions.        _____ _______

     ** CLEAR JOIN        Removes join definitions.        _____ ____

        CLOSE             Closes the current data set.        __

     ** COLLECT           Groups one or more open data sets  into  a        ___
                          collection.

     ** COMPILE           Compiles a PL1022 or  report  program  for        ___
                          later execution.

        CREATE            Creates a data set linked to a  user  data        ___
                          file.

        DBSET             Selects a data  set  for  use  from  among        ___
                          several already open.
   GENERAL USE OF THE SYSTEM                                     Page 2-5
   Revision 4


        DEFINE            Creates a variable of specified  name  and        ___
                          type to be referenced later by the user.

        DELETE            Removes selected  records  from  the  data        ______
                          set.

        DFIND             Selects a group  of  deleted  records  for        _____
                          examination, using keyed attributes.

        DISABLE JOIN      Turns off join definitions.        ___     ____

        DROP              Removes a record  from  the  record  group        ____
                          being  examined,  but  does  not remove it
                          from the data set.

        DUMP              Creates a new data set  from  the  records        ___
                          currently selected.

        EDIT              On TOPS-10, EDIT  accesses  the  SOS  text        ____
                          editor  within 1022 and preserves the 1022
                          environment.  On  TOPS-20,  EDIT  accesses
                          the  editor defined as EDITOR: on EXEC and
                          preserves the 1022 environment.

        ELSE              Conditionally executes a block of commands        ____
                          within an IF statement.

        ELSEIF...THEN     Conditionally tests a  Boolean  expression        ______   ____
                          and  conditionally  executes  a  block  of
                          commands within an IF statement.

        ENABLE JOIN       Turns on join definitions.        ___    ____

        END               Ends a FORMAT  clause  in  a  System  1022        ___
                          PRINT  command;   ends a block of commands
                          in an IF or WHILE statement in PL1022.

        ENDIF             Ends  a  block  of  commands  in   an   IF        ____
                          statement.

        ENDWHILE          Ends  a  block  of  commands  in  a  WHILE        ____
                          statement.

        EVALUATE          Stores the result of a record function  in        __
                          a user defined variable.

        EXIT              In interactive 1022, EXIT  ends  a  System        __
                          1022  session and returns to the operating
                          system.  In a PL1022 routine or  a  report
                          program,   EXIT   aborts  compilation  and
                          returns control to interactive 1022.
   GENERAL USE OF THE SYSTEM                                     Page 2-6
   Revision 4


        FILE COPY         Copies a disk file.        ___  ___

        FILE DELETE       Deletes a disk file.        ___  ___

        FILE RENAME       Renames a disk file.        ___  ___

        FILE TYPE         Types a disk file on the terminal.        ___  ___

        FIND              Selects a  group  of  active  records  for        _
                          examination, using keyed attributes.

        FOOTING           Sets up a footing for  the  report  output        ___
                          page.

        GETREC            Selects  an  individual  record  from  the        ____
                          selected group of records.

      * GOTO              Branches to  a  labelled  statement  in  a        __
                          PL1022 program.

        HEADING           Sets up a heading for  the  report  output        ___
                          page.

        HELP              Displays on-line information about  System        ____
                          1022 commands.

        HOST              Returns to the Host Language Program which        ___
                          called System 1022 via DBEXEC.

        IF                Tests a Boolean  expression  and  executes        __
                          the  command  in  the  IF statement if the
                          expression is true.

      * IF...GOTO         Tests a Boolean expression  and  transfers        __   __
                          control  to  a  labelled statement if that
                          expression is true.

        IF...THEN         Tests a Boolean expression and executes  a        __   ____
                          block  of  commands  if that expression is
                          true.

        IGNORE DAMAGE     Instructs 1022 to ignore file damage.        ___    ______

        INFORM ADMIT      Displays ADMIT information about the  data        _      ___
                          set.

        INFORM ATTRIBUTE  Displays  the  description  of  the  named        _      ___
                          attribute.

        INFORM AUDIT      Displays the status of the audit trail for        _      ___
                          the current data set.
   GENERAL USE OF THE SYSTEM                                     Page 2-7
   Revision 4


        INFORM BASE       Displays the data set descriptors  of  all        _      ___
                          open data sets.

        INFORM COLLECT    Displays the current collections.        _      ___

        INFORM DAMAGE     Displays  damage  information   for   each        _      ___
                          damaged, open data set.

|       INFORM DMX        Displays information  about  the  run-time        _      ___
|                         environment   that   must  exist  for  the
|                         execution  of  a  precompiled  PL1022   or
|                         report program or for the recompilation of
|                         that program with the COMPILE command.

        INFORM DATA       Prints the data  file  descriptor  of  the        _      ____
                          current unbundled data set.

        INFORM FILES      Displays the file specification associated        _      ___
                          with  each  1022  channel  in  use (except
                          channel 0).

        INFORM JOIN       Displays the currently defined joins.        _      ____

        INFORM NAMES      Displays the full attribute names  in  the        _      ___
                          current data set.

        INFORM SET        Displays the full name of the current data        _      ___
                          set.

        INFORM STATUS     Displays the status of  the  current  data        _      ___
                          set.

        INFORM STRUCTURE  Displays the description  of  the  current        _      ___
                          data set.

        INFORM VERSION    Displays  information  about  the  current        _      ___
                          version of 1022.
|  
|       INIT              Assigns System output channels.  INIT  DIF        ___
|                         assigns  a  channel  to  which  output  is
|                         directed in Data Interchange Format.  INIT
|                         WKS  assigns  a channel to which output is
|                         directed in  Lotus  1-2-3  worksheet  file
|                         format.

     ** JOIN              Performs  automatic  mapping  between  two        ____
                          open  data  sets based on matching locator
                          attribute values.

        KEY               Creates   key   tables    for    specified        ___
                          attributes for fast retrieval.
   GENERAL USE OF THE SYSTEM                                     Page 2-8
   Revision 4


|       KEY $CHECKSUM     Shows whether or not the key tables for an        ___  ________
|                         attribute are damaged.
|  
|       KEY $SCAN         Returns statistical information about  key        ___  ____
|                         table fragmentation and space usage.
|  
|       KEY $VERIFY       Shows whether or not the key tables for an        ___  ______
|                         attribute  are  damaged  and  explains the
|                         damage, if any.

      * LEAVE             Exits a structured loop in PL1022.        _____

        LET               Assigns values to variables.        ___

        LOAD              Loads a data set from an ASCII  or  SIXBIT        _
                          input file.
|  
|       LOCK              Requests  or   removes   a   request   for        ____
|                         exclusive  access  to  a  record  or  to a
|                         userlock string.

        MAP               Locates records in a second data set based        ___
                          on  attribute  values in the current group
                          of records.
|  
|    ** MODIFY $ACCESS    Changes the access to ENQ or NOENQ and, if        ___    _______
|                         the   data  set  is  ENQ,  to  RECLOCK  or
|                         NORECLOCK.

     ** MODIFY $ATTR      Changes the name  or  abbreviation  of  an        ___    _____
                          attribute.

     ** MODIFY $DSNAME    Changes the internal data set name.        ___    _______

      * ON CHANGE         Executes report functions when a group  or        __ _
                          subgroup  changes  during  execution  of a
                          report.

      * ON END            Executes report functions after  the  last        __ _
                          record has been processed.

      * ON START          Executes report functions before the first        __ __
                          record is processed.

        OPEN              Opens a data set.        _

     ** OPTIMIZE          Reformats   key    tables    to    improve        ___
                          efficiency.

        PAGE              Sets the physical page size of the  report        ____
                          output page.

     ** PERFORM           Executes a a PL1022 or report program that        ____
   GENERAL USE OF THE SYSTEM                                     Page 2-9
   Revision 4


                          has   been   compiled   with  the  COMPILE
                          command.

        PERMIT            Controls access to restricted attributes.        ___

|     * PL1022 DEBUG      Activates the PL1022 debugger at run time.        __     _____

      * PL1022 END        Marks the end  of  a  PL1022  program  and        __     ___
                          starts the execution of the program.

      * PL1022 START      Declares that the commands to follow  form        __     _____
                          a  PL1022  program  to  be  executed  as a
                          group.

      * PL1022 STOP       Halts execution of a  PL1022  program  and        __     ____
                          returns control to the interactive command
                          level.

        PRINT             Writes output data to the  terminal  or  a        _
                          disk file.

        PUSH              Goes to  TOPS-20  EXEC  level,  suspending        ____
                          System  1022 operations and preserving the
                          system environment.

        QUIT              In interactive 1022, QUIT  ends  a  System        _
                          1022  session and returns to the operating
                          system.  In a PL1022 routine or  a  report
                          program,   QUIT   aborts  compilation  and
                          returns control to interactive 1022.

        RELEASE           Releases an output  channel,  closing  any        ___
                          file assigned to it.

|       RELOCATE AUXFILE  Changes the location of an auxiliary file.        _____    _______

        RELOCATE DATA     Changes  the  data  file  location  in  an        _____    ____
                          unbundled data set.

        REPEAT...UNTIL    Executes a sequence of commands repeatedly        ______   _____
                          until   its   termination   condition   is
                          satisfied.

        REPORT END        Marks the end of a report program.        ___    _

        REPORT START      Begins a report program.        ___    _

      * RETURN            Terminates a PL1022 subroutine.        ___

        RUN               Runs another program  after  exiting  from        _
                          1022.
   GENERAL USE OF THE SYSTEM                                    Page 2-10
   Revision 4


        SAVE              Saves  a  binary  file  containing  record        ___
                          numbers  for  the  last  selected group of
                          records.

        SEARCH            Selects records using attributes' values.        ___

      * SECTION           Begins a functional section in an advanced        ___
                          report.

        SELECT            Sets selection conditions  on  records  to        ___
                          use in a following operation.

        SET BUFFER        Specifies the number of input/output (I/O)        ___ ______
                          buffers  1022 uses, for greater efficiency
                          during updates.

        SET ERRCHAR       Specifies  the  character  printed  before        ___ _______
                          error messages.

        SET ERROR         Specifies 1022 response to errors.        _   _____

        SET FERR          Specifies  which  FIND,  SEARCH,  and  MAP        ___ ____
                          results  are  considered errors; they will
                          print with the 1022 ERRCHAR.

        SET FILERR        Specifies  the  1022  response  to  errors        ___ ______
                          encountered in command files.

        SET FMSG          Specifies  which  FIND,  SEARCH,  and  MAP        ___ ____
                          results will print a response message.

        SET PROMPT        Specifies the prompt message used by 1022.        ___ ______

|       SET SCRATCH       Specifies the number of buffers to be used        ___ __
|                         by  the  scratch  file that 1022 routinely
|                         creates  for  the  session  for   building
|                         selection sets.

        SET TAPE          Specifies the mode  of  hardware  carriage        ___ ____
                          control.

        SORT              Sorts  selected  records   by   expression        ___
                          values.

        SORT KEY          Sorts selected records by a  single  keyed        ____ ___
                          attribute.

        SOS               On TOPS-10, accesses an  SOS  text  editor        ___
                          within   1022   and   preserves  the  1022
                          environment.   On  TOPS-20,  accesses  the
                          editor  defined  as  EDITOR: on  EXEC  and
                          preserves the 1022 environment.
   GENERAL USE OF THE SYSTEM                                    Page 2-11
   Revision 4


        SPSS              Creates  an  SPSS  system  file  for   the        ____
                          selected records.

        STARTREC          Returns to global mode  from  local  mode,        ________
                          when examining individual records.

        TECO              Accesses a TECO text  editor  within  1022        __
                          and preserves the 1022 environment.

        TMPFILE           Puts an ASCII string into TMPCORE.        ___

        TRANSACT          Performs multiple changes and additions by        ___
                          reading  from  an  input data file or data
                          set.

        TYPAGE            Specifies the page size used for output to        ____
                          the terminal.

        TYPE              Displays information to the terminal.        _

        UNDELETE          Activates selected deleted records.        _____

     ** UNKEY             Deletes   key   tables    for    specified        ___
                          attributes.

        UNTIL             Specifies the termination condition  of  a        _____
                          REPEAT command.

        UPDATE            Turns on, and off, update mode for greater        ___
                          efficiency during update activities.

        UPTO              Makes the current data set compatible with        ____
                          a more recent version of 1022 than the one
                          which built it.

        USE               Executes 1022 commands that are stored  in        ___
                          a disk file.

        USERCALL          Passes  information  from  1022  to  MACRO        ________
                          routines.  TOPS-20 systems only.

        USING             An optional clause  of  the  PUSH  command        _____
                          that  specifies a string of commands to be
                          passed to EXEC.

        VALUES            Displays the data distributions  of  keyed        ___
                          attributes for selected records.

        WHILE...DO        Executes a sequence of commands repeatedly        _____   __
                          until   its   termination   condition   is
                          satisfied.
   GENERAL USE OF THE SYSTEM                                    Page 2-12
   Revision 4


        #COM              Allows the user to insert a comment  in  a        ____
                          command file.

        #T                Immediately activates TRACE mode  of  file        __
                          reading.

        #TYPE             Immediately displays  a  text  message  on        _____
                          scanning the command line.

        #Z                Immediately aborts a multiline command.        __



   2.4  USING SYSTEM COMMANDS

   The description of each System 1022 command in  this  manual  includes
   the  format  of  the command and examples of its use.  The conventions
   used in these formats and examples are:

        1. Examples show sample input typed to System  1022  by  the
           user  and the resulting output typed by 1022.  The user's
           input is usually preceded by  the  1022  command  prompt.
           System 1022 output follows.

           System 1022 output  is  underlined  where  necessary  for
           clarity.

        2. The parts of the examples printed in capital letters must
           be typed exactly as shown, unless otherwise noted.  These
           are keywords and have a special meaning to 1022.

        3. The parts of the examples printed in lower  case  letters
           are command arguments which you replace with a value from
           the possible group of values.

        4. Parts of the example enclosed within square brackets  [ ]
           are  optional.   Type  them  only  when  that  option  is
           desired.

        5. A vertical list of  parameters  enclosed  in  braces  { }
           indicates that you choose one item from the list when the
           command is used.  One item in a vertical  list  may  have
           square  brackets  around  it.   This  means  that you may
           entirely omit a choice.  The item in square  brackets  is
           the default when no choice is made.

        6. Both <RET> and <CR><LF>  stand  for  the  character  pair
           Carriage-Return/Linefeed.     This    is   the   standard
           end-of-line sequence.  You  generate  <CR><LF>  when  you
           press  RETURN  on  the  terminal keyboard.  The text uses
           <RET>  when  the  characters  appear  because  RETURN  is
           pressed,  and uses <CR><LF> to stress the presence of two
           characters  in  examples  where  the  exact   number   of
   GENERAL USE OF THE SYSTEM                                    Page 2-13
   Revision 4


           characters makes a difference.

        7. A small letter "b" often stands for a space  when  output
           is shown exactly.




   2.4.1  Command Structure

   System 1022 accepts user commands in a free and natural  word-oriented
   format.   In  general  it  does  not  rely  on  special  symbols.  The
   exceptions occur in the cases of  machine-related  specifications  and
   mathematical expressions which historically have taken a given form.

   The format of a System 1022 command is:

        COMMAND word word word ...  word

   Each word is separated from the next by a space, tab, or  comma.   The
   comma need not delimit command arguments or lists of arguments;  it is
   usually treated as a single space.

   A command line consists of  one  or  more  commands.   An  interactive
   command  line  is  terminated  by  a  period followed by a space, by a
   <RET>, or by an <ESC>.  An interactive command is executed when it  is
   terminated.

   The following command lines are equivalent:

        FIND ALL<RET>
        FIND ALL<ESC>
        FIND ALL.<RET>
        FIND ALL.<ESC>


   More than one command may be typed on a single line if each command is
   terminated by a period and a space.  The last interactive command on a
   line need not have an ending period.  For example:

        COMMAND word word.  COMMAND word word.  COMMAND word word<RET>
   GENERAL USE OF THE SYSTEM                                    Page 2-14
   Revision 4


   2.4.2  Automatic Startup File

   If you keep an AUTO.DMC file in your directory, System  1022  executes
   the  1022  commands contained in that file when 1022 starts and before
   the  first  command  prompt.   You  may  place  in   this   file   any
   initialization  commands that you desire when starting 1022.  (See the
|  "Command Files" section of this chapter.)   Note that you must  invoke
|  1022  interactively  in  order  to process the AUTO.DMC.  When 1022 is
|  initialized by a host language  call  such  as  DBFOR  or  DBCBL,  the
|  AUTO.DMC is not read.

   Here is a sample AUTO.DMC file:

        SET ERRCHAR $.
        SET PROMPT TIME DISK CPU TEXT "System 1022:".




   2.4.3  Interactive Continuations

   To continue a command or word from one input line to the next, type  a
   hyphen (-) just before the <RET>.  1022 erases both the hyphen and the
   <RET> from the input, without inserting a space.  This is  similar  to
   the  common use of a hyphen in printed text to continue words from one
   line to the next.  For example:

        * OPEN -<RET>        _
         #_MEMO<RET>         _

        is equivalent to:

        * OPEN MEMO<RET>        _

   To continue a command and have 1022 insert a space, you  may  use  the
   ampersand (&) as a continuation character.

   Examples of interactive continuations:

             * PRINT SYS-<RET>             _
              # DATE            enters as PRINT SYSDATE              _

             * PRINT "JOHN-<RET>             _
              # HARRISON"       enters as PRINT "JOHNHARRISON"              _

             * PRINT "JOHN&<RET>             _
              # HARRISON"      enters as PRINT "JOHN HARRISON"              _

             * PRINT "JOHN -<RET>             _
              # HARRISON"       enters as PRINT "JOHN HARRISON"              _

             * PRINT "JOHN--<RET>             _
              # HARRISON"       enters as PRINT "JOHN-HARRISON"              _
   GENERAL USE OF THE SYSTEM                                   Page 2-14A
   Revision 4


   If a quoted alphanumeric string continues from one line  to  the  next
   without  using  this  convention, 1022 issues a warning message.  This
   catches the common error of "runaway" literals, especially in  command
   files.

   Format statements are an exception to the line continuation rule.  The
   hyphen is not needed for line continuation.  System 1022 automatically
   continues lines in a FORMAT clause until it sees an END.

   1022 prompts for continuation lines with a pound sign (#)  and  space,
   as in the above examples, when you enter commands at your terminal.



   2.4.4  Continuations In Command Files

   Line continuation is automatic  when  1022  accepts  commands  from  a
   command  file,  with  the  carriage  return  counting  as a space.  To
   continue from line to line without a  space,  again  use  the  hyphen.
   Long commands are continued on following lines by breaking the command
   between words  without  other  special  actions.   In  command  files,
   commands  are  ended  only  by  an  ending  period (.) character and a
   spacing character.

   Example of lines in a command file:

             OPEN STOCK.          Is read as   OPEN STOCK

             OPEN STOCK
             PASSWORD BOND.       Is read as OPEN STOCK PASSWORD BOND




   2.4.5  Aborting A Multiline Command

   If you type several lines of a multiple line  command  and  decide  to
   cancel  the  entire  command,  type the immediate command #Z (see this
   chapter, "Immediate Commands") and a  carriage  return.   System  1022
   responds  by  typing  an  asterisk  (*) without executing the command.
   Syntax errors in the earlier parts of the  command  will  still  cause
   error messages.

   GENERAL USE OF THE SYSTEM                                   Page 2-14B
   Revision 4



























                     [ This page intentionally left blank ]
   GENERAL USE OF THE SYSTEM                                    Page 2-15
   Revision 4


   2.4.6  Alphanumeric Strings

   To enter a text literal (a character string), enclose the string  with
   a pair of double quotation marks or single quotation marks.

   Example: "JOHN HENRY" is a literal string of 10  characters  including
   the space in the middle.

   Some commands (like FIND) allow entering single words as text literals
   without  typing the quotation marks.  Look for this convenience in the
   command descriptions.

   Quotation marks are special characters when they start  a  word  (when
   they  are  preceded  by a space, tab, or <RET>).  A quotation mark not
   beginning a word is treated  as  part  of  the  input  text.   When  a
   quotation  mark  begins  a  word,  then the appearance of the matching
   quotation mark  character  terminates  that  word,  even  if  directly
   followed by another character.  For example:

        "HOW"AGE is read as  word=HOW   word=AGE

   Sometimes the user wants to enter text containing a reserved character
   (  " , # , @ , up arrow or caret,  and <RET> ).  Enter  any  of  these
   characters by typing an up arrow in front of the character.  Enter  an
   up arrow as a character by typing two up arrows.

   Example:

       ^"JOHN^"  enters the exact string  "JOHN"

       COMMENT^<RET>
       LINE

       enters the exact string, COMMENT<RET>LINE including the <RET>.

   Enter a string containing a double quotation  mark  by  enclosing  the
   string with single quotation marks, and the reverse.  For example:

        * PRINT '"Hello," said Fred.'        _
        "Hello," said Fred.        ________ ____ _____

   GENERAL USE OF THE SYSTEM                                    Page 2-16
   Revision 4


   2.4.7  Comments

   An exclamation point (!) preceded by a space  or  a  tab,  or  at  the
   beginning   of  a  line,  marks  the  beginning  of  a  comment.   The
   exclamation point and all text to the end of the line are treated as a
   comment  and  are  ignored  in  command processing.  For example, 1022
   reads

        PRINT "HELLO"  !A SIMPLE COMMAND

   as PRINT "HELLO" and ignores the rest of the line.

   Comments are allowed everywhere:  in interactive commands, in  command
   files, and in DMD files.



   2.4.8  Command Level

   System 1022 types an asterisk (*) when it has completed  all  commands
   given to it and reaches 1022 command level.  You need not wait for the
   asterisk to enter the next command;  type ahead if you wish.

   If you type <RET> in the middle of a multiline command, 1022  types  a
   pound sign (#).

   If the user starts a PL1022 or REPORT  program,  System  1022  prompts
   with  the  characters  "* (PL)"  and  "* (R)", respectively.  In these
   cases, 1022 types a prompt to indicate the most recent  command  input
   has  scanned successfully;  execution is deferred until the user types
   the appropriate END command.  A text editor used  from  within  System
   1022 prompts with ":".  When you are unsure whether 1022 is at command
   level, type a carriage return and see which of  the  prompt  responses
   "*" "#" "* (PL)" "* (R)" is typed.

   The user may replace the asterisk in the prompt  string  with  one  or
   more options in the SET PROMPT command (see Chapter 7, SET Command).



   2.4.9  Command Files

   A command file is a disk file containing  a  command  or  sequence  of
   commands  to  be  executed  with the USE command or at-sign (@).  (The
   execution of  precompiled  procedures  with  the  PERFORM  command  is
   described in chapter 8.)

   The syntax of the USE command is:

        USE <file-descriptor>

   where the file-descriptor names the file containing the commands.
   GENERAL USE OF THE SYSTEM                                    Page 2-17
   Revision 4


   1022 can read pieces of commands provided in disk files,  or  supplied
   in  text  variables,  or typed directly by the user at the appropriate
   time.  From as little as one word to as  much  as  an  entire  command
   procedure  may  be  provided  to  1022  using  the  following  at-sign
   constructions:

             @<file-descriptor>

             @=<variable-name>

             @TTY:

   The at-sign construction may supply portions of commands, whereas  the
   USE command may only reference files containing complete commands.

   The @<file-descriptor> construction is replaced by the contents of the
   named  file  at  the time the command is scanned, and the insertion is
   treated as part of the command.

   If no extension is specified in the file-descriptor  following  either
   USE or @, DMC is assumed first, and then a null extension.


   The command scanner converts the  clause  @=<variable-name>  into  the
   text contents of the variable.  This happens at "scan-time", only when
   the command is read, and not again during execution of a program.  The
   variable  must  be  a  text  variable.  The text value of the variable
   becomes part of the command, as if the variable were a text file in an
   @<file-descriptor>  construction.   No  spaces  are  allowed  in  this
   construction; it is written as one word.

   Because the @=<variable-name> construction operates  at  scan-time,  a
   single  PL1022 or Report Program cannot use the ACCEPT command to read
   a value for a variable  and  expect  that  value  to  be  used  in  an
   @=<variable-name> in the same PL1022 program.


   The @TTY: clause stops for the user to input text that is  scanned  as
   part  of  the  command.   Note  that  the colon (:) is required.  This
   clause normally reads one line of text from the user's terminal  ended
   by  a  <RET>.   The  user  may  input multiple lines by using the line
   continuation sequence of "-<RET>" at the end of each line, remembering
   that  a  space must be used to separate the last word of one line from
   the first word of the next line.


   These three types of indirect text references may be stacked,  in  any
   order,  to  a  limit  of  20  levels.   Thus,  the user can provide an
   @<file-descriptor> reference in response to the request for input from
   an  @TTY: reference.   Also,  the contents of a variable might include
   the clause @TTY:, and this will correctly reference the terminal  when
   1022 scans the contents of that variable.
   GENERAL USE OF THE SYSTEM                                    Page 2-18
   Revision 4


   Text insertion is done only at the time that the  reference  is  first
   scanned.   In  a PL1022 program or report, the commands are determined
   at scan-time and do not change during execution.


   Commands in disk files must be ended by a period.  In files, the <RET>
   is  not  a command terminator but is treated as a single space.  It is
   convenient  to  spread  some  commands  over  several  lines   without
   continuation characters.


   System 1022 checks  that  command  files  end  properly  when  passing
   control  back  to the user's terminal.  Either of two conditions cause
   an error:

        1. The command file ends with only part of a  command.   This  is
           often  due to an unterminated literal causing the remainder of
           the command to be ignored.

        2. The command file contains either REPORT START or PL START  but
           not  a  corresponding REPORT END or PL END command.  In either
           case, 1022 automatically cancels Report  or  PL1022  mode  and
           returns to 1022 command level.


   The following examples illustrate typical uses of command files.

   EXAMPLE 1:  The file PART1.DMC contains the commands

        FIND ALL.
        PRINT SYSID NAME.

        The command "USE PART1"  reads  and  executes  the  two  commands
        sequentially.

   EXAMPLE 2:  The file DSET.TMP contains the names of two data sets:

        INVOIC.JAN INVOIC.FEB

        The command "OPEN @DSET.TMP  INVOIC.MAR"  is  equivalent  to  the
        command "OPEN INVOIC.JAN INVOIC.FEB INVOIC.MAR".

   EXAMPLE 3:  Set up the following variable:

        DEFINE TEXT 25 DSET.
        LET DSET EQ "INVOIC.JAN  INVOIC.FEB".

        Then, the command "OPEN  @=DSET  INVOICE.MAR"  is  equivalent  to
        "OPEN INVOIC.JAN  INVOIC.FEB  INVOIC.MAR".

   GENERAL USE OF THE SYSTEM                                    Page 2-19
   Revision 4


   2.4.10  Constant Values

   Most commands contain specified values and keywords to control command
   actions.   Sometimes  a  command file has a general form, and the user
   desires to use a variable in place of these values and  keywords,  but
   variables  are  not  explicitly  allowed  for  doing  this.  The CONST
   function evaluates a variable and assembles its  result.   Unlike  the
   ordinary  use  of  a variable, the value is used only at the time that
   the command is scanned and  does  not  change  for  the  rest  of  the
   execution of any program.

   The user may reference the value of a variable to supply  a  scan-time
   constant by specifying:

        CONST(<variable-name>)

   Conversions automatically produce a value of the required  type.   For
   example:

        DEFINE TEXT CONST(TLENGTH) TA( CONST(SYSNREC) ).

   defines the text array TA indexed from 1 to the number of  records  in
   the  present selection group.  Each entry contains TLENGTH characters.
   For example, if TLENGTH has the value 5, and SYSNREC has the value 12,
   this is the same as the command:

        DEFINE TEXT 5 TA(12).

   References to CONST and @=<variable-name> are  resolved  at  scan-time
   (compile-time),  using  the  variable's  value  at  that time.  In the
   example below, 1022 compiles the program and prints 5.

        LET I=5.
        PL START.
           LET I=10.
           PRINT CONST(I).
        PL END.

   The CONST expression may include array references.  All subscripts are
   treated as if they too are constant references.  The following example
   prints 1.

        LET A(1)=1  A(2)=2  I=1.
        PL START.
           LET I=2.
           PRINT CONST(A(I)).
        PL END.
   GENERAL USE OF THE SYSTEM                                    Page 2-20
   Revision 4


   2.4.11  Immediate Commands

   The pound sign (#) has special meaning if it is the first character in
   a command word.  Such commands are called "immediate commands" because
   1022 processes them immediately.  Immediate commands include  #Z,  #T,
   and #TYPE.



   2.4.11.1  #Z  Multiline Command Abort

   This command aborts  multiline  commands  (see  Continuations  above).
   When  the user types this command, followed by <RET>, 1022 ignores the
   previously typed portion of the multiline command (except for  errors)
   and returns to the command level asterisk (*) prompt.



   2.4.11.2  #T  TRACE Mode Switch For Command Files

   System 1022 does not normally type out the contents of a command  file
   when  reading  it.  Type the command "#T" (for TRACE) on the same line
   as a USE command:  #T USE MYPROG.  This turns on  the  TRACE  mode  of
   file  reading.  In the TRACE mode, all characters which go through the
   command reader are repeated on the terminal as they  are  read.   This
   continues  until  1022 types "*", indicating that all current commands
   have been executed.  The TRACE mode is useful in checking out problems
   with  command  file  constructions and for documenting processes which
   are executed automatically from command files.  The #T can also  occur
   in the command files which are being executed.



   2.4.11.3  #TYPE   Command File Messages

   #TYPE displays a text message at the terminal when the command line is
   scanned.   #TYPE  is useful in command files, to indicate the progress
   of 1022 through a long command sequence.   The  message  ends  on  the
   first period encountered.

   #TYPE commands type their message when they are scanned.  A  PRINT  or
   TYPE  command, on the other hand, produces output only upon execution.
   If a loop is executed 5 times and contains both #TYPE and  TYPE,  then
   #TYPE produces output once when the loop is scanned, and TYPE produces
   output once for each execution of the loop.
   GENERAL USE OF THE SYSTEM                                    Page 2-21
   Revision 4


   2.4.11.4  #COM  Command File Comments

   #COM allows the user to insert a comment in a command file.   Comments
   inserted  with  the  #COM  command  differ from those initiated by the
   exclamation point in two ways.  First, #COM comments may only occur in
   a  command  file (while exclamation point comments are allowed in many
   different places), and #COM comments terminate, like other commands in
   a  command  file,  with  a  period  (while  exclamation point comments
   terminate with a carriage return).  As with comments initiated  by  an
   exclamation point, #COM commands are ignored when the inventory of the
   command file is scanned prior to execution.

   The #COM command is  especially  useful  as  a  debugging  tool:   the
   insertion  of  #COM at the beginning of a command that is suspected of
   causing a program malfunction allows the user to save the  command  in
   its  original form while keeping it from executing.  The user can then
   try a new version of the command.  If it turns out that  the  original
   command  was correct after all, the user can then restore it by simply
   deleting the #COM.

   Use of the  #COM  command  is  illustrated  in  the  following  report
   program:

        #COM THIS FILE WAS CREATED 2/28/84.
                   .
                   .
                   .
        #COM PRINT SYSID
        FORMAT "SYSID =" X 13 END.
                   .
                   .
                   .

   The first #COM command is a reminder of the date on which the file was
   created.   The  second  #COM  command has been inserted by the user to
   block the execution of the command:

        PRINT SYSID
        FORMAT "SYSID =" X 13 END.



   2.4.12  Aborting Command Execution

   The user may abort command execution in one of several ways.

   When you are typing the command, type Control-U (^U) if it is a single
   line command, or #Z if it is a multiline command.

   To skip the rest of the output from a PRINT  command  which  does  not
   have a large amount of output left, type the monitor command Control-O
   (^O).  The command continues to  execute  in  the  background  without
   printing  anything, faster than when actually printing.  Continue when
   GENERAL USE OF THE SYSTEM                                    Page 2-22
   Revision 4


   the command prompt appears.

   To immediately terminate a single PRINT command which is  producing  a
   large  amount  of  output, type two Control-C's (^C^C) followed by the
   monitor command REENTER.  1022 responds with the command  prompt,  and
   you may continue.

   In most other cases, you cannot use  REENTER  after  aborting  command
   execution  with Control-C.  In those cases, TOPS-10 displays the error
   message "?  NO START ADDRESS".  On TOPS-20, System 1022  displays  the
   error  message  "??(1022) REENTER COMMAND NOT NOW AVAILABLE".  You may
   type the monitor command "CONTINUE<RET>" to continue 1022 execution in
   this case.

   WARNING:  Do not use Control-C to terminate any UPDATE class  command,
   like  ADD  or CHANGE.  You will damage the data set structure.  If you
   have used Control-C and believe that you were in an UPDATE,  then  the
   monitor  command  CONTINUE  continues  System  1022 operations without
   damage to the data set.




   2.5  COMMAND PARAMETERS

   Most System commands require parameters to specify the command action.
   The  following  sections  describe  the  different  types  of  command
   parameters and how they are used.



   2.5.1  File Descriptors

   A "file descriptor" specifies a DECsystem-10 (TOPS-10) or DECsystem-20
   (TOPS-20)  file.  File-descriptors differ slightly between TOPS-10 and
   TOPS-20.  All 1022 commands except  TECO  accept  file-descriptors  in
   these formats.

   GENERAL USE OF THE SYSTEM                                   Page 2-22A
   Revision 4


   The form of the TOPS-10 file-descriptor is:

        dev:filnam.ext[proj,prog,sfd1,...,sfd5]<protection>


   dev          Is the logical or physical name of any disk structure  or
                device.  If dev is specified, it is terminated by a colon
                (:)  to  separate  it   from   the   remainder   of   the
                file-descriptor.  If no device is specified, 1022 assumes
                the device is DSK, the user's disk structure.

   filnam       Is the filename.  It may be up to six characters long and
                contains  only  letters  and numbers.  A value for filnam
                must be supplied as part of any  file-descriptor,  unless
                otherwise stated.

   ext          Is a filename extension.  It is at most three  characters
                long   and   contains   only  letters  and  numbers.   If
                specified, it is separated from the filename by a period.
                Many  commands  supply  a  default extension.  This means
                that it is not always possible to specify a null  (blank)
                extension.

   proj,prog    Is the TOPS-10  project-programmer  number  (ppn)  for  a
                user's  disk  area.  Files in other areas can be accessed
                when the user has  the  proper  access  privileges.   The
                number  pair may be supplied as shown, enclosed by square
                brackets and separated by a comma.  If the project number
                or  programmer  number  is  omitted,  it  defaults to the
                user's logged-in ppn;  if the ppn is omitted  altogether,
                the default is supplied by the monitor.

   sfd          Is a sub-file directory.  They may be nested up  to  five
                levels.

   <protection> Is the three-digit protection code.  It must be  enclosed
                in angle brackets.

   File specifications must be less than 80 characters long.

   Examples of TOPS-10 file-descriptors:

        TEST
        DSK:TEST.DMC
        DSKB:TEST.NEW[100,102]
        DSK:TEST.DBA[100,102,SUB1,SUB2]<057>

   GENERAL USE OF THE SYSTEM                                   Page 2-22B
   Revision 4


   The form of the TOPS-20 file-descriptor is:

        dev:<directory.sub>filename.ext.gen;protection;accounting;T


   dev          Is the logical or physical name of any disk structure  or
                device.  If dev is specified, it is terminated by a colon
                (:)  to  separate  it   from   the   remainder   of   the
                file-descriptor.  If no device is specified, 1022 assumes
                the device is DSK, the user's disk structure.

   <directory>  Is a TOPS-20 directory specification  enclosed  by  angle
                brackets.   It  may  have  up  to thirty-nine letters and
                digits including hyphens.

   sub          Is a TOPS-20 subdirectory specification.   If  specified,
                it  is  separated  from  the  directory  name by a period
                within the angle brackets.  It may have up to thirty-nine
                letters and digits including hyphens.  Subdirectories may
                be arbitrarily deep, i.e. <USER.sub1.sub2....subn>.

   filename     Is  the  filename.   It  is  a  maximum  of   thirty-nine
                characters  long  and  contains  only  letters,  hyphens,
                underscores, and digits.  A value for  filename  must  be
                supplied as part of any file-descriptor, unless otherwise
                stated.

   ext          Is a filename  extension.   It  is  at  most  thirty-nine
                characters  long  and  contains  only  letters,  hyphens,
                underscores, and digits.  If specified, it  is  separated
                from  the  filename  by a period.  Many commands supply a
                default extension.  This means  that  it  is  not  always
                possible to specify a null (blank) extension.

   gen          Is an integer that specifies  the  file  generation.   If
                specified,  it  is  separated  from  the  extension  by a
                period.

   protection   Is a  letter  "P"  and  six-digit  protection  code.   If
                specified,  it  is  separated  from  the  preceding  file
                descriptor by a semicolon.

   accounting   Is a letter "A" and accounting code.  If specified, it is
                separated   from  the  preceding  file  descriptor  by  a
                semicolon.

   T            Specifies  a  temporary  file.   If  specified,   it   is
                separated   from  the  preceding  file  descriptor  by  a
                semicolon.

   The file specification must be less than 80 characters long, including
   both  the  specification  entered by the user and the TOPS-20 physical
   device and directory string.
   GENERAL USE OF THE SYSTEM                                   Page 2-22C
   Revision 4


   Examples of TOPS-20 file-descriptors:

        TEST
        DSK:TEST.DMC
        PS:<SMITH>TEST.DBA
        DSK:<TEST.FILES>FILE.EXT.1;P775200;ATESTING




   2.5.2  Data Set Descriptors

   A data set descriptor identifies a data set.  The full form of a  data
   set descriptor is:

        data-set-name IN file-descriptor

   "data-set-name" is the internal name given to the data set.  Data  set
   names  may  contain  letters,  numbers,  and  the underscore character
   (back-arrow on many terminals).  The name begins  with  a  letter  and
   contains  a maximum of 25 characters.  Internal names distinguish data
   sets when multiple data sets reside in the same file.

   "file-descriptor" is a file descriptor as described  in  the  previous
   section.

   In many commands, either the data  set  name  or  file  descriptor  is
   optional.   For  example,  when  creating  a  data  set  with the DUMP
   command, the file descriptor must be specified so 1022 knows  on  what
   file to put the output.  However, the data set name can be omitted, in
   which case 1022 assigns the data set name.  If multiple data sets  are
   to  be  put  into  one  file, both the internal data set name and file
   descriptor must be specified.

   Commands that reference open data sets (such as DBSET, MAP, and  JOIN)
   need only specify either the internal data set name or file-descriptor
   as long as it uniquely identifies the data  set.   Both  the  internal
   data  set name and the file descriptor are needed to uniquely identify
   open data sets when one data set is a copy of the other.  For example,
   if  the  data  set  STOCK resides in two separate files, STOCK.DMS and
   ACCTS.DMS, the user wishing to join the two data  sets  must  identify
   them as STOCK in STOCK.DMS and STOCK in ACCTS.DMS when giving the JOIN
   command.

   Commands which reference opened data sets may also refer to a data set
   by  its number, assigned by 1022 when it is opened (see "OPEN Command"
   in the  Examining  chapter).   You  may  also  specify  an  alias,  an
   alternate name, when you open a data set.  This alternate name may not
   be the same as the internal  name  or  alias  of  any  open  data  set
   (including  the  one to which it refers).  When you open a single data
   set  simultaneously  in  two  or  more  positions,  the  only  way  to
   distinguish between them is to use a data set number or alias.
   GENERAL USE OF THE SYSTEM                                   Page 2-22D
   Revision 4


   Examples:

        STOCK
        STOCK IN ACCTS
        STOCK IN ACCTS.DMS
        STOCK IN ACCTS.NEW




   2.5.3  Attribute Descriptors

   An attribute descriptor identifies an attribute.  The simple  form  is
   to  use  the  attribute name or abbreviation.  These are assigned when
   the data set is built or later changed by  the  MODIFY  command.   The
   name  and abbreviation can be used interchangeably in any command that
   references attributes.

   The most particular attribute descriptor identifies  an  attribute  by
   both  its name and its data set name.  When you use more than one data
   set, this distinguishes attributes with the same name or abbreviation.
   For  example,  SPOUSE.SURNAME  specifies  the SURNAME attribute in the
   SPOUSE data set.  This is called attribute qualification.

   The full form of an attribute descriptor is:

                                 { attribute-name         }
        [ data-set-descriptor. ] {                        }
                                 { attribute-abbreviation }

   Data-set-descriptor is described above.  Number or alias may be  used.
   For example, the following are equivalent commands:

        PRINT SURNAME SPOUSE.SURNAME
        PRINT SURNAME 2.SURNAME
        PRINT SURNAME SPOUSE.SN
        PRINT SURNAME 2.SN

   Each command prints the value of SURNAME from the current data set and
   the value of SURNAME from the SPOUSE data set (number 2).

   Attribute qualification works in  commands  that  reference  attribute
   values  and  do  not  use  or affect the key tables.  For example, the
   PRINT, TYPE, SORT, and IF  commands  can  refer  to  attributes  using
   attribute  qualification.   The  FIND,  VALUES, and SORT KEY commands,
   which use key tables, may not use attribute qualification.

   The SEARCH, SELECT, and CHANGE commands can use attribute
   GENERAL USE OF THE SYSTEM                                    Page 2-23
   Revision 4


   qualification to  specify  values  on  the  right  of  the  relational
   operator.   For  example,  SEARCH  SURNAME  EQUALS  SPOUSE.SURNAME  is
   allowed when SURNAME is an attribute  in  the  current  data  set  and
   SPOUSE  is  another  open  data set.  But SEARCH SPOUSE.SURNAME EQUALS
   SURNAME  is  not  allowed.   In   the   same   way,   CHANGE   SURNAME
   SPOUSE.SURNAME is allowed, but CHANGE SPOUSE.SURNAME SURNAME is not.

   The system variable SYSTEXTDOT controls the way 1022  handles  invalid
   qualified attribute references.  When SYSTEXTDOT is 0, 1022 returns an
   error message for invalid references.  If, for example, SPOUSE.SURNAME
   is  not  an  attribute  in  an  open  data  set, 1022 returns an error
   message.  When SYSTEXTDOT is  1,  1022  treats  an  invalid  qualified
   attribute reference as text in any command that allows unquoted text.

   Example:

        * LET SYSTEXTDOT 0
        * FIND ALL
        520 RECS FOUND.
        * SEARCH DOCUMENT EQUALS MANUAL.RNO
        ? (CS81) Invalid dataset specified
        * LET SYSTEXTDOT 1
        * FIND ALL
        520 RECS FOUND.
        * SEARCH DOCUMENT EQUALS MANUAL.RNO
        FOUND.

        MANUAL is not an open data set.  So MANUAL.RNO is a search  value
        for the DOCUMENT attribute in the current data set.

   When attribute names or abbreviations are unique among  multiple  open
   data   sets,  you  can  use  alternate  data  set  references  without
   specifying the alternate data set.  The PRINT, TYPE, LET, and EVALUATE
   commands can directly reference attributes in data sets other than the
   current  one  by  attribute  name  or  abbreviation  alone.   When  an
   attribute  name  in one of these commands does not match any attribute
   in the current data set, then the other  open  data  sets  qualify  to
   provide  a  match.   The  matching  attribute  in  the  other data set
   provides the value.  For example,

        PRINT PNAME CNAME

   prints PNAME from the PARENT data set and CNAME from  the  CHILD  data
   set.

   Alternate data set reference does not automatically select records  in
   other  data sets.  It uses the values of the currently selected record
   in the other data set.  The related record in an auxiliary data set is
   selected  by  the user, allowing a PRINT command to reference both the
   original data in the current data set and the auxiliary data.  Use the
   system  variable  SYSAMBATTR  to  control  the  handling  of ambiguous
   alternate data set references.
   GENERAL USE OF THE SYSTEM                                    Page 2-24
   Revision 4


   If more than one record is selected in the alternate  data  set,  only
   the value from the first record is used when no JOIN is in effect.  If
   no record is selected, a null value is used.



   2.5.4  System Output Channels

   You may assign up to eight output channels for use with disk files  or
   the  terminal.   The channels are in turn referenced by 1022 commands,
   such as PRINT, which generate or control  output.   The  clause  which
   selects a channel has the form:

        [ ON n ]

   where n is an integer from 1 to 8.

   For example:  PRINT ON 3 AGES !sends the output to channel 3.

   The correspondence between the  output  channel  n  and  the  physical
   output device is set up by the INIT command, whose form is:
|  
|            { [  123    [ options ] ] }     { <file-descriptor> }
|       INIT { [ APPEND ]              } <n> {                   }
|            { [  DIF    [ options ] ] }     { TTY:              }


   For example:

        INIT 3 TTY:            !inits channel 3 to the user's terminal
        INIT 3 FILEA.DAT       !inits to this file
        INIT 3 DSKB:FILEA.DAT  !includes the particular disk drive
        INIT 3 DSKB:<MIS>FILEA.DAT   !includes a user area

   Once the correspondence between a  device  and  a  channel  number  is
   established,  it  is  broken  only  when  the channel is reassigned or
   released.  In either case, the file associated  with  the  channel  is
   properly  closed  and saved.  Channels 2 through 8 are reassigned only
   when another INIT command is issued to  the  channel.   Channel  1  is
   reassigned  in  this  way, or when an "ON <file-descriptor>" clause is
   used in a PRINT command.

   Channel 1 is used by default for  all  PRINT  commands  which  do  not
   specify  a  channel and is used when the "ON <file-descriptor>" clause
   appears in a PRINT command.  A default output PRINT  command  goes  to
   whatever  device  is assigned to channel 1, or to TTY: if no device is
   assigned.

   An "ON <file-descriptor>" clause INITs channel 1 to the specified file
   for  further  operations.   Directing  output  to a specified channel,
   including channel 1, without first INITing it gives an error  message.
   For example:
   GENERAL USE OF THE SYSTEM                                    Page 2-25
   Revision 4


        * PRINT ON 1 "HELLO"        _
        ? (FO3) Output to unassigned device        _ _____ ______ __ __________ ______
        * INIT 1 TTY:        _
        * PRINT ON 1 "HELLO"        _
        HELLO        _____



|  The 123 option assigns a channel to  which  subsequent  PRINT  ON  <n>
|  commands  direct  output  in  Lotus  1-2-3  worksheet file format (see
|  Chapter 12).  INIT 123 <n> must be  followed  by  a  file  descriptor.
|  INIT 123 <n> TTY:  produces an error message.
|  
|  The DIF option assigns a channel to  which  subsequent  PRINT  ON  <n>
|  commands  direct  output  in Data Interchange Format (see Chapter 12).
|  INIT DIF <n> must be followed by a file descriptor.  INIT DIF <n> TTY:
|  produces an error message.

   The APPEND option opens a file in APPEND mode so that an existing file
   is  extended,  not  rewritten.   The  file  is  created if it does not
   already exist.

   Channels are released when you  leave  1022  with  the  QUIT  or  EXIT
   command, or you give the RELEASE command:

        RELEASE [<n>]

   <n> is the channel to be released.  If <n> is omitted,  1022  releases
   all assigned channels.

   If the user leaves 1022 with  Control-C,  assigned  channels  are  not
   closed and files are not saved.



   2.5.5  Expressions

   System 1022 allows arithmetic  expressions  in  the  place  of  single
   values  in  most  commands.   For example, expressions may be given in
   PRINT lists and in the ADD, CHANGE, and FIND commands,  among  others.
   An  arithmetic  expression  may contain constants, literals, attribute
   names, user and 1022 defined variables (see the DEFINE  command),  and
   functions   (see  below).   These  quantities  are  connected  by  the
   arithmetic operators to express a resulting value.  Parentheses may be
   freely  used  for  clarity  or  to change the order of calculating the
   expression.  Spaces are ignored in  expressions  and  are  not  needed
   around  arithmetic operators.  A comma always separates one expression
   from the next but usually is not needed;  the  end  of  an  expression
   occurs when no arithmetic operator follows.

   The arithmetic operators are:

        * Multiplication
   GENERAL USE OF THE SYSTEM                                    Page 2-26
   Revision 4


        / Division
        + Addition
        - Subtraction and negation

   Parentheses  set  off  separate  subexpressions  which  are  evaluated
   completely  before  their  values  are  used in the larger expression.
   Examples of typical arithmetic expressions are:

        AGE-18
        100.0 + SALARY
        (A+B)/C +(1+AVG)/D

   Expressions are evaluated according to the following four rules:

   1.  The data items in an expression are read from left to right.  They
   are combined arithmetically as they are read, unless higher precedence
   operations  must  be  done  first.   Any  data  conversions  or   type
   conversions are done just before an item is combined with other items.


   2.  The left-to-right evaluation is interrupted to do operations  with
   a  high  precedence.   For  example,  *  (multiplication)  has  higher
   precedence than + (addition).  A group of items multiplied together is
   evaluated  before  the  result  is  added  to  an  earlier part of the
   expression.  A subexpression denoted by parentheses  has  the  highest
   precedence  and  is completely evaluated before its result is combined
   with the values around it.

   The precedence of the operations is:

        ( ... )  Subexpressions     Highest Priority
          * /    Multiply, Divide   Next lower
          + -    Plus, Minus        Lowest Priority

   For example, the rules tell how the following expression is  evaluated
   step by step:

        1)  1+3+5*2*(1+2)  becomes...
        2)  4  +5*2*(1+2)
        3)  4  +10 *(1+2)
        4)  4  +10 *3
        5)  4  +30
        6)  34             as the final answer.


   GENERAL USE OF THE SYSTEM                                   Page 2-26A
   Revision 4


   3.  The user may combine items of many types in one  expression.   (In
   FORTRAN  these  are called mixed mode expressions.) 1022 converts data
   from one type to another while it is evaluating the expression.  These
   are  called  type  conversions and are necessary to do the arithmetic.
   The types themselves have priorities;  INTEGER  type  has  the  lowest
   priority  and  REAL type has the highest.  The table of priorities for
   all the data types is:

        REAL                        Highest Priority Type
        DOUBLE PRECISION INTEGER
        INTEGER                     Lowest Priority Type

   When two quantities of different types  are  combined  arithmetically,
   the  lower  priority  type item is converted to the type of the higher
   priority type item.  Then the  arithmetic  is  performed,  yielding  a
   result  with  the  higher  priority type.  This result type is used in
   further computations.

   GENERAL USE OF THE SYSTEM                                   Page 2-26B
   Revision 4



























                     [ This page intentionally left blank ]
   GENERAL USE OF THE SYSTEM                                    Page 2-27
   Revision 4


   System 1022 maintains an expected data type as it scans an  expression
   from  left to right.  The expected data type starts as the type of the
   first term.  It changes when a term  of  a  higher  priority  type  is
   encountered.  Terms farther to the right are converted to the expected
   data type before arithmetic is done.  For example, a REAL  term  early
   in  an expression causes the rest of the expression to be evaluated as
   REAL.

   3/2 + 1.5         Evaluates to 2.5.  The division is done  in  integer
                     mode, yielding 1.

   1.5 + 3/2         Evaluates to 3.0.  The division is done in real mode
                     because it follows a real quantity.

   3/2 + 3.0/2 + 3/2 Evaluates to 4.0.  The first  division  is  done  in
                     integer  mode,  yielding  1.  Subsequent division is
                     done in real mode following the real quantity.

   A subexpression set off by  parentheses  is  evaluated  independently;
   the  expected  data type starts with the type of the first term in the
   subexpression.

   1.5 + (3/2)   Evaluates  to  2.5  (compare  to   just   above).    The
                 subexpression  is  evaluated  independently  as  integer
                 division.

   For example, let I be any integer quantity and R  any  real  quantity.
   If we keep track of only the resulting data types as the expression is
   evaluated, we get the following sequence:

        1)  R + I/I * (I + I)        This becomes ...
        2)  R + R/R * (I + I)
        3)  R + R   * (I + I)
        4)  R + R   * I
        5)  R + R   * R
        6)  R + R
        7)  R                             ...as the final type.

   No rounding is done in type conversions within arithmetic  expressions
   or  in  most assignments.  However, rounding is done if necessary when
   assignments of real values are made to display-real items.

   The PRINT and TYPE commands may apply a final type conversion to  each
   expression  being printed.  The expression is converted to the type of
   the first (leftmost) term in the expression before printing.   Compare
   the following examples to those above:

   PRINT 3/2 + 1.5       prints as 2;  the result of 2.5 is truncated.
   PRINT 1.5 + 3/2       prints as 3.0000000;   no  final  conversion  is
                           needed.

   SYSEXPTYPE  is  a  system  variable  which  controls  expression  type
   evaluation.  Its default value is zero.
   GENERAL USE OF THE SYSTEM                                    Page 2-28
   Revision 4


        Zero means that expressions are evaluated as described above.  In
        the  expression  1.5+3/2,  the  1.5  forces  the expression to be
        evaluated as real and thus it equals 3.0 .

        If the user sets SYSEXPTYPE to 1, 1022 does not use  an  expected
        data  type.   Conversions  are  done only when items of different
        types are combined.  In the above example, the 3/2  is  evaluated
        as an integer expression which equals 1.  Next 1.5+1 is evaluated
        as a real expression which equals 2.5.  Thus when  SYSEXPTYPE  is
        set to 1 the expression 1.5+3/2 equals 2.5.  This is identical to
        FORTRAN and COBOL rules of evaluation.

   Some conversions are not possible for all data values of the converted
   item.   For example, given the variables DI defined as DOUBLE INTEGER,
   and I defined as INTEGER:

        The command

             LET I EQ DI

        gives valid results for single precision values of DI, such as 1,
        or 1000, but gives an Integer Overflow error message and produces
        incorrect results for large values of DI, such as 40000000000.


   4.  An attribute may be a numeric value represented in  display  form,
   composed  of  ASCII  or  SIXBIT  characters.   These  display  numeric
   quantities may be used in expressions.  When they are evaluated,  1022
   first converts them to their computational form of the same data type.
   Display real becomes real for computation.   Display  integer  becomes
   integer for computation.



   2.5.5.1  Overflow, Underflow And Zero Division Handling

   System 1022  tests  all  computations  for  overflow,  underflow,  and
   division by zero.  Overflow is the production of a number too large to
   store as an item of the required type;  underflow is the production of
   too  small or negative a value.  These conditions set system variables
   and/or display appropriate warning messages.  The user can test  these
   system  variables  for  overflow,  underflow and zero division;  other
   system variables can suppress display of the warning messages.
   GENERAL USE OF THE SYSTEM                                    Page 2-29
   Revision 4


   2.5.5.1.1  Overflow And Underflow Conditions.

   If either condition occurs, 1022 prints one of the following  warnings
   in brackets:

        { Integer          }  { Overflow  }
        { Double Precision }  {           }
        { Floating         }  { Underflow }

   When an overflow occurs, 1022 uses the maximum possible  value;   when
   an underflow occurs, 1022 uses the minimum possible value.
   For example:

        * PRINT 1000000 * 1000000        _
        [Integer Overflow]        ________ _________
        34359738367        ___________

   To permit PL1022 programs to handle these error conditions, two system
   variables are available:  SYSOVFP and SYSOVF.

   SYSOVFP is initially set to 0.  It is set to  1  by  any  overflow  or
   underflow condition, and must be explicitly reset by LET SYSOVFP EQ 0.
   A new PL START command does not reinitialize SYSOVFP.

   SYSOVF is initially set to 0.  It is  set  to  1  by  an  overflow  or
   underflow  in  an  expression.  SYSOVF is reset to 0 automatically, by
   the next command containing an  arithmetic  operation  that  evaluates
   correctly.   A  command  containing  an  operation  that  overflows or
   underflows, followed by one or more operations  that  do  not,  leaves
   SYSOVF set.  For example:

        PRINT 99999999*99999999 1+1

   sets SYSOVF to 1;  the sequence:

        PRINT 999999999*999999999  1+1
        PRINT 1+1

   first sets SYSOVF to 1, then resets it to 0 at the  beginning  of  the
   expression in the second PRINT command.

   This means that SYSOVF records any overflow which may have happened in
   the previous command, and may be tested immediately to detect overflow
   conditions.  It automatically resets to  zero  for  the  next  command
   containing an arithmetic operation, so that it only reflects a current
   overflow, and not a past one.

   For example:

        00010     LET V1 EQ A*B.
        00020     LET V2 EQ C*D.
        00030     PRINT SYSOVF.
        00040     PRINT SYSOVFP.
   GENERAL USE OF THE SYSTEM                                    Page 2-30
   Revision 4


        00050     LET SYSOVFP EQ 0.
        00060     PRINT SYSOVF.
        00070     LET I EQ 1+1.
        00080     PRINT SYSOVF.

        Lines 10 and 20 contain statements which might cause an overflow.
        Assume Line 20 causes an overflow or underflow.

        Line 30 can only test an overflow from line 20.   SYSOVF  retains
        only  the  overflow state from the most recent command containing
        an  arithmetic  operation  or  conversion.   Line  40  tests  the
        permanent  flag,  and  so tests whether any overflow has occurred
        since last clearing SYSOVFP.  Line 50 clears the  permanent  flag
        for further use.  Line 60 prints the value 1, since no arithmetic
        expression or conversion intervenes between it and line 20.  Line
        70  contains  an  arithmetic  expression,  whose normal execution
        causes line 80 to print 0.




   2.5.5.1.2  Suppressing Overflow/Underflow Messages

   The system  variable  SYSOVFMSG  controls  printing  of  overflow  and
   underflow  warning  messages.   The  default  value  of  0  causes the
   messages  to  be  displayed;   the  value  1  causes  messages  to  be
   suppressed.  In either case, the values of both SYSOVFP and SYSOVF are
   set and reset as discussed above.



   2.5.5.1.3  Zero Division Handling.

   System 1022 checks all computations for division of a non-zero  amount
   by zero.  When this occurs, the warning message

        [Division by zero]

   is  displayed.   The  value  zero  is  used  as  the  result  of   the
   computation.

   The expression 0/0 is legal, and does not set  the  division  by  zero
   error message.  The result of 0/0 is 0.

   Two system variables record the zero divide condition:

   SYSDIVP flags division by zero in the same manner that  SYSOVFP  flags
   overflow/underflow.  SYSDIVP is initially set to 0.  It is set to 1 by
   any division by zero, and may be reset  to  0  with  the  command  LET
   SYSDIVP EQUAL 0.  A new PL START command does not reinitialize SYSDIVP
   to 0.

   SYSDIV records division by zero in the same way  that  SYSOVF  records
   GENERAL USE OF THE SYSTEM                                    Page 2-31
   Revision 4


   overflow/underflow.   SYSDIV is initially set to 0.  It is set to 1 by
   an error division by zero in an expression, and is automatically reset
   to 0 by the next command containing an operation.



   2.5.5.1.4  Suppressing Division-By-Zero Warning Messages

   The  system  variable  SYSDIVMSG  controls   the   printing   of   the
   division-by-zero  warning  message.  The default value of 0 causes the
   messages to be displayed;  the value  1  causes  the  messages  to  be
   suppressed.  In either case, the values of both SYSDIVP and SYSDIV are
   set and reset in the same manner as are SYSOVFP and SYSOVF.



   2.5.6  Comparison Of Expressions

   When an expression is compared to another  value,  the  expression  is
   converted to the same type as the value being compared.

   As an example of a comparison, the command

        IF NEWSUM LE 2.0*OLDSUM THEN ...

   compares the two expressions.  It takes the TRUE action if the integer
   value  NEWSUM  is  less than or equal to the truncated integer part of
   2.0*OLDSUM (a real type value).  In comparisons, the second expression
   is always changed to match the type of the first expression.

   Be careful  about  comparing  real  expressions  for  equality.   Real
   expressions  are sensitive to the exact order and values of items that
   make them up.  Minor round-off errors in real arithmetic  (unavoidable
   in  the  computer)  may cause two expressions which are mathematically
   equal to actually differ  by  very  small  amounts.   This  causes  an
   unequal comparison where the user might expect an equal one.  The user
   can expect real expressions to come close, but not to be exact in  all
   cases.



   2.5.7  Storing Expressions

   Values  of  expressions  stored  into  variables  or  used  to  change
   attributes  are  converted  to  match  the  type  of  the  variable or
   attribute.

   When a computational numeric value is used  to  set  the  value  of  a
   display numeric attribute, 1022 produces the display form of the value
   and sets the attribute to this display result.  A  warning  is  issued
   and  a  truncated value is used if the receiving display numeric field
   is too small.
   GENERAL USE OF THE SYSTEM                                    Page 2-32
   Revision 4


   2.5.8  Date Expressions

   Date variables, attributes, and constants may appear  in  expressions.
   The underlying value in a date item is the integer number of days past
   1/1/1800 that represents that date.  For example, the date  "1/5/1800"
   has the underlying value of 4.

   The user  may  add  and  subtract  numeric  values  from  dates;   the
   resulting  date  is  that  number  of  days  sooner  or later than the
   starting date.  If the user subtracts two dates, the  result  is  type
   integer and is the number of days between the two dates.

   The following table gives the allowed combinations of dates with other
   data  types.   Other combinations are illegal.  "I" stands for integer
   or double integer, "R"  for  real,  and  "D"  for  date.   Values  are
   converted to integer first when they are combined with dates.


              TABLE 2-1. COMBINING DATES WITH OTHER DATA TYPES


        TYPE   OPERATORS     TYPE   RESULT TYPE    COMMENT        ____   _________     ____   ______ ____    _______

        D      (-)           D      Integer        Interval in days

        D      (+,-)         I,R    Date           Adjust the date,
                                                   real is converted
                                                   to integer first.

        I,R    (+)           D      Date           Adjust the date.


   The user need not enclose any single  date  in  quotation  marks  when
   using  date  values  in  the  FIND,  SEARCH,  SELECT,  ADD, and CHANGE
   commands.  This simplifies the typing of these commands.  For example:

        FIND STARTDAY BETWEEN 1/1/80 2/1/80

   When using a date constant in other  commands,  the  user  encloses  a
   single  date  constant  in  quotation  marks to distinguish it from an
   arithmetic expression.   In  the  following  examples,  the  enclosing
   quotation marks make these valid date constants:

        PRINT "MAY 1,1978"   "5/1/78"

   In all commands, the user must enclose a date  constant  in  quotation
   marks  when it appears in an expression.  This distinguishes it from a
   series of operations.  For example:

        CHANGE NDATE "1/1/1970" + INTERVAL

   Users should not put quotation marks around a numeric constant that is
   in  legal date form unless they want 1022 to interpret the constant as
   GENERAL USE OF THE SYSTEM                                    Page 2-33
   Revision 4


   a date.  For example, the command "PRINT '12345'", prints "1/23/1945".
   If  this  constant  were  not  enclosed in quotation marks, 1022 would
   interpret the constant as type integer and would print "12345".

   A PRINT command displays the results of expressions in the  data  type
   of the first term of the expression.  The result of an expression thus
   may be automatically converted by the PRINT command.

   Example:

        * PRINT DOE DOC (DOE-DOC) DOC-DOE $INT(DOE-DOC)
        12/29/1980  12/28/1980  1/02/1800  9/22/2517 1
        * PRINT 1+DOE DOE+1
        66107   12/30/1980

   In this example the result of DOE-DOC is 1;  PRINT  converts  this  by
   adding  1  day to the minimum date of 1/1/1800.  The result of DOC-DOE
   is -1;  PRINT converts negative integers to dates by subtracting  from
   the maximum date of 9/23/2517.  The integer 66107 is 1 plus the number
   of days between 1/1/1800 and 12/29/1980.



   2.5.9  System Functions

   System functions perform commonly  needed  tasks  and  generalize  the
   handling  of  quantities  in expressions.  Function names begin with a
   dollar  sign  to  distinguish   them   from   user   variables.    For
   compatibility  with older versions of 1022, the user may refer to some
   functions without preceding them with a dollar sign.  The following is
   a list of system functions:

      Totals Functions           Process values from many records to form
                                 a total or quantity that is derived from
                                 the entire record group.

      Arithmetic Functions       Perform a complex arithmetic operation.

      Conversion Functions       Control  data   type   conversions   for
                                 flexibility in handling data.

      Text Conversion Functions  Convert values to type text and  perform
                                 right  or  left  justification  within a
                                 receiving field.

      String Functions           Manipulate text values.

      Date Functions             Break down, build, and manipulate dates.

      Monitor Functions          Retrieve values from the monitor.

   A system function is used by giving the function name followed  by  an
   argument  list.   Each element in the list may be an expression.  If a
   GENERAL USE OF THE SYSTEM                                    Page 2-34
   Revision 4


   system function has more than one argument, the user must enclose  the
   argument  list  in  parentheses.   If  a  system function has only one
   argument, it is not necessary to enclose the argument in  parentheses.
   For example:

         $TOT SALARY
         $BDAYS("3/1/80","4/30/80")


   System functions may be used in a general  way  to  form  expressions.
   The entire function group is used in the same way that any variable is
   used.  A totals function cannot be in an argument  to  another  totals
   function.

   Examples:

        $TOT SALARY+BONUS             These are equivalent.
        $TOT(SALARY+BONUS)

        $TOT (SALARY)/$TOT(BONUS)     These are equivalent.
        ($TOT SALARY)/$TOT BONUS

        $TOT SALARY*$TOT BONUS        These are illegal.                                                _______
        $TOT SALARY * ($TOT BONUS)

        $TOT (SALARY)*$TOT BONUS      These are correct.
        ($TOT SALARY)*($TOT BONUS)




   2.5.9.1  Totals And Statistics Functions


   The totals functions generate a value which depends on many records in
   a  data  set.   Typically this is all records in the current selection
   group, or all records selected by an ON CHANGE command  in  a  report.
   These  functions  imply a background process in which values from many
   records are collected and evaluated  and  are  the  primary  means  of
   generating  totals  in  1022.  They are:  $TOT, $MEAN, $MIN, $MAX, and
   $STDEV.

   The full descriptions of the functions are:

   $TOT   The expression is formed  over  all  records  in  the  selected
          group.   The  expression is evaluated once for each record, and
          each result is added into the total that is formed.

          The resulting sum  has  the  same  type  as  the  type  of  the
          expression.  If the expression is real, the total is type real.
          If the expression is integer, the total is type  integer.   The
          expression type flows through the function to the result.
   GENERAL USE OF THE SYSTEM                                    Page 2-35
   Revision 4


          The expression "$TOT 1" is a way to count how many records  are
          in  the  group.   The constant expression "1" is added into the
          result once for each record in the group.

   $MEAN  The arithmetic mean of the expression is  calculated  over  the
          records  in  the  group.   The  result  is  always  type  real,
          regardless of the argument.  This is the same as:

               $TOT (expression)/$TOT 1.0

          If there are no records in the group, the result is 0.0.

   $MIN   The minimum  or maximum  value of  the expression  for  all the
   $MAX   records in the group is generated as the result.  The  type  of
          the  argument  flows  through to become the type of the result.
          Only numeric arguments are allowed.

   $STDEV The standard deviation of the expression is calculated from the
          values  that  the  expression  attains  for  the records in the
          group.  The standard deviation for a set of values  is  defined
          by the formula:


                                          ( V(I) - VMEAN )**2
                SQUARE ROOT ( SUM OVER I ( ------------------- ) )
                                               N - 1


          V(I) is the value for the Ith record in the group, VMEAN is the
          arithmetic  mean  of  all  the  values,  and N is the number of
          records in the group.

          The computational formula used by 1022 is:

                             SUM OVER I ( V(I)**2 ) - N * VMEAN**2
               SQUARE ROOT ( ------------------------------------- )
                                           N-1

          The result of $STDEV is type real regardless of the type of the
          argument.   If  there  are  fewer  than  two record values, the
          result is zero.

   GENERAL USE OF THE SYSTEM                                    Page 2-36
   Revision 4


   2.5.9.2  Arithmetic Functions


   The arithmetic function $SQRT computes the square root of the value of
   the  expression  which  is its argument.  If the argument is negative,
   the absolute value of the argument is used to compute the result and a
   warning  is issued.  The result is type real regardless of the type of
   the argument.

   The arithmetic function  $SQ  computes  the  square  of  a  number  by
   multiplying  it  by  itself.   The  result  has  the  same type as the
   argument.

|  The  arithmetic  function  $LOG10  calculates  the  logarithm  of  the
|  argument  to  base  ten.   Another  logarithmic system function, $LOG,
|  calculates the natural logarithm  (base  e)  of  the  argument.   $EXP
|  calculates  the  base  e  exponential  of the argument.  Each of these
|  three functions takes a single argument that is converted to  a  real,
|  and the results returned are reals.
|  
|  The $MOD function takes  two  arguments  separated  by  a  comma.   It
|  converts these to integers and then returns the integer remainder that
|  results from the division of the first argument by the second.



   2.5.9.3  Conversion Functions


   The conversion functions give the user  control  over  the  data  type
   conversions  which  are ordinarily done automatically by the system in
   evaluating expressions.

   The conversion functions take an expression of any type and return the
   converted  value  of  the  desired  type.   They  may  be  used  to do
   nonstandard conversions in special situations.  For  example,  if  the
   user  wants the integer value of a date item (the number of days since
   January 1, 1800) this can be recovered as an integer  for  computation
   by using "$INT(date-item)" in the expression.

   The user may also do conversions of text items.   When  a  text  field
   contains  characters  that  satisfy  the  requirements  for  a numeric
   display constant, then a  conversion  function  extracts  the  numeric
   value.   If  the field has illegal characters or form, then a run-time
   conversion error results.  The arguments to a conversion function  may
   be arithmetic expressions, possibly including other conversions.
   GENERAL USE OF THE SYSTEM                                    Page 2-37
   Revision 4


   The conversion functions are:

     $INT(arg)              Converts  its  argument  expression  to  type
                            integer.   Real expressions are truncated and
                            their integer part taken.

     $REAL(arg)             Converts  its  argument  expression  to  type
                            real.

     $DINT(arg)             Converts  its  argument  expression  to  type
                            double   integer.    This   is   useful   for
                            generating double  precision  integer  totals
                            from  a  list of single precision values.  By
                            computing the total of $DINT(expression)  the
                            result is double precision.

|    $DATE(arg)             Converts an expression  to  an  integer  (I),
|                           which  is  then  converted  to  a  1022  date
|                           representing I days since 1/1/1800.
|  
|    $DECODE(arg[,byte-size]) Converts its first  integer  argument  from
                            binary    representation   to   ASCII.    The
                            byte-size argument is 6 for SIXBIT or 7  (the
                            default).  Arguments other than 6 or 7 return
                            an error.  $DECODE is useful  for  retrieving
                            monitor   table   values   with  $GETAB  (see
                            "Monitor Functions" below).

   Examples:

        EXPRESSION                         RESULT
        ----------                         ------

        $INT(1.9)                          1
        $INT(1.0)                          1
        $INT-1.0                           -1
        $INT(-1.5)                         -1

        $DINT(1350000)*1000000             1350000000000

        $TOT($DINT(IVAL))                  Produces  the  double  integer
                                           total  of the integer quantity
                                           IVAL.

        $DINT(I1) + I2                     Produces  a   double   integer
                                           result  because  one  term  is
                                           double integer.

        $DATE(1.45)                        1/2/1800

|       $DECODE(-29197860864,6)            "DSK" is the ASCII  equivalent
|                                          of the SIXBIT binary number.
   GENERAL USE OF THE SYSTEM                                    Page 2-38
   Revision 4


|       $DECODE(-31784737320)              "Devel"    is    the     ASCII
|                                          equivalent   of   the   binary
|                                          number.  Default byte size  is
|                                          7.
|  
|       $DECODE(-31784737320,7)             "Devel"    is    the    ASCII
|                                          equivalent   of   the   binary
|                                          number.

   SYSCVTERR is  a  system  variable  that  records  run-time  conversion
   errors.   It  is  initially  set  to  0.  It is set to 1 by a run-time
   conversion error and must be explicitly reset to 0 to  detect  further
   errors.

   SYSCVTMSG is a system variable that controls display of  the  run-time
   conversion  error message.  When SYSCVTMSG is 0, 1022 signals run-time
   conversion errors by displaying an error message.  When  SYSCVTMSG  is
   1, 1022 suppresses run-time error message display.  Programs often use
   SYSCVTMSG is suppress  the  error  message  and  SYSCVTERR  to  detect
   errors.



   2.5.9.4  Text Conversion Functions


|  System 1022 now supports  three  text  conversion  functions:   $TEXT,
|  $TEXTR, and $TEXTL.
|  
|  
|  
|  2.5.9.4.1  $TEXT
|  
|  The $TEXT function converts  its  argument  to  a  text  string.   The
|  argument  may  be  any  System 1022 expression.  Input of type DATE is
|  converted to ANSII-standard format (YYYYMMDD).  Numeric constants  are
|  interpreted  as  dates if they are in legal date form and are enclosed
|  in quotation marks.   When  $TEXT(arg)  is  an  expression  in  a  LET
|  command,  the  result  is  padded  to  length  with trailing blanks if
|  necessary.  Strings resulting from input of type TEXT  are  truncated,
|  if  necesaary,  while numeric input whose length exceeds the length of
|  the variable produces an error.
|  
|  The following examples illustrate the ways in which $TEXT may be used,
|  assuming that ID is an integer attribute and FOO is a text variable of
|  length 10.
|  
|       * PRINT $TEXT(' abc ')
|        abc
|       *PRINT $TEXT(' abc '+' def ')
|        abc  def
|  
|       * PRINT $TEXT(ID)
   GENERAL USE OF THE SYSTEM                                    Page 2-39
   Revision 4


|       62135
|       * PRINT $TEXT(ID)+$TEXT(ID)
|       6213562135
|  
|       * LET FOO $TEXT(ID)
|       * PRINT FOO
|       62135
|       * PRINT FOO+FOO
|       62135     62135
|  
|       * LET FOO 'ID: '+$TEXT(ID)
|       * PRINT FOO
|       ID: 62135
|  
|  It is in cases like the last one cited  that  $TEXT  is  most  useful,
|  providing  an  easy  way to concatenate a value converted to text with
|  some other value in a single text variable.
|  
|  
|  
|  2.5.9.4.2  $TEXTL And $TEXTR
|  
|  Like $TEXT, each of these functions converts its argument  to  a  text
|  string.   The  argument may be any System 1022 expression.  The format
|  of the result depends on the command and  on  the  complexity  of  the
|  expression in which the function appears.
|  
|  When  $TEXTR(arg)  appears  in  a  PRINT  command,   the   result   is
|  right-justified  to  the  default  length for the argument type.  When
|  $TEXTL(arg) appears in a PRINT command, the result  is  left-justified
|  to  the  default  length for the argument type.  Input of type DATE is
|  converted to ANSII-standard format (YYYYMMDD).  Numeric constants  are
|  interpreted  as  dates if they are in legal date form and are enclosed
|  in quotation marks.  The default field lengths are as follows:
|  
|       Type        Default Field Length        ____        _______ _____ ______
|  
|  Text             Same length as argument
|  Integer          12
|  Real             12
|  Date             8
|  Double Integer   24
|  
|  Output strings are padded to length, if necessary, with leading blanks
|  in  the  case  of  $TEXTR(arg) and with trailing blanks in the case of
|  $TEXTL(arg).
|  
|  When $TEXTL(arg) appears as the single expression in  a  LET  command,
|  the result is left-justified in the receiving field.  When $TEXTR(arg)
|  appears as the single expression in  a  LET  command,  the  result  is
|  right-justified  in the receiving field.  Output strings are padded to
|  length, if necessary, with leading blanks in the case  of  $TEXTR(arg)
|  and  with  trailing  blanks  in  the  case  of  $TEXTL(arg).   Strings
   GENERAL USE OF THE SYSTEM                                    Page 2-40
   Revision 4


|  resulting from input of type TEXT are truncated if necessary, from the
|  left  in  the case of $TEXTR and from the right in the case of $TEXTL.
|  Numeric input whose length exceeds the length of the variable produces
|  an error message.
|  
|  $TEXTL and $TEXTR perform exactly like $TEXT when  either  appears  as
|  part  of  a  concatenated or nested expression in a LET command.  That
|  is, the argument is converted to a text string with  no  justification
|  or  padding.   As with other LET assignments, System 1022 will pad the
|  result of the evaluation of the expression as a whole if necessary.
|  
|  The following examples illustrate the ways in which $TEXTL and  $TEXTR
|  may  be used, assuming that ID is an integer attribute of length 8 and
|  FOO is a text variable of length 10.
|  
|       * PRINT $TEXTL(' abc ')
|       abc
|       * PRINT $TEXTR(' abc ')
|         abc
|       * PRINT $TEXTL(' abc ')+$TEXTR(' abc ')
|       abc   abc
|  
|       *PRINT $TEXTL(ID)
|       62135
|       * PRINT $TEXTR(ID)
|              62135
|       * PRINT $TEXTL(ID)+$TEXTR(ID)
|       62135              62135
|  
|       * LET FOO $TEXTL(ID)
|       * PRINT FOO
|       62135
|       * LET FOO $TEXTR(ID)
|       * PRINT FOO+FOO
|          62135   62135
|  
|       * LET FOO $TEXTL(ID)+$TEXTR(ID)
|       * PRINT FOO
|       6213562135



   2.5.9.5  String Functions

   String functions manipulate TEXT values from attributes and variables.
   They   combine   strings,  return  the  length  of  a  string,  return
   substrings, strip and count spaces, center strings, change  case,  and
   search, insert, and replace strings.

   The string functions work in interactive 1022 wherever  functions  are
   allowed.   They  are  commonly used with LET, PRINT, FIND, and SEARCH.
   With one limitation, these functions work with the SORT command.  They
   are available to the host language interface through DBEXEC calls.
   GENERAL USE OF THE SYSTEM                                    Page 2-41
   Revision 4


   Errors in arguments to string functions set the error flags SYSOVF and
   SYSOVFP to 1.  System 1022 prints the message:

        [Error in argument to STRING function].

   The printing of this message can be disabled by setting  SYSOVFMSG  to
   1.   A  string  function  returns  a  null string for text or zero for
   integers when such errors occur.

   When the value supplied by a string function in a FIND, ADD, or CHANGE
   command  is  too  long, 1022 truncates the value to the proper length.
   This causes no error or warning message.

   The TEXT arguments in string functions may be  variables,  attributes,
   literals,  or  TEXT  expressions.   Arguments  of  other  types can be
   converted to TEXT with  the  $TEXTL  and  $TEXTR  functions.   DISPLAY
   numeric   arguments  are  not  treated  as  TEXT.   INTEGER  arguments
   (represented by m and n in the following syntax diagrams) are  greater
   than   or  equal  to  zero  and  may  be  integer  variables,  integer
   expressions, or integers.  String functions may be nested.

   String character positions are numbered left to right starting with 1.
   When  a  string  result  is written into a TEXT variable, it is padded
   with spaces on the right if it is smaller than the variable, and it is
   truncated on the right if it is larger than the variable.

   The following list describes  each  string  function.   A  hyphen  (-)
   represents a blank in these examples.

   + (plus)   text1 + text2

              The "+" sign concatenates text strings.

              "Abcd"+"efgh" returns Abcdefgh.


   $REPEAT    $REPEAT(text1,n)

              Returns a string which is the concatenation of n copies  of
              text1.

              $REPEAT("abc",3) returns abcabcabc.


   $LEN       $LEN(text1)

              Returns the integer value for  the  length  of  text1.   It
              returns  the  defined  length  of attributes and variables.
              Use the $RTRIM function with $LEN to return the  length  of
              the characters stripped of trailing blanks.

              $LEN("Abcdefgh") returns 8.
              $LEN(SURNAME) returns 12  when  the  attribute  SURNAME  is
   GENERAL USE OF THE SYSTEM                                    Page 2-42
   Revision 4


                  defined as length 12.
              $LEN($RTRIM(SURNAME)) returns 5  when  the  value  for  the
                  attribute SURNAME is Jones-------.


   $CHAR      $CHAR(n)

              Returns the one-character text string of the character with
              the  ASCII  code  n.   The value of n must be between 0 and
              127.

              $CHAR(99) returns c, the character equivalent of ASCII code
              99.


   $ICHAR     $ICHAR(text1 [,n])

              Returns the ASCII code of the nth character of text1.   The
              default value of n is 1.

              $ICHAR("abcd",3) returns 99, the ASCII code for c.
              $ICHAR("abcd") returns 97, the ASCII code for a.


   $LEFT      $LEFT(text1,n)
   $RIGHT     $RIGHT(text1,n)

              Truncates or pads a string to return  a  substring  of  the
              left  or  right n characters.  If n is less than the length
              of text1, the result is the left or right n characters.  If
              n  is  greater  than  the length of text1, text1 is left or
              right justified in a field of length n filled with blanks.

              $LEFT("Abcdefgh",4) returns Abcd.
              $RIGHT("Abcdefg-",4) returns efg-.
              $LEFT("Abcd",8) returns Abcd----.
              $RIGHT("Abcd",8) returns ----Abcd.

   $RSTRING   $RSTRING(text1)

              Keeps only the rightmost characters of text1 that fit  into
              a  smaller  receiving  field.   It  works  only  in LET and
              EVALUATE commands.  Without the string function, 1022 keeps
              the leftmost characters.

              * DEF TEXT 5 A
              * LET A EQ "ABCDEF-"
              * PRINT A
              ABCDE
              * LET A EQ $RSTRING "ABCDE-"
              * PRINT A
              BCDE-
   GENERAL USE OF THE SYSTEM                                    Page 2-43
   Revision 4


              This is equivalent to LET A EQ $RIGHT("ABCDE-",$LEN(A)).


   $SUBSTR    $SUBSTR(text1,m,n)

              Returns the substring from position m to position  n.   The
              value of n must be greater than or equal to m.

              $SUBSTR("Abcdefgh",4,6) returns def.


   $LTRIM     $LTRIM(text1)
   $RTRIM     $RTRIM(text1)
   $TRIM      $TRIM(text1)

              Removes all spaces from the left, right, or both  sides  of
              text1.

              $LTRIM("---Abcdefgh---") returns Abcdefgh---.
              $RTRIM("---Abcdefgh---") returns ---Abcdefgh.
              $TRIM("---Abcdefgh---") returns Abcdefgh.


   $CENTER    $CENTER(text1,n)
   $CENTRE    $CENTRE(text1,n)

              Centers text1 in a field of n spaces.  The value of n  must
              be  greater  than  or equal to the length of text1.  If the
              text cannot be exactly centered, one extra space is on  the
              right  side of text1 in the result.  The effects of $CENTER
              and $CENTRE are identical.

              $CENTER("Abcdefgh",12) returns --Abcdefgh--.
              $CENTER("Abcdefgh",13) returns --Abcdefgh---.


   $BLANKS    $BLANKS(n)

              Returns a string of spaces n characters long.  If n  is  0,
              it returns a null string.

              $BLANKS(5) returns "-----".


   $CAPS      $CAPS(text1)

              Returns text1 with all the alphabetic characters  converted
              to upper case.

              $CAPS("Abcdefgh") returns ABCDEFGH.


   GENERAL USE OF THE SYSTEM                                    Page 2-44
   Revision 4


   $LOWER     $LOWER(text1)

              Returns text1 with all the alphabetic characters  converted
              to lower case.

              $LOWER("abCDefG") returns abcdefg.


   $MIXED     $MIXED(text1)

              Returns text1 with the first character converted  to  upper
              case  and  subsequent  characters  converted to lower case.
              Only alphabetic characters are  converted.   If  the  first
              character  is not alphabetic, all alphabetic characters are
              converted to lower case.

              $MIXED("abCDefG") returns Abcdefg.
              $MIXED("9 DAYS") returns 9 days.


   $NULL      $NULL

              Returns a null string.  See $REPALL below for an example.


   $FIND      $FIND(text2,text1 [,n][,m])

              Searches for occurrence m of text2  in  text1  starting  at
              character  position  n  and returns the integer position of
              the first character of the  specified  substring.   If  the
              substring  is  not  found,  the  function  returns  0.  The
              default values for m and n are 1.  The current  setting  of
              SYSCASE  controls  whether  upper and lower case characters
              match.

              $FIND("bc","Abcdefgh") returns 2.

              $FIND("b","Abcdefgh-Abcdefgh",3) returns 11,  the  position
                  of the first occurrence of "b" after position 3.

              $FIND("a","Abcd-Abcd-Abcd",3,2) returns 11, the position of
                  the 2nd occurrence of "a" after position 3.


   $INSERT    $INSERT(text2,text1,n [,m])

              Inserts  text2  at  position  n  in  text1,   replacing   m
              characters.   The  default value of m is 0.  The value of n
              must be less than or equal to (length of text1)+1.

              $INSERT("bc","Adefgh",2) returns Abcdefgh.
              $INSERT("bc","Axxxdefgh",2,3) returns Abcdefgh.
   GENERAL USE OF THE SYSTEM                                    Page 2-45
   Revision 4


   $REPLACE   $REPLACE(text2,text3,text1 [,n])

              Replaces the nth occurrence of text2 with text3  in  text1.
              The  default  value  of  n  is  1.   The current setting of
              SYSCASE controls whether upper and  lower  case  characters
              match.

              $REPLACE("xxx","bc","Axxxdefgh") returns Abcdefgh.
              $REPLACE("xxx","bc","Axxxcd-Axxxcd",2) returns Axxxcd-Abcde
                  replacing the 2nd occurrence of "xxx" with "bc".


   $REPALL    $REPALL(text2,text3,text1)

              Replaces all occurrences of text2 with text3 in text1.

              $REPALL("xx","bc","axxaxxaxx") returns abcabcabc.
              $REPALL("ABA","MAMA","ABABAB") returns MAMABAB.
              $REPALL ("-",$NULL,"617-661-9440") returns 6176619440.


   The following are examples of common string function applications:

   (1) A PL1022 program accepts user entries for  department  name.   The
       string  functions  in  the following program fragment allow a wide
       range of formats for the user entry.

            DEFINE TEXT 15 DEP
            PRINT "WHICH DEPARTMENT?"
            ACCEPT DEP
            FIND DEPARTMENT CONTAINS $CAPS($TRIM(DEP))

       In the data set the  DEPARTMENT  attribute  has  ACCOUNTING  as  a
       value.  User entries of "Accounting", "ACC", "Acco", "accounting",
       "Account", "----acc", and others  with  and  without  leading  and
       trailing  blanks  will  match  because  the string functions strip
       spaces from the variable and convert it to upper case.


   (2) In a report you wish to print only the first initial  rather  than
       the  whole  attribute  FIRSTNAME (FN) and then print SURNAME.  You
       can do this by using a string function to return  only  the  first
       character of FN.

            PRINT $LEFT(FN,1) SURNAME


   GENERAL USE OF THE SYSTEM                                    Page 2-46
   Revision 4


   2.5.9.5.1  String Functions In SORT


   The SORT command requires that values being sorted be all of the  same
   length.   When SORT is used with string functions that produce results
   of different lengths, 1022 issues an error message.  A combination  of
   string  functions  using  functions  like $LEFT can be used to produce
   results  of  a  consistent  length  for  sorting.   For  example,  the
   following command successfully sorts concatenated attributes:

        SORT $LEFT($TRIM(attribute1)+$TRIM(attribute2),20)

   The $TRIM functions  strip  leading  and  trailing  blanks  from  each
   attribute.   The  +  function concatenates the two attributes into one
   string.  And the $LEFT function with the argument 20 truncates or pads
   the  concatenated  attributes to a uniform length of 20 for successful
   sorting.



   2.5.9.6  Date Functions


   Date  functions  manipulate  dates  and  date-related  arguments.   In
   addition,  date  functions  convert  a  month, day, and year to a 1022
   date.

   Errors in arguments to date functions set the error flags  SYSOVF  and
   SYSOVFP to 1.  System 1022 prints the following message:

         [Error in argument to date function]

   The user disables  the  printing  of  the  error  message  by  setting
   SYSOVFMSG  to  1.  When an error occurs and the result of the function
   was to be an integer, 1022 returns zero.  If the result was  to  be  a
   date,  1022  returns  ten  blanks  for  1/1/1800  which  is  the  date
   equivalent of zero.

   The following list describes each date function:

   $YEAR      $YEAR(date)

              Extracts the year from a date and returns it as an integer.

              $YEAR("2/15/80") returns 1980.


   $MONTH     $MONTH(date)

              Extracts the ordinal month from a date and returns it as an
              integer.

              $MONTH("2/15/80") returns 2.
   GENERAL USE OF THE SYSTEM                                    Page 2-47
   Revision 4


   $DAY       $DAY(date)

              Returns the day of the month as an integer.

              $DAY("2/15/80") returns 15.


   $YDAY      $YDAY(date)

              Returns the ordinal day of the year as an integer.

              $YDAY("2/15/80") returns 46.


   $WDAY      $WDAY(date)

              Returns the ordinal day of the week as an integer.   Monday
              is 1, Sunday is 7.

              $WDAY("2/15/80") returns 5.


   $FMONTH    $FMONTH(date)

              Returns the date corresponding to  the  first  day  of  the
              month.

              $FMONTH("2/15/80") returns 2/01/1980.


   $LMONTH    $LMONTH(date)

              Returns the date corresponding  to  the  last  day  of  the
              month.

              $LMONTH("1/15/80") returns 1/31/1980.
              $LMONTH("2/15/80") returns 2/29/1980.


   $BDAYS     $BDAYS(date1,date2)

              Returns the number of business days (weekdays) between  and
              including  two specified dates.  If "date1" is greater than
              "date2", a negative result is returned, excluding  the  two
              dates.  1022 does not account for holidays.

              $BDAYS("2/15/80","3/15/80") returns 21.


   $MDYDATE   $MDYDATE(month,day,year)

              Converts a month, day, and year to a  1022  date.   If  the
              year  is  specified as two digits between 0 and 99, 1900 is
   GENERAL USE OF THE SYSTEM                                    Page 2-48
   Revision 4


              added to it.  The result of this argument is a date.   This
              function changes dates by numbers of months or years.

              The resulting day is bounded by the resulting month.

              ARGUMENT                     RESULT              ________                     ______

              $MDYDATE(2,31,1980)          2/29/1980

              $MDYDATE(2,31,1981)          2/28/1981

              $MDYDATE(2,-5,1980)          2/1/1980

              To change a date by a number of months,  the  user  adds  N
              months to a date.  For example:

              LET D EQ $MDYDATE( $MONTH(D)+N, $DAY(D), $YEAR(D) ).

              The  month  argument  to  $MDYDATE  can  be  any   integer.
              Arguments  that  fall outside of the 1-to-12 range cause an
              adjustment to the resulting year.  For example:


              ARGUMENT                RESULT              ________                ______

              $MDYDATE(0,30,1980)     12/30/1979

              $MDYDATE(26,31,1980)    2/28/1982


              To change a date by a number of years,  the  user  adds  an
              expression to the $MDYDATE year argument.

              The user should not use $MDYDATE to add a fixed  number  of
              days  to a date.  To change a date by a number of days, the
              user adds the number of days directly to the date  using  a
              LET  command.   For example, the following command produces
              the date that is 45 days later than the original date:

                   LET DATE1 EQ DATE1+45

              The day argument of the $MDYDATE function is bounded by the
              month  of  the  result.   A day argument that is out of the
              normal range is adjusted to the nearest legal  day  of  the
              resulting  month.   This does not affect the calculation of
              month and year.

              If the user added 45 to  the  $MDYDATE  day  argument,  the
              resulting date would not be the date that is 45 days later.
              The result would be  the  last  legal  date  in  the  month
              determined by the other $MDYDATE arguments.
   GENERAL USE OF THE SYSTEM                                    Page 2-49
   Revision 4


   $VDATE     $VDATE(month,day,year)

              Verifies that the user has specified three legal arguments.
              If  the  month,  day,  and year are legal, 1022 returns the
              integer value zero.

              If  1022  rejects  any  of  the  arguments,  it  returns  a
              corresponding argument number:

                    Illegal month: 1
                    Illegal day:   2
                    Illegal year:  3

              The priority for the error code is year, then  month,  then
              day.   If  more  than one argument is illegal, 1022 returns
              the error code in that order.

              $VDATE(-1,-1,-1) returns 3, the error code for year.
              $VDATE(-1,-1,80) returns 1, the error code for month.
              $VDATE(2,-1,80) returns 2, the error code for day.


   $JULDATE   $JULDATE(integer expression)

              Converts a  Julian  date  to  a  1022  date.   The  integer
              expression evaluates to an integer of the form yyyyddd.

              $JULDATE(1980046) returns 2/15/1980.


   $DATEJUL   $DATEJUL(date)

              Converts a 1022 date to a Julian date.  The  result  is  an
              integer.

              $DATEJUL("2/15/80") returns 1980046.


   The following are two applications of date functions.

   A user wants to know the date of the last working day  of  the  month.
   If the last day of the month falls on a weekday, then that is the last
   working day.  If the last day of the month is a  Saturday  or  Sunday,
   then  the  last  working day is the previous Friday.  In the following
   program fragment the date variable LWD is the last working day of  the
   present month.
   GENERAL USE OF THE SYSTEM                                    Page 2-50
   Revision 4


         !Assign LWD to be the last day of the month.
         LET LWD EQ $LMONTH(SYSDATE).
         !Now determine if LWD is a week day.
         IF $WDAY(LWD) LT 6 GOTO OK.
         !Subtract the number of weekend days.
         LET LWD EQ LWD - ($WDAY(LWD) - 5) .
         OK: .....


   A user wants to calculate  monthly  totals  in  a  report.   The  user
   divides  the  records in a report according to month by combining date
   functions with an ON CHANGE command:

              ON CHANGE $MONTH(ORDER_DATE) PRINT .  .  .




   2.5.9.7  Monitor Functions

   The monitor function $GETAB retrieves values from monitor tables.   It
   performs  the  same function as the TOPS-10 GETTAB monitor call or the
   TOPS-20 GETAB monitor call.  The monitor maintains tables  of  various
   system-  and  job-related  information.  The tables differ for TOPS-10
   and TOPS-20.  See the DECsystem-10 Monitor  Calls  Manual  or  TOPS-20                         ____________ _______  _____  ______      _______
   Monitor  Calls  Reference  Manual  for  details  on  GETTAB/GETAB  and   _______  _____  _________  ______
   information on the monitor tables.

   The format of the function is:

        $GETAB(index,table#)

   The index and table# are decimal integers that  identify  contents  of
   specific monitor tables.  They are listed in the Monitor Calls Manuals                                                    _______ _____ _______
   in octal form;  convert them to decimal for 1022.

   Example:

        * PRINT $GETAB(8,1)
        174598

        This prints the number of  milleseconds  of  CPU  time  that  job
        number 8 has used.  On TOPS-20 this is table number 1;  the index
        is the job number.

   For longer, ASCII or SIXBIT table entries, use a loop and the  $DECODE
   function  to  convert  the binary table information to printable form.
   (See $DECODE in "Conversion Functions").

   GENERAL USE OF THE SYSTEM                                    Page 2-51
   Revision 4


   Example:

        LET index 0.

        REPEAT

             LET name $GETAB(index,11).      !Retrieve a word from table
                                             !into "name"
             PRINT $DECODE(name) FMT A5 END. !$DECODE uses default byte
                                             !size 7
             LET index EQ index+1.

        UNTIL index EQ 7.                    !7 words in this entry

        This prints the system name, the first seven words of the TOPS-20
        table number 11.


   An error sets the system variable SYSGTABERR to 1,  and  the  function
   returns the value of the monitor error code.  SYSGTABERR is reset to 0
   when $GETAB is next called.  It records the success (0) or  error  (1)
   of the immediately preceding $GETAB call.



   2.5.10  System Variables

   The system variables control and display 1022 operations.   All  words
   beginning  with  "SYS",  including  all the system variable names, are
   reserved words.  Table 2-3, following the description  of  the  system
   variables, summarizes the characteristics of each.


     VARIABLE                         DESCRIPTION     ________                         ___________

     SYSADDMSG  - Controls prompts for the interactive ADD command.  When
                  it  is  0,  ADD  prompts  with attribute abbreviations.
                  When it is 1, ADD prompts with  full  attribute  names.
                  (See Chapter 5, ADD Command.)

     SYSADMCDIR - Controls access privileges among connected  directories
                  on  TOPS-20.  When SYSADMCDIR is 0, a user who connects
                  to another user's directory  has  full  owner's  rights
                  over  the  files in that directory.  When SYSADMCDIR is
                  1, a user who connects to another user's  directory  is
                  subject  to the ADMIT protection based on the logged-in
                  directory.

     SYSALCMSG  - Controls messages printed by 1022 when additional  disk
                  blocks  are  allocated.   When it is 0, 1022 suppresses
                  these messages;  when it is 1, 1022 displays them.

   GENERAL USE OF THE SYSTEM                                    Page 2-52
   Revision 4


     SYSAMBATTR - Controls the way 1022 deals  with  ambiguous  alternate
                  data  set references.  When SYSAMBATTR is 0, 1022 gives
                  an error message if an alternate data set reference  is
                  ambiguous.   When  SYSAMBATTR is 1, 1022 uses the first
                  occurence (in the lowest numbered data set)  and  gives
                  no   message.   See  "Attribute  Descriptors"  in  this
                  chapter.

|    SYSAUXCHK  - Determines whether or not 1022 checks to make sure that
|                 all  of  the auxiliary files that belong in a multifile
|                 data set are undamaged when the  data  set  is  opened.
|                 When SYSAUXCHK is 0, 1022 gives an error message if any
|                 of the data set's auxiliary  files  are  skewed.   When
|                 SYSAUXCHK  is  set  to 1, no such checking is performed
|                 and no error messages are displayed.

     SYSBETWEEN - Controls the operation of the BETWEEN and  NOT  BETWEEN
                  relational  operators  in  FIND, SEARCH, SELECT, and IF
                  commands.  When SYSBETWEEN is 0, the first argument for
                  the  operator  should be less than the second argument.
                  "BETWEEN arg1 arg2" is equivalent to "GE  arg1  AND  LE
                  arg2".  When SYSBETWEEN is 1, order of arguments is not
                  significant.  "BETWEEN arg1 arg2" is equivalent to  "GE
                  MIN(arg1 arg2) AND LE MAX(arg1,arg2)".  When SYSBETWEEN
                  is 1, "BETWEEN 5 3" has the same result as  "BETWEEN  3
                  5".

     SYSCASE    - Controls how alphabetic case is  handled  in  searches.
                  When SYSCASE is 0, 1022 distinguishes between upper and
                  lower case characters in FIND, DFIND,  SEARCH,  SELECT,
                  and  IF  comparisons.   When SYSCASE is 1, 1022 ignores
                  case differences in SEARCH, SELECT, and IF  comparisons
                  and  in  FIND  and  DBFIND commands using CONTAINS, NOT
                  CONTAINS, BEGINS, or NOT BEGINS.

     SYSCBLSIGN - Controls  use  of   COBOL   over-punch   signs.    When
                  SYSCBLSIGN is 0, 1022 disallows over-punch signs.  When
                  it is 1, 1022 allows over-punch signs in DMI and  other
                  data  files  for integer data.  When it is 2, 1022 also
                  allows over-punch signs  in  typed  input  and  command
                  files.

|    SYSCHANGED - Displays the changed or unchanged status  of  a  record
|                 that  you  have  selected  in GETREC mode and have then
|                 attempted to lock with a LOCK ON  RECORD  command.   If
|                 the record has been changed by another user between the
|                 time that you selected the record and the time that  it
|                 was  locked,  SYSCHANGED  returns  a value of 1.  If no
|                 other user has changed the record between the time that
|                 you  selected  it  and  the  time  that  it was locked,
|                 SYSCHANGED returns a value of 0.

   GENERAL USE OF THE SYSTEM                                    Page 2-53
   Revision 4


     SYSCLOSE2  - Controls the 1022  use  of  the  TOPS-10  monitor  call
                  CLOSE CHAN,CL.IN.    SYSCLOSE2   =   0  indicates  that
                  CLOSE CHAN,CL.IN  is  supported  at  your  site.   When
                  SYSCLOSE2 = 1, 1022 cannot use this monitor call.

|    SYSCOLNAME - Allows  you  to  access  the  name   of   the   current
|                 collection.   If  there  is  no current collection, the
|                 value returned for SYSCOLNAME is a blank.
|  
|    SYSCORESS  - Controls selection set format.  You can  set  SYSCORESS
|                 to  an  integer value.  The default value is 50000.  If
|                 the number of records (including deleted records) in  a
|                 data  set  is less than or equal to that integer value,
|                 selection sets for that data set will be built entirely
|                 in  core.   If the number of records in the data set is
|                 larger than that value, selection sets  for  that  data
|                 set  are  built as compressed bit tables that can spill
|                 over into a scratch file if necessary.
|  
|    SYSCUSTDMI - Contains the memory location in  decimal  of  the  user
|                 routine  that  calls  DBLODR to pass properly formatted
|                 records to 1022.

     SYSCVTERR  - Initially 0, SYSCVTERR is set to 1 when 1022 encounters
                  a run-time conversion error.  The user must reset it to
                  0  to  detect  further  errors.   (See  this   chapter,
                  "Conversion Functions").

     SYSCVTMSG  - Controls  display  of  the  run-time  conversion  error
                  message.   When  SYSCVTMSG  is 0, 1022 signals run-time
                  conversion errors by displaying an error message.  When
                  SYSCVTMSG  is 1, 1022 suppresses run-time error message
                  display.

     SYSDAMAGE  - Displays  the  damage  and/or  update  status  of   the
                  selected   data   set.   (See  Chapter  5,  "Data  Base
                  Damage").   This   supersedes   the   system   variable
                  "SYSFILDAM".

     SYSDATE    - Today's date.

     SYSDATEFMT - Controls the use of upper and lower-case characters  in
                  printing  dates.   When  SYSDATEFMT  is  0, 1022 prints
                  mixed-case dates (e.g.,  May).   When  it  is  1,  1022
                  prints upper-case (e.g., MAY).

     SYSDAYTIME - The current time of day updated  when  referenced.   It
                  has  eight  characters in the format hh:mm.ss.  This is
                  most useful in PL1022 programs and reports  where  long
                  periods of time may elapse between prompts.  Compare to
                  SYSTIME.

     SYSDBEXMSG - Controls   the   display   of   number-of-records-found
   GENERAL USE OF THE SYSTEM                                    Page 2-54
   Revision 4


                  messages  and  the  "called  from DBEXEC" part of error
                  messages when  the  FIND  and  MAP  commands  are  used
                  through   DBEXEC   in  host  language  programs.   When
                  SYSDBEXMSG is 0, 1022 suppresses the messages.  When it
                  is  1,  1022 displays them.  This makes the result of a
                  host  language  DBEXEC  call  look  the  same  as   the
                  interactive system.
|  
|    SYSDCORESS - Controls selection set format for individual data sets.
|                 By  default,  when  a data set is opened, SYSDCORESS is
|                 automatically  set  to  1  if  the  number  of  records
|                 (including  deleted  records)  in  the data set is less
|                 than or equal to the setting for SYSCORESS (see above).
|                 Selection  sets  for  that  data  set  are  then formed
|                 entirely in core.  If the number of records in the data
|                 set   is   greater  than  the  setting  for  SYSCORESS,
|                 SYSDCORESS is automatically set  to  0,  and  selection
|                 sets are formed as compressed bit tables that can spill
|                 over into a scratch file.  You can override the setting
|                 of  SYSCORESS by specifying the appropriate setting for
|                 SYSDCORESS for any individual  data  set  at  any  time
|                 after  opening  the data set.  The setting takes effect
|                 with the next FIND command.

     SYSDELIM   - Controls the  delimiter  character  recognized  by  the
                  ACCEPT command.  (See Chapter 8, "ACCEPT Command".)

     SYSDEQFAST - Controls writing to a disk file when  the  current  ENQ
                  data  set  is  updated.   When  SYSDEQFAST  is  0, 1022
                  requests that the  monitor  checkpoint  the  file  when
                  update  mode  is  released.  When SYSDEQFAST is 1, 1022
                  does not.  This is faster but less safe in  case  of  a
                  machine  crash.   (See  "SYSDEQFAST"  in  the  Updating
                  Chapter).

     SYSDIV     - Displays division by 0 error.  Initially 0,  SYSDIV  is
                  set to 1 whenever division by zero occurs.  It is reset
                  to 0 by any arithmetic  operation  in  a  new  command.
                  (Note:   dividing  zero  by zero does not set SYSDIV to
                  1.)

     SYSDIVMSG  - Controls display of division-by-zero  warning  message.
                  When  SYSDIVMSG  is  0,  1022 displays division-by-zero
                  warning messages.  When it is 1,  1022  suppresses  the
                  messages.

     SYSDIVP    - Displays division by zero error.  Initially 0,  SYSDIVP
                  is  set to 1 when a division by zero occurs.  It may be
                  reset  by  the  user.   It  indicates  that  a  nonzero
                  quantity  has  been  divided  by zero.  It is a lasting
                  version of  SYSDIV,  and  may  be  examined  in  PL1022
                  procedures.
   GENERAL USE OF THE SYSTEM                                    Page 2-55
   Revision 4


     SYSDMETRID - Controls the format in which messages  are  written  to
                  .DME  files.   When  SYSDMETRID  is 0, the SYSID of the
                  master data set record causing the message  is  written
                  to the .DME file.  When SYSDMETRID is 1, both the SYSID
                  of the master data set record  and  the  SYSID  of  the
                  transaction  record are written to the .DME file.  (See
                  Chapter 3, "Error Handling").

|    SYSDSALIAS - Controls the current data set alias.  The  variable  is
|                 25   characters   long.   See  "OPEN  Command"  in  the
|                 Examining chapter.

     SYSDSENQ   - Displays the current ENQ/NOENQ  mode  for  the  current
                  data  set.   When  SYSDSENQ is 1, the data set uses ENQ
                  update access.  When SYSDSENQ is 0, the data  set  uses
                  the  retry  system  (NOENQ).   See  "Waiting for Update
                  Access" in the Update chapter.

     SYSDSFILE  - Displays the current data set file name.

     SYSDSNAME  - Displays the current data set name.  The variable is 25
                  characters long.

     SYSENQDEF  - Controls the default update  access  scheduling.   When
                  SYSENQDEF  is  0,  1022  uses  the retry system, unless
                  otherwise specified.  When SYSENQDEF is  1,  1022  uses
                  the  queue  system,  unless  otherwise  specified.  See
                  "Waiting for Update Access" in the Update chapter.

     SYSENQTYPE - Controls the queued update access use  of  the  monitor
                  PSI  facility.   When  SYSENQTYPE  is 1, 1022 uses PSI.
                  When SYSENQTYPE  is  0,  1022  does  not  use  PSI  and
                  repeatedly  tries  for  access.  When SYSENQTYPE is -1,
                  1022 does not use PSI  and  waits  until  the  file  is
                  available.   See  "Interrupts  with  ENQ" in the Update
                  chapter.

     SYSERRCODE - Displays the integer error code for an I/O error.  (See
                  the Introduction chapter of the Host Language Interface                                                  ____ ________ _________
                  Manual).                  ______

     SYSERRDEV  - Displays the SIXBIT structure  name  for  an  INIT  I/O
                  error.   (See  the  Introduction  chapter  of  the Host                                                                     ____
                  Language Interface Manual).                  ________ _________ ______

     SYSERREXT  - Displays the SIXBIT file extension for a LOOKUP, ENTER,
                  or  RENAME I/O error.  (See the Introduction chapter of
                  the Host Language Interface Manual).                      ____ ________ _________ ______

     SYSERRFILE - Displays the SIXBIT file name for a LOOKUP,  ENTER,  or
                  RENAME I/O error.  (See the Introduction chapter of the
                  Host Language Interface Manual).                  ____ ________ _________ ______
   GENERAL USE OF THE SYSTEM                                    Page 2-56
   Revision 4


     SYSERRPPN  - Displays  the  octal   project-programmer   number   or
                  directory  number  pair  for a LOOKUP, ENTER, or RENAME
                  I/O error.  (See the Introduction chapter of  the  Host                                                                     ____
                  Language Interface Manual).                  ________ _________ ______

|    SYSERRTEXT - Determines which error message file  is  read  when  an
|                 error message is produced.  When SYSERRTEXT is set to 0
|                 (the default), the system reads  the  standard  English
|                 file   1022.ERR   to   produce  error  messages.   When
|                 SYSERRTEXT is set to 1, the system reads the  alternate
|                 file 1022.ERF.  This file contains a properly formatted
|                 translation of 1022.ERR, which the site has created  in
|                 the language of its choice.

     SYSEURODAT - Controls whether 1022 uses U.S. or European-style  date
                  formats.    When   SYSEURODAT  is  0,  1022  looks  for
                  U.S.-style dates on input.  It checks  delimited  input
                  as  MDY (month, day, year) and all-numeric input as YMD
                  and MDY in that order.  The default date output is  D3.
                  When  SYSEURODAT  is  1,  1022 looks for European-style
                  dates on input.  It checks delimited input as  DMY  and
                  all-numeric  input  as  YMD and DMY in that order.  The
                  default date output is D8.  See DATE in the "Data Type"
                  section of the Creation chapter.

|    SYSEXECKP  - Allows TOPS-20 users to return  to  their  former  EXEC
|                 rather  than  going  to  a new EXEC each time they PUSH
|                 from 1022.  The standard default (0) puts the user in a
|                 new  EXEC  on a PUSH from 1022.  If SYSEXECKP is set to
|                 1, the user returns to his or her previous EXEC.

     SYSEXP     - Displays the expiration date of  this  copy  of  System
                  1022.

     SYSEXPTYPE - Controls  expression  type   evaluation.    (See   this
                  chapter, "Expressions").

     SYSFDMATT  - The number of the keyed attribute being updated at  the
                  time  damage  to  the  data  base  was  detected.  (See
                  Chapter 5, "Data Base Damage").

|    SYSFMSG    - Allows you to save and restore the  bit  flag  settings
|                 that  are  manipulated  by  the  SET  FMSG and SET FERR
|                 commands (see the "SET Command" section of Chapter 7).

     SYSGTABERR - Displays an error in the immediately  preceding  $GETAB
                  call.   An  error  in $GETAB sets SYSGTABERR to 1.  The
                  next call to $GETAB resets SYSGTABERR to 0.  (See  this
                  chapter, "Monitor Functions").

     SYSHLCVT   - Controls the data type of  arguments  passed  in  COBOL
                  COMP   arrays   when  using  the  COBOL  Host  Language
                  Interface.  It is usually set by a host  language  call
   GENERAL USE OF THE SYSTEM                                    Page 2-57
   Revision 4


                  to  DBSYSV.   When  SYSHLCVT  is  0, 1022 automatically
                  converts data types between 1022 and other  COBOL  data
                  types.  When set to 1, arguments to DBXXXX routines are
                  interpreted by default-type rules,  regardless  of  the
                  COBOL  data  type,  exactly  as  in  FORTRAN;   and the
                  operators  "DISP."  and  "BIN."  have   their   FORTRAN
                  meanings.   See  the  beginning of the COBOL Chapter of
                  the Host Language Interface Manual.                      ____ ________ _________ ______

                  This variable allows argument  lists  in  COBOL  to  be
                  interpreted  with  the same data conversion conventions
                  as used in the FORTRAN interface.

     SYSHLDISP  - Controls the display type for display items in  a  host
                  language  program.   When  SYSHLDISP  is 0, the display
                  type is ASCII;  when it  is  1,  the  display  type  is
                  SIXBIT.

     SYSHLNAME  - Controls  the  use  of  NOSETNAME  in   host   language
                  initialization  calls.  NOSETNAME controls 1022 changes
                  in host language program names.  When SYSHLNAME  is  0,
                  1022 uses the argument NOSETNAME.  When SYSHLNAME is 1,
                  1022 does not use the argument NOSETNAME.  (See the DBA                                                                      ___
                  Manual.)                  ______

     SYSHLMODE  - Controls  integer-to-display  conversions  in  a   host
                  language program.

     SYSID      - Displays the internal record number  for  each  record,
                  available  for FIND and SEARCH commands, as well as for
                  printing.

     SYSIFTYPE  - Controls the kind of IF statement used.  When SYSIFTYPE
                  is 0, 1022 accepts "IF expression THEN label".  When it
                  is 1, 1022  accepts  structured  IF  statements.   (See
                  Chapter 8, "IF Statements").

     SYSIOMSG   - Controls messages printed due to  input/output  errors.
                  When  SYSIOMSG  is 0, I/O error messages are displayed;
                  when it is 1, the  messages  are  suppressed.(See  this
                  chapter, "Error Messages").

     SYSJOBNO   - Displays the user's job number.

     SYSKEEPBUF - Controls sort buffer allocation.  When SYSKEEPBUF is 0,
                  1022  allocates  a buffer for the temporary sort files,
                  sorts the data, then frees the buffer.  When SYSKEEPBUF
                  is  1,  1022  allocates  a buffer, sorts the data, then
                  retains the buffer for the next sort.  This reduces the
                  overhead  of repeatedly allocating a buffer at the cost
                  of having more memory allocated between sorts.  If  you
                  set  SYSKEEPBUF to 1 for a series of sorts, reset it to
                  0 before the last sort of the series to deallocate  the                    ______
   GENERAL USE OF THE SYSTEM                                    Page 2-58
   Revision 4


                  buffer.

     SYSKEEPPSI - Controls the handling of previous PSI settings when the
                  update access system uses ENQ and PSI.  When SYSKEEPPSI
                  is 1, 1022 replaces the previous PSI  (TOPS-10).   When
                  SYSKEEPPSI  is  0, 1022 keeps and restores the previous
                  PSI.  See "Interrupts with ENQ" in the Update chapter.

     SYSLINE(n) - Displays the current print line number  on  1022  print
                  channel n.

     SYSMSTIME  - Displays the number  of  milliseconds  since  midnight,
                  updated when referenced.

     SYSNOFILOP - Controls the use of the TOPS-10 monitor call  "FILOP.".
                  When  the  version  of  TOPS-10  does  not support this
                  monitor call, the administrator sets  SYSNOFILOP  to  1
                  (see the DBA Manual).                           ___ ______

     SYSNOPSI   - Controls the use of PSI  when  update  access  is  ENQ.
                  When  SYSNOPSI  is  0,  1022  tries  to  use PSI.  When
                  SYSNOPSI is 1, 1022 does not try to use PSI.   SYSNOPSI
                  may  be  set  by users or is set to 1 by 1022 when 1022
                  first  discovers  that   PSI   is   unavailable.    See
                  "Interrupts with ENQ" in the Update chapter.

     SYSNOSEG   - Controls 1022 segmentation on TOPS-10.   When  SYSNOSEG
                  is  0,  1022 runs in segments;  when it is 1, 1022 runs
                  unsegmented.  (See Appendix D.)

     SYSNOSEGP  - Controls  1022  segmentation  on  TOPS-10,  systemwide.
                  When  SYSNOSEGP  is  -1, the value of SYSNOSEG controls
                  this.  When SYSNOSEGP  is  1,  1022  runs  unsegmented.
                  When SYSNOSEGP is 0, 1022 runs segmented.  SYSNOSEG can
                  be set by users;  SYSNOSEGP can be set only by the DBA.

     SYSNOXCHAN - Controls  the  use  of  the  TOPS-10  monitor  extended
                  channels.  When the version of TOPS-10 does not support
                  extended channels, the administrator sets SYSNOXCHAN to
                  1 (see the DBA Manual).                             ___ ______

|    SYSNOYMD   - Controls the way in which 1022  interprets  all-numeric
|                 dates.   When  SYSNOYMD is set to 0 (the default), 1022
|                 tries to  read  an  all-numeric  date  as  an  ANSI  or
|                 modified  ANSI  date (YY)YYMMDD.  If SYSNOYMD is set to
|                 1, 1022 does not try to read  an  all-numeric  date  as
|                 year-month-day.   Instead,  if SYSNOYMD is set to 1 and
|                 SYSEURODAT is set to 0, 1022 tries to read the date  as
|                 MMDDYY(YY).  If SYSNOYMD and SYSEURODAT are both set to
|                 1, 1022 tries to read the date as DDMMYY(YY).

   GENERAL USE OF THE SYSTEM                                    Page 2-59
   Revision 4


     SYSNREC    - Displays the number of records in the current selection
                  group.

     SYSNRETRY  - Controls the number of retries for update access when a
                  shared  data set is updated.  (See Chapter 5, "Multiple
                  Access to a Data Set").

     SYSOVF     - Displays overflow and underflow errors.   Initially  0,
                  it  is  set  to  1  whenever  an  operation  in  a  new
                  expression   overflows   or    underflows.     It    is
                  automatically  set  to  0  in  any  statement where all
                  arithmetic  expressions  evaluate  correctly.   It   is
                  unchanged  if  no  arithmetic  operators  appear  in  a
                  statement.  (See "Overflow and Underflow Conditions" in
                  this chapter).

     SYSOVFMSG  - Displays overflow and underflow warning messages.  When
                  SYSOVFMSG  is  0, 1022 displays these warning messages;
                  when it is 1, 1022 suppresses the messages.  SYSOVF and
                  SYSOVFP are unaffected.

     SYSOVFP    - Displays overflow and underflow errors.   Initially  0,
                  it  is  set  to 1 by 1022 when an overflow or underflow
                  occurs.  Unlike SYSOVF, it must be reset explicitly  by
                  the  user.  (See "Overflow and Underflow Conditions" in
                  this chapter).

     SYSPAGE(n) - Controls and contains the current page number  on  1022
                  print channel n.  The user may assign any integer value
                  to this variable.

|    SYSPCCOL   - Contains the number of the  column  to  which  1022  is
|                 writing  or is about to write when printing to a DIF or
|                 WKS file.  When you give  the  INIT  DIF  or  INIT  123
|                 command,  SYSPCCOL  is  set  by default to 0.  (See the
|                 "Data-Positioning  Information"  and  "Data-Positioning
|                 Options" section of Chapter 12.)
|  
|    SYSPCRESET - Contains the number of the column where 1022 will begin
|                 writing  data  to  a  DIF file at the beginning of each
|                 PRINT command;  contains the number of the column where
|                 1022 will begin writing to a columnwise WKS file at the
|                 beginning of each PRINT command;  contains  the  number
|                 of  the  row where 1022 will begin writing to a rowwise
|                 WKS file at the beginning of each PRINT command.   When
|                 you  give  the INIT DIF or INIT 123 command, SYSPCRESET
|                 is set by default to  0.   (See  the  "Data-Positioning
|                 Information"  and "Data-Positioning Options" section of
|                 Chapter 12.)
|  
   GENERAL USE OF THE SYSTEM                                    Page 2-60
   Revision 4


|    SYSPCROW   - Contains the number of the row to which 1022 is writing
|                 or  is  about  to  write  when printing to a DIF or WKS
|                 file.  When you give the INIT DIF or INIT 123  command,
|                 SYSPCROW   is   set   to   0   by  default.   (See  the
|                 "Data-Positioning  Information"  and  "Data-Positioning
|                 Options" section of Chapter 12.)

     SYSPPN     - Displays the current user's  project-programmer  number
                  (PPN)   in  its  internal  octal  form:   (proj,,prog).
                  SYSPPN has meaning when printed  in  "O"  format  only.
                  (See also SYSUPROG and SYSUPROJ).

     SYSPROT20  - Controls file  protection  on  TOPS-20  systems.   (See
                  Chapter 3).
|  
|    SYSRECLOCK - Displays the RECLOCK/NORECLOCK status  of  the  current
|                 data  set.  When the current data set is NORECLOCK, the
|                 value of  SYSRECLOCK  is  0.   When  the  data  set  is
|                 RECLOCK, the value of SYSRECLOCK is 1.

     SYSRECMODE - Displays the current record mode.  When  SYSRECMODE  is
                  0, 1022 is in global mode.  When SYSRECMODE is -1, 1022
                  is in local  mode  (a  single  record  is  selected  by
                  GETREC).

     SYSRECNO   - Displays the position  (rank  order)  of  the  selected
                  record in the current selection group.

     SYSREP1    - Controls processing of records  in  a  report  program.
                  (See Chapter 9, "Jumping Around An ON CHANGE").

     SYSREP2    - Controls printing of  null  groups  in  reports.   (See
                  Chapter 9, "Jumping Around An ON CHANGE").

     SYSREP3    - Displays the pass  condition  during  report  programs.
                  (See  Chapter  9,"Restrictions  on  Pretotals in Report
                  Programs,").

     SYSREPMODE - Controls page headings and footings outside of reports.
                  (See Chapter 9, "Page Formatting Commands").

     SYSREPSYNC - Controls form feeds between  pages  of  reports.   When
                  SYSREPSYNC  is 0 and the SET TAPE NONE command has been
                  given, 1022 suppresses  automatic  form  feeds  between
                  pages;   when  it is 1 and no SET TAPE NONE command has
                  been given, 1022 generates a  form  feed  between  each
                  page.

     SYSRESET   - Controls   data   handling   in    multiple    updating
                  environments.   (See  Chapter  5, "Multiple Access of a
                  Data Base").

     SYSRNGMSG  - Controls  messages  printed  when  values  assigned  to
   GENERAL USE OF THE SYSTEM                                    Page 2-61
   Revision 4


                  attributes  are  out  of  their  allowed  range.   When
                  SYSRNGMSG is 0, 1022  displays  out-of-range  messages;
                  when  it  is  1,  1022  suppresses  the messages.  (See
                  Chapter 3, "RANGE Clause").

     SYSSCRDEV  - Controls the default scratch device for  commands  that
                  use  a  scratch  file  structure.   See  "SORT  Scratch
                  Device" in the Examining chapter.

|    SYSSCRFILE - Allows you to prevent 1022 from opening a scratch  file
|                 for  use in building selection sets during the session.
|                 When SYSSCRFILE is set to 1 (the  default),  a  scratch
|                 file  is  automatically opened and remains open for the
|                 duration of the  session  once  a  data  set  has  been
|                 opened.  If SYSSCRFILE is set to 0 before any data sets
|                 are opened, no scratch file is opened for the session.

     SYSSFDFLAG - Controls the use of TOPS-10 SFDs.  When  SYSSFDFLAG  is
                  0, the version of TOPS-10 supports SFDs.  When it is 1,
                  the version does not support SFDs.

|    SYSSWEDSRT - Allows the Swedish characters a ring, a umlaut,  and  o                                                _ ____  _ ______        _
|                 umlaut  to  be  sorted in alphabetical order instead of                  ______
|                 standard ASCII order.  When SYSSWEDSRT is set to 0 (the
|                 default),   ASCII   order  is  used  in  sorting  these
|                 characters.  When  SYSSWEDSRT  is  set  to  1,  Swedish
|                 alphabetical  order is used.  This feature is supported
|                 only on KL and KS model processors and has no effect on
|                 the SORT KEY command.

     SYSTENQ    - Controls the maximum time 1022 waits for update  access
                  using  the  ENQ  and  PSI  facilities.  The value is in
                  milliseconds.  See "Queue for  Update  Access"  in  the
                  Update Chapter.

     SYSTEXTDOT - Controls  the  way  1022  handles   invalid   qualified
                  attribute  references.   When  SYSTEXTDOT  is  0,  1022
                  returns  an  error  message  for  references   in   the
                  SET.ATTRIBUTE   form  that  do  not  correspond  to  an
                  attribute.  When SYSTEXTDOT is 1, 1022  treats  invalid
                  qualified attribute references as text.  See "Attribute
                  Descriptors" in this chapter.

     SYSTIME    - Displays the current  time  of  day,  updated  at  each
                  command  prompt.   In  host language applications it is
                  updated at each request for  it.   In  reports  SYSTIME
                  retains the value it had at the beginning of the report
                  throughout.  Compare to SYSDAYTIME which changes during
                  reports.    It  has  eight  characters  in  the  format
                  hh:mm.ss.
|  
   GENERAL USE OF THE SYSTEM                                    Page 2-62
   Revision 4


|    SYSTOPIID  - Contains  the  number  of  the   highest   Integer   of
|                 Identification in the current data set.
|  
|    SYSTOPSID  - Contains the number of the highest SYSID in the current
|                 data set.

     SYSTRAPUP3 - Controls the way 1022 handles  the  UP3  update  error.
|                 Unless you are using UPDATE ON or record-level locking,
|                 it is possible for another  user  to  change  a  record
|                 between  the  time  you  selected  it  with  the GETREC
|                 command and the time you  gave  the  CHANGE  or  DELETE
|                 command.   When  this  happens, 1022 gives a warning or
|                 handles the condition as  an  error  and  ignores  your
|                 CHANGE  or  DELETE command.  The value of SYSTRAPUP3 is
|                 then read to determine whether to terminate or continue
|                 program  execution.   When SYSTRAPUP3 is 0, System 1022
|                 allows your program to continue execution  (unless  the
|                 UPDE. label  is  specified in a host language program).
|                 When SYSTRAPUP3 is 1 (or the UPDE. label  is  specified
|                 in  a host language program), 1022 issues the UP3 error
|                 message and terminates execution of your program.

     SYSTRETRY  - Controls the time  between  tries  for  update  access.
                  (See Chapter 5, "Multiple Access of a Data Set").

     SYSUPROG   - Displays the octal  digits  of  the  user's  programmer
                  number  as a decimal value.  A programmer number of 276
                  octal produces a value in SYSUPROG of 276 decimal.  The
                  octal digits print under integer print formats.

     SYSUPROJ   - Displays the octal digits of the user's project  number
                  as  a  decimal  value.   A  project number of 276 octal
                  produces a value in SYSUPROJ of 276 decimal.  The octal
                  digits print under integer print formats.


     SYSUSERADR - Contains the memory location in decimal  of  the  MACRO
                  routine called by USERCALL.  The setting for SYSUSERADR
                  is local for the users current session.  (See  USERCALL
                  in the Special Commands chapter).

     SYSUSRADRP - Contains the memory location in decimal  of  the  MACRO
                  routine called by USERCALL.  SYSUSRADRP can be set only
                  by the DBA and is systemwide.  Compare to SYSUSERADR.

     SYSUSERD1  - Value-passing variables available to pass a date value
     SYSUSERD2    between host language programs and 1022.  (See the Host                                                                     ____
     SYSUSERD3    Language Interface Manual for full explanations of  all                  ________ _________ ______
                  the SYSUSER__ variables).

     SYSUSERI1  - Value-passing variables available to pass an integer
     SYSUSERI2    value between host language programs and 1022.
     SYSUSERI3    
   GENERAL USE OF THE SYSTEM                                    Page 2-63
   Revision 4


     SYSUSERR1  - Value-passing variables available to pass a real value
     SYSUSERR2    between host language programs and 1022.
     SYSUSERR3    

     SYSUSERT5  - Value-passing variables available to pass a 5, 10, or
     SYSUSERT10   40 character text value between host language programs
     SYSUSERT40   and 1022.

     SYSWRITE20 - Controls TOPS-20 disk writes when UPDATE OFF is  given.
                  When  SYSWRITE20  is  0, 1022 does not force TOPS-20 to
                  write changed pages to disk.   When  SYSWRITE20  is  1,
                  1022  forces TOPS-20 to write the data set to disk when
                  the UPDATE OFF  command  is  given.   (See  Chapter  5,
                  "Incomplete Updates").

   The value of any system variable can be printed at any time.  The user
   can  assign the value for many variables (listed as "User Settable" in
   Table 2-3) with the LET and DBSYSV commands.  The default  values  for
   system  variables  which  are  "Default  Settable" in Table 2-3 can be
   changed only by the data base administrator.
   GENERAL USE OF THE SYSTEM                                    Page 2-64
   Revision 4


                 TABLE 2-3. SYSTEM VARIABLE CHARACTERISTICS


           NAME    NUMBER  DATA TYPE      USER   STANDARD   DEFAULT
                                        SETTABLE DEFAULT    SETTABLE

        SYSADDMSG    105   INTEGER         YES     0          YES
        SYSADMCDIR   126   INTEGER         NO      0          YES
        SYSALCMSG    104   INTEGER         YES     0          YES
        SYSAMBATTR   132   INTEGER         YES     0          YES
        SYSAUXCHK    128   INTEGER         YES     0          YES
        SYSBETWEEN   131   INTEGER         YES     0          YES
        SYSCASE      3     INTEGER         YES     0          YES
        SYSCBLSIGN   41    INTEGER         YES     1          YES
        SYSCHANGED   79    INTEGER         NO      0          NO
        SYSCLOSE2    115   INTEGER         NO      0          YES
        SYSCOLNAME   72    TEXT 25         NO      blanks     NO
        SYSCORESS    74    INTEGER         YES     50000      YES
        SYSCUSTDMI   88    INTEGER         YES     0          YES
        SYSCVTERR    113   INTEGER         YES     0          YES
        SYSDAMAGE    200   INTEGER         NO      0          NO
        SYSDATE      1     DATE            NO      0          NO
        SYSDATEFMT   112   INTEGER         YES     0          YES
        SYSDAYTIME         TEXT            NO      0          NO
        SYSDBEXMSG   44    INTEGER         YES     0          YES
        SYSDCORESS   75    INTEGER         YES     0          NO
        SYSDELIM     24    TEXT            YES     ,          YES
        SYSDEQFAST   68    INTEGER         YES     0          YES
        SYSDIV       110   INTEGER         YES     0          YES
        SYSDIVMSG    108   INTEGER         YES     0          YES
        SYSDIVP      111   INTEGER         YES     0          YES
        SYSDMETRID   133   INTEGER         YES     0          YES
        SYSDSALIAS   70    TEXT 25         YES     blanks     NO
        SYSDSENQ     65    INTEGER         NO      1          NO
        SYSDSFILE    69    TEXT 80         NO      blanks     NO
        SYSDSNAME    58    TEXT 25         NO      blanks     NO
        SYSENQDEF    123   INTEGER         NO      1          YES
        SYSENQTYPE   67    INTEGER         YES     1          YES
        SYSERRCODE   21    OCTAL           NO      0          NO
        SYSERRDEV    17    SIXBIT INT      NO      0          NO
        SYSERREXT    19    SIXBIT INT      NO      0          NO
        SYSERRFILE   18    SIXBIT INT      NO      0          NO
        SYSERRPPN    20    OCTAL           NO      0          NO
        SYSERRTEXT   78    INTEGER         YES     0          YES
        SYSEURODAT   120   INTEGER         YES     0          YES
        SYSEXECKP    85    INTEGER         YES     0          YES
        SYSEXP       7     DATE            NO      0          NO
        SYSEXPTYPE   29    INTEGER         YES     0          YES
        SYSFDMATT    16    INTEGER         NO      0          NO
        SYSFMSG      59    INTEGER         YES     0          NO
        SYSGTABERR   129   INTEGER         NO      0          NO
        SYSHLCVT     34    INTEGER         YES     0          YES

   GENERAL USE OF THE SYSTEM                                    Page 2-65
   Revision 4


            TABLE OF SYSTEM VARIABLE CHARACTERISTICS (continued)

           NAME    NUMBER  DATA TYPE      USER   STANDARD   DEFAULT
                                        SETTABLE DEFAULT    SETTABLE

        SYSHLDISP    26    INTEGER         YES     0          YES
        SYSHLMODE    27    INTEGER         YES     0          YES
        SYSHLNAME    63    INTEGER         NO      0          YES
        SYSID        8     INTEGER         NO      0          NO
        SYSIFTYPE    42    INTEGER         YES     0          YES
        SYSIOMSG     102   INTEGER         YES     0          YES
        SYSJOBNO     25    INTEGER         NO      0          NO
        SYSKEEPBUF   125   INTEGER         YES     0          YES
        SYSKEEPPSI   121   INTEGER         YES     1          YES
        SYSLINE      4     INTEGER         NO      0          NO
        SYSMSTIME          INTEGER         NO      0          NO
        SYSNOFILOP   118   INTEGER         NO      1          YES
        SYSNOPSI     122   INTEGER         YES     0          YES
        SYSNOSEG     100   INTEGER         YES     0          YES
        SYSNOSEGP    61    INTEGER         NO      -1         YES
        SYSNOXCHAN   119   INTEGER         NO      0          YES
        SYSNOYMD     87    INTEGER         YES     0          YES
        SYSNREC      9     INTEGER         NO      0          NO
        SYSNRETRY    15    INTEGER         YES     10         YES
        SYSOVF       106   INTEGER         YES     0          YES
        SYSOVFMSG    109   INTEGER         YES     0          YES
        SYSOVFP      107   INTEGER         YES     0          YES
        SYSPAGE      2     INTEGER         YES     0          NO
        SYSPCCOL     82    INTEGER         YES     0          NO
        SYSPCRESET   84    INTEGER         YES     0          NO
        SYSPCROW     83    INTEGER         YES     0          NO
        SYSPPN       37    INTEGER         NO      0          NO
        SYSPROT20    28    TEXT 6          YES     blanks     YES
        SYSRECLOCK   86    INTEGER         NO      0          NO
        SYSRECMODE   60    INTEGER         NO      0          NO
        SYSRECNO     5     INTEGER         NO      0          NO
        SYSREP1      10    INTEGER         YES     0          YES
        SYSREP2      11    INTEGER         YES     0          YES
        SYSREP3      12    INTEGER         NO      0          NO
        SYSREPMODE   13    INTEGER         YES     0          YES
        SYSREPSYNC   14    INTEGER         YES     1          YES
        SYSRESET     23    INTEGER         YES     0          YES
        SYSRNGMSG    103   INTEGER         YES     0          YES
        SYSSCRDEV    64    TEXT 6          YES     DSK        YES
        SYSSCRFILE   76    INTEGER         YES     1          YES
        SYSSFDFLAG   114   INTEGER         NO      0          YES
        SYSSWEDSRT   77    INTEGER         YES     0          YES
        SYSTENQ      66    INTEGER         YES     2000       YES
        SYSTEXTDOT   127   INTEGER         YES     0          YES
        SYSTIME      6     TEXT 8          NO      0          NO
        SYSTOPIID    80    INTEGER         NO      0          NO
        SYSTOPSID    81    INTEGER         NO      0          NO
        SYSTRAPUP3   124   INTEGER         YES     0          YES
   GENERAL USE OF THE SYSTEM                                    Page 2-66
   Revision 4


            TABLE OF SYSTEM VARIABLE CHARACTERISTICS (continued)

           NAME    NUMBER  DATA TYPE      USER   STANDARD   DEFAULT
                                        SETTABLE DEFAULT    SETTABLE

        SYSTRETRY    43    INTEGER         YES     200        YES
        SYSUPROG     39    INTEGER         NO      0          NO
        SYSUPROJ     38    INTEGER         NO      0          NO
        SYSUSERADR   30    INTEGER         YES     0          YES
        SYSUSERD1    54    DATE            YES     01/01/1800 NO
        SYSUSERD2    55    DATE            YES     01/01/1800 NO
        SYSUSERD3    56    DATE            YES     01/01/1800 NO
        SYSUSERI1    45    INTEGER         YES     0          NO
        SYSUSERI2    46    INTEGER         YES     0          NO
        SYSUSERI3    47    INTEGER         YES     0          NO
        SYSUSERR1    48    REAL            YES     0          NO
        SYSUSERR2    49    REAL            YES     0          NO
        SYSUSERR3    50    REAL            YES     0          NO
        SYSUSERT10   52    TEXT 10         YES     blanks     NO
        SYSUSERT40   53    TEXT 40         YES     blanks     NO
        SYSUSERT5    51    TEXT 5          YES     blanks     NO
        SYSUSRADRP   71    INTEGER         NO      0          YES
        SYSWRITE20   57    INTEGER         YES     1          YES



   2.6  ERROR HANDLING

   When 1022 detects an error, it outputs an  error  message  naming  the
   problem.  The form of the error message is:

        ? <error code> <text>

   The error character may be changed from the question mark  by  use  of
   the SET ERRCHAR command (see Chapter 7, "SET Command").

   If the error occurs because a command was not typed correctly  by  the
   user,  1022  retypes the command up to the word in error, or up to the
   first word which could not be  properly  understood.   The  last  word
   typed is often just after the word in error.

   The error code  consists  of  a  letter  code  identifying  the  error
   category  and  a  number for the specific error.  The letter codes are
   the following:

        AU  Audit Trail Errors
        CO  Out Of Core Errors
        CP  COMPILE/PERFORM errors
        CS  Command Scanner Errors
        DB  Debugging Errors
        FD  File Damaged Errors
        FI  FIND and SAVE Errors
        FO  Format or Print Output Errors
   GENERAL USE OF THE SYSTEM                                    Page 2-67
   Revision 4


        HL  Host Language Errors
        IO  I/O Errors
        LD  LOAD and APPEND Errors
        MI  Miscellaneous Errors
        OP  OPEN Errors
        PL  PL1022 Errors
        SO  SORT Errors
        SP  SPSS Errors
        SY  Fatal System Errors
        TR  TRANSACT Errors
        UP  Update Errors

   With the letter code and error ID, the user can  refer  to  Appendix E
   for a list of error messages.



   2.7  CHANNEL USAGE UNDER TOPS-10

   System 1022 permits the use of  at  least  15  monitor  I/O  channels.
   Under  versions  7.01  and  later  of  TOPS-10, 1022 supports extended
   channels.  With extended channels, System 1022 permits the use  of  up
   to  80  channels.   If  extended  channels  are  available, the system
   variables SYSNOFILOP and  SYSNOXCHAN  are  0.   System  1022  reserves
   Channel 0 as a scratch channel for internal use.

   With extended channels, 1022 begins allocating with channel 20.   This
   makes  64  channels  available to 1022.  Channels 1 through 15 are not
   used by 1022;  they can be used by host language programs.

   The user may determine which channels are in  use  by  1022  with  the
   command  INFORM FILES.  System 1022 lists all channels in use, and the
   names of the files associated with the channels.  Channels flagged  as
   "reserved" by this command are in use by TMP files.

   The user may determine how close he is to the channel limit  from  the
   following rules:

        1. System 1022 accounting requires one channel.   Some  sites  do
           not   use   1022   accounting;    check   with   your   System
           Administrator.

        2. 1022 uses one channel to access all data sets residing in  one
           physical DMS file.

        3. If a data set is unbundled, a second channel is used  for  the
           DMI  file;   this  means an unbundled data set uses a total of
           two channels.  However Rule 2 applies to the 1022 portions  of
           unbundled data sets, if they are placed on one DMS file.

        4. Any 1022 PRINT channels established to disk files require  one
           channel each.
   GENERAL USE OF THE SYSTEM                                    Page 2-68
   Revision 4


        5. While a data set maintains a sorted order  (that  is,  between
           the  time  a  SORT  is  done  and  the next FIND command), one
           channel may be used to keep the sort  temporary  file.   Small
           SORTs (about 400 records) require no channels.

        6. The SORT command requires at least 4 channels to  perform  the
           sort.   Three  of  these are freed when the sort is completed;
           the channel which is not freed is maintained for the SORT  TMP
           file.

        7. When the AUDIT TRAIL is enabled, the AUDIT procedure uses  one
           channel per data set.



   2.8  INPUT FILE FORMATS

   System  1022  supports  input  files   in   both   line-numbered   and
   non-line-numbered  formats.   In files that are not line-numbered, bit
   35 should not be on in any word  in  the  file.   Line-numbered  files
   should meet the following specifications:

        1.  Line numbers and page mark words are flagged by having bit 35
            on in the word.  This is not so of data words.

        2.  Flagged words do not occur in the middle of lines.

        3.  Page marks are two words.  The first has five spaces  and  is
            flagged.   The second has <CR>, <FF>, followed by three nulls
            and is not flagged with bit 35.

        4.  Lines are padded with nulls so that line numbers  synchronize
            with word boundaries.

        5.  Line numbers are followed by a <TAB>.  Both  are  ignored  as
            input  data  but may be printed in error messages to help the
            user locate errors.

        6.  Each line has one--and only one--line number.













                                 CHAPTER 3

                           CREATING THE DATA BASE



   3.1  BUILDING A DATA SET

   System 1022 builds a data  set  from  a  file  of  input  data  and  a
   description file which describes the data file and data set.

   The data file contains records that correspond to the records  of  the
   1022  data set.  The data file records may be fixed length or variable
   length, in a uniform, user-defined format.  Records in  other  formats
   must  be  converted  to  an  accepted one using an external utility or
   editing program before 1022 can use them to build a data set.   System
   1022  can  also build an empty data set without a data file;  data can
   then be entered with the ADD command.

   The description file (DMD) describes the relevant fields of the  input
   data  records and assigns an attribute name and data type to each.  It
   can  also  specify  devices,  the  data  file  name,  and   data   set
|  characteristics  that  1022 uses when it builds the data set.  If your
|  site has licensed the Large Data Sets Module, the DMD  file  can  also
|  specify  that a data set's records and key tables are to be split over
|  multiple auxiliary files.

   Figure 3-1 shows a simple description file;  figure 3-2 shows the data
   file  it describes.  The following example shows the commands to build
   a data set from that description and data, to open the new  data  set,
   and to access information in it.


        ATTRIBUTE NAME TEXT COLUMN 1 7
        ATTRIBUTE AGE INTEGER COLUMN 8 9
        ATTRIBUTE BIRTHDAY ABBREV BDAY DATE COLUMN 10 18


                                 Figure 3-1
                     Sample Description file BIRTH.DMD
   CREATING THE DATA BASE                                        Page 3-2
   Revision 4


        Jones  3511/10/40
        D'Amato28       
        Harris 2709/08/47


                                 Figure 3-2
                         Sample Data file BIRTH.DMI


   Example:

        * LOAD BIRTH
        System 1022 Data Loading Program
        No errors in DESCRIPTION file
        3 records processed, 1 page written on phase 2
        no keyed attributes
        * OPEN BIRTH
        * FIND ALL
        3 RECS FOUND.
        * PRINT NAME
        Jones
        D'Amato
        Harris



   3.1.1  Bundled And Unbundled Data Sets

   System 1022 can build two types of data sets:  bundled and unbundled.

   1.  BUNDLED DATA SETS

   The LOAD command produces a bundled data set.  This command  combines,
   or  bundles,  data records, their keys and description, and other 1022
   information into one file.

   2.  UNBUNDLED DATA SETS

   The CREATE command produces an unbundled data set.  An unbundled  data
   set  keeps  the  data  records in a file separate (unbundled) from the
   keys and other 1022 information.
   CREATING THE DATA BASE                                        Page 3-3
   Revision 4


                               1022 Data Sets

   +---------------------------|----------------------------------------+
   |                           |                                        |
   |         Bundled           |              Unbundled                 |             _______                          _________
   |                           |                                        |
   |                           |                                        |
   |         Data set          |       Data set        Data file        |
   |        _________          |      _________        __________       |
   |        |       |          |      |       |        |        |       |
   |        | 1022  |          |      | 1022  |   |--->| data   |       |
   |        | info  |          |      | info  |   |    | records|       |
   |        |-------|          |      |-------|   |    |        |       |
   |        |       |          |      |name of|   |    |        |       |
   |        | data  |          |      | data  |   |    |        |       |
   |        |records|          |      | file  |---|    | (user's|       |
   |        |       |          |      |-------|        |  data- |       |
   |        |-------|          |      |       |        |  file) |       |
   |        |       |          |      |       |        |        |       |
   |        | keys  |          |      | keys  |        |        |       |
   |        |       |          |      |       |        |        |       |
   |        |       |          |      |       |        |        |       |
   |        |_______|          |      |_______|        |________|       |
   |                           |                                        |
   +---------------------------|----------------------------------------+

   The DUMP command builds a new data set  or  data  file  that  contains
   selected records from an existing data set.

   The  following  sections  of  this  chapter   describe   data   files,
   description  files,  the  uses of bundled and unbundled data sets, and
   the LOAD, CREATE, and DUMP commands.



   3.2  DATA FILE

   System 1022 usually reads an input data file  to  build  a  data  set.
   This file contains the data that fills in the values for attributes in
   the data set.  For use with 1022, the  data  file  is  called  a  Data
   Management  Input  (DMI)  file and is usually given the extension DMI.
   Any of the following record formats may be used to build the data set:
   ASCII (7-bit), ASCII ISAM, SIXBIT, SIXBIT ISAM, delimited field, fixed
   length, and variable length.
   CREATING THE DATA BASE                                        Page 3-4
   Revision 4


   3.2.1  Record Formats

   A record usually contains many data fields.  Each field can correspond
   to an attribute in the data set.  For example, the following data file
   records contain data for the attributes NAME, AGE, and BIRTHDAY:

        Jones  35 11/10/40
        D'Amato28
        Harris 27 09/08/47

   In these records the NAME field occupies 7 places, the  AGE  field  2,
   and the BIRTHDAY field 9.

   System 1022 recognizes fixed length and variable length  input  record
   formats.  By default, 1022 expects variable length records, where each
   record terminates with a carriage-return and line-feed combination.

   Fields which are absent at the end of a line are given blank  or  zero
   values  by  1022.   This  is  useful  when  data  is not available for
   trailing attributes as in the case above for D'Amato's birthday.  Both
   variable  and  fixed length formats require fixed column positions for
   the data fields, from the start of each record.

   In variable-length format, the above records appear as:

        Jones  35 11/10/40<CR><LF>
        D'Amato28<CR><LF>
        Harris 27 09/08/47<CR><LF>

   In fixed-length format, the above records appear as:

        Jones  35 11/10/40<CR><LF>
        D'Amato28         <CR><LF>
        Harris 27 09/08/47<CR><LF>

   Each    fixed-length    record    occupies    7+2+9+2=20    positions.
   Carriage-return <CR> and linefeed <LF> each count as a character.  The
   <CR><LF> combination serves no special function in fixed-length format
   and is read as data or skipped as FILLER when encountered (see "FILLER
   Statement" below).  All characters are included in the length  of  the
   record.

   The choice of fixed-length record format is  specified  by  the  LRECL
   clause  of  the  LOAD  command (see "LOAD Command" below) or the LRECL
   clause of the DMD file (see "LRECL Statement In The DMD" below).  This
   clause specifies the length of fixed-length records, regardless of the
   <CR> <LF> appearing in the file.  The fixed-length example above would
   also  load correctly under variable length rules because <CR><LF> ends
   each record.  Only fixed-length rules can load the data if  <CR><LF>'s
   are not present.
   CREATING THE DATA BASE                                        Page 3-5
   Revision 4


   3.2.1.1  Delimited-field Input

   Fields  of  input  records  can  also  be   defined   by   delimiters.
   Delimited-field  records  contain fields separated by single-character
   delimiters.  Delimited-field data  files  are  easily  entered;   each
   field  can  be  delimited by a comma or other character and columns do
   not need to be carefully counted.  In delimited-field format  using  a
   comma as delimiter, the above records appear as:

        Jones,35,11/10/40<CR><LF>
        D'Amato,28<CR><LF>
        Harris,27,09/08/47<CR><LF>

   See "Delimited Fields in ATTRIBUTE Statements" for a full discussion.



   3.2.2  Data Types

   1022 recognizes eight types of data in input records:  INTEGER, DOUBLE
   INTEGER, COMP, DOUBLE COMP, REAL, COMP1, TEXT and DATE.



   3.2.2.1  INTEGER

   INTEGER data fields contain integer numeric values  between  plus  and
   minus  34,359,738,367.   An  integer  contains up to 11 digits with no
   intervening  spaces  or  commas.   Negative  values  are  preceded  or
   followed by a minus sign;  positive values may be preceded or followed
   by a plus sign.  On input, any leading or trailing blanks in the field
   are ignored and the value is converted to binary integer format inside
   the data set.

   Examples: 100
             -57309
             +283721

|  COBOL overpunch characters are also allowed  as  integer  input  data.
|  For  example,  -12345  can  appear  as 1234N, with N in the last digit
|  representing both the  negative  sign  and  the  value  5.   Overpunch
|  characters are allowed in data input files for LOAD, APPEND, TRANSACT,
|  CREATE, and subsequent unbundled operations, and in  COBOL  parameters
|  passed through DBxxxx calls.
|  
|  1022 recognizes the following overpunch characters:
|  
   CREATING THE DATA BASE                                        Page 3-6
   Revision 4


|                        COBOL OVERPUNCH CHARACTERS
|  
|       VALUE CHARACTER  VALUE CHARACTER  VALUE  CHARACTER        _____ _________  _____ _________  _____  _________
|  
|            1     A          -1    J          +0    ?
|            2     B          -2    K          +0    [
|            3     C          -3    L          +0    {
|            4     D          -4    M          +0    !
|            5     E          -5    N          -0    :
|            6     F          -6    O          -0    ]
|            7     G          -7    P          -0    }
|            8     H          -8    Q              
|            9     I          -9    R
|  
|  
|  The user can control 1022's processing of COBOL  overpunch  characters
|  by  setting  the  system  variable  SYSCBLSIGN.   These  are the three
|  possible values of SYSCBLSIGN:
|  
|       VALUE               MEANING        _____               _______
|  
|         0        Overpunch characters are disallowed.
|  
|         1        Overpunch characters are allowed in integer input data
|                  in data files (default).
|  
|         2        Overpunch characters are allowed in integer input data
|                  in  data files, in integers typed as input to commands
|                  like ADD and  ACCEPT,  and  as  arguments  to  integer
|                  conversion functions like INT("123N").
|  



   3.2.2.2  DOUBLE INTEGER

   DOUBLE INTEGER data fields contain integer numeric values between plus
   and minus 1,180,591,620,717,411,303,423.  A double integer contains up
   to 22 digits with no intervening spaces or  commas.   Negative  values
   are  preceded  or  followed  by  a minus sign;  positive values may be
   preceded or followed by  a  plus  sign.   On  input,  any  leading  or
   trailing blanks in the field are ignored and the value is converted to
   binary integer format inside the data set.  DOUBLE INTEGER  attributes
   may not be keyed and are not accepted as SPSS input.



   3.2.2.3  REAL

   REAL data fields may  contain  any  standard  numeric  representation,
   including  integer,  floating point, and scientific notation (E-type).
   On input the values are converted to  binary  floating  point  format.
   Values are limited to the following:
   CREATING THE DATA BASE                                        Page 3-7
   Revision 4


        Maximum Absolute Value:           1.70141E+38
        Minimum Non-zero Absolute Value:  1.46937E-39

   If more than eight significant digits are contained in the field, 1022
   uses the best attainable precision.  As in the case of INTEGER fields,
   leading and trailing blanks are ignored.

   Examples: 100.00
              .376E+28
             875      (converted to 875.00000)
             -4.3E-10



   3.2.2.4  TEXT

   TEXT data fields are interpreted as literal character  strings.   Each
   character  is  treated as a part of the string, including blanks, tabs
   and non-printing characters.  They may be up to 5,000 characters long.



   3.2.2.5  DATE

   DATE fields may contain almost any date form commonly recognized as  a
   date.

   Examples:

             General      General       American   European             _______      _______       ________   ________

             5/26/55     May-26-1955     52655 260555
             5-26-55     26-May-55      05261955 26051955
             05/26/55    May 26, 1955   19550526 26-05-55
             05/26/1955  May 26,55      550506 26-05-1955

   A date is stored internally in an 18-bit binary integer the  value  of
   which is the number of days since January 1, 1800 that represents that
   date.    Acceptable   dates   range   between   January 1, 1800    and
   September 22, 2517.  If the century is not specified, 1022 assumes the
   twentieth century by default.



   3.2.2.5.1  Delimited Dates

   Delimited dates contain  commas,  periods,  hyphens,  and  slashes  as
   equivalent delimiters.  Spaces may be used as delimiters when the date
   is quoted.  The dates 26-MAY-55 and "26.MAY 55" evaluate to  the  same
   date.

   Delimited dates are read  as  either  U.S.-style  (month,day,year)  or
   European-style  (day,month,year)  depending on the value of the system
   CREATING THE DATA BASE                                        Page 3-8
   Revision 4


   variable SYSEURODAT.  When SYSEURODAT is  0,  System  1022  looks  for
   U.S.-style  dates.   Then 2/3/75 is February 3, 1975.  When SYSEURODAT
   is 1, System 1022 looks for  European-style  dates.   Then  2/3/75  is
   March 2, 1975.



   3.2.2.5.2  All-numeric Dates

|  System 1022 accepts eight and  six  digit  all-numeric  dates  without
|  delimiters.   The  settings  of  the  system  variables  SYSNOYMD  and
|  SYSEURODAT and the composition of the digit string determine  the  way
|  in which System 1022 interprets an all-numeric, non-delimited date.
|  
|  
|  
|  3.2.2.5.2.1  Eight-Digit Dates
|  
|  When SYSNOYMD is set to 0 (the default), System 1022  first  tries  to
|  read  an  eight-digit  date as though it were in standard ANSII format
|  (YYYYMMDD),  regardless  of  the  setting  of  the   system   variable
|  SYSEURODAT.   For  example, if SYSNOYMD is set to 0, System 1022 reads
|  the date 19550526 as May 26, 1955.
|  
|  If the two digits for the month are greater than 12, or the two digits
|  for  the  day are greater than 31, then 1022 does not read the date as
|  YYYYMMDD.  Instead, it tries to read the string as an American date of
|  the form MMDDYYYY (if SYSEURODAT is set to 0, which is the default) or
|  as a European date of the form DDMMYYYY (if SYSEURODAT is set  to  1).
|  For example, when SYSEURODAT is set to 0, the date 05111956 is read as
|  May 11, 1956.  When SYSEURODAT is  set  to  1,  05111956  is  read  as
|  November 5, 1956.
|  
|  When SYSNOYMD is set to 1, System 1022 does not try to read the string
|  as  a  date of the form YYYYMMDD.  Rather, if SYSNOYMD is set to 1 and
|  SYSEURODAT is set to 0, System 1022 tries to read  the  string  as  an
|  American  date (MMDDYYYY).  If SYSNOYMD and SYSEURODAT are both set to
|  1, System 1022 tries to read the string as a European date (DDMMYYYY).
|  
|  
|  
|  3.2.2.5.2.2  Six-Digit Dates
|  
|  When SYSNOYMD is set to 0, System 1022 first tries to read a six-digit
|  date  as though it were in modified ANSII format (YYMMDD), in which YY
|  represents the last two digits of the year.  The  omitted  digits  are
|  assumed  to  be  19.   Thus,  when  SYSNOYMD  is set to 0, System 1022
|  interprets the date 550526 as May 26, 1955.
|  
|  
|  If the two digits for the month are greater than 12, or the two digits
|  for the day are greater than 31, then 1022 tries to read the string as
|  an American date of the form MMDDYY (if SYSEURODAT is set to 0,  which
   CREATING THE DATA BASE                                        Page 3-9
   Revision 4


|  is  the  default)  or  as  a  European  date  of  the  form DDMMYY (if
|  SYSEURODAT is set to 1).  For example, when SYSEURODAT is  set  to  0,
|  the date 051156 is read as May 11, 1956.  When SYSEURODAT is set to 1,
|  051156 is read as November 5, 1956.
|  
|  When SYSNOYMD is set to 1, System 1022 does not try to read the string
|  as date of the form YYMMDD.  Rather, if SYSEURODAT is set to 0, System
|  1022 tries to read the  string  as  an  American  date  (MMDDYY).   If
|  SYSEURODAT  is  set  10  1,  System 1022 tries to read the string as a
|  European date (DDMMYY).
|  
|  
|  
|  3.2.2.5.2.3  Seven-Digit And Five-Digit Dates
|  
|  A leading zero may be omitted from an all-numeric date, thus  yielding
|  a  seven-digit  or  a  five-digit  string.   In this case, System 1022
|  follows the same procedures for interpreting the string as a  date  as
|  it does for an eight-digit or six-digit string.
|  
|  For example, if SYSNOYMD is set to 0, System 1022 reads the date 50103
|  as  January 3, 1905.  If SYSNOYMD is set to 1 and SYSEURODAT is set to
|  0, 50103 is read as May 1, 1903.  If SYSNOYMD and SYSEURODAT are  both
|  set to 1, the date is read as January 5, 1903.



   3.2.2.5.2.4  Errors And Counted Dates

   An all-numeric DATE entry that is not acceptable in any form  gets  an
   error message in most 1022 commands.  However, such a DATE entry in an
   ADD, FIND, SEARCH, or CHANGE command is interpreted as the  number  of
   days  since  January  1,  1800.  For example, 000033 cannot be read as
   YYMMDD because day cannot be 33.  And it cannot be read as  MMDDYY  or
   DDMMYY  since  month and day cannot be 00.  So 1022 reads 000033 in an
   ADD or CHANGE command as February 3, 1800,  the  date  33  days  after
   January 1, 1800.



   3.2.2.6  COMP

   In SIXBIT mode, the COMP data type represents  an  integer  in  binary
   form  instead  of as SIXBIT characters.  A COMP data field starts on a
   word boundary and has length 6.
   CREATING THE DATA BASE                                       Page 3-10
   Revision 4


   3.2.2.7  DOUBLE COMP

   In SIXBIT mode, the DOUBLE COMP data type represents a double  integer
   in  binary  form  instead of as SIXBIT characters.  A DOUBLE COMP data
   field starts on a word boundary and has length 12.



   3.2.2.8  COMP1

   In SIXBIT mode, the COMP1 data type represents a real value in  binary
   form  instead  of as SIXBIT characters.  A COMP1 data field is aligned
   on a word boundary and has length 6.





   3.3  DESCRIPTION FILE

   The description file describes the input data file and  the  structure
   of  the  data set.  It can also specify loading procedures.  This file
   is called a Data Management Description file and is usually given  the
   extension DMD.

   Every 1022 data set requires a data description.  The  description  is
   usually  written with a text editor;  it must exist before 1022 builds
   the data set.  The description is a  series  of  statements  in  which
   keywords  are  separated  by  one  or  more  spaces, tabs, or carriage
   returns.  Text-editor line numbers are ignored, lower-case  characters
   are  interpreted  as  upper-case,  and  tabs  are  treated  as spaces.
   Statements in the description file may continue  from  line  to  line.
   Most   keywords  are  determined  by  their  first  three  characters.
   Remaining characters may be included,  but  are  ignored.   Everything
   between an exclamation point (!) and the end of the line is treated as
   a comment.

   Many description files contain only a list of attribute  descriptions.
   Figure 3-3 shows an example of such a simple description.

                       ------------------------------

        ATTRIBUTE NAME TEXT COLUMN 1 7
        ATTRIBUTE AGE INTEGER COLUMN 8 9
        ATTRIBUTE BIRTHDAY ABBREV BDAY DATE COLUMN 10 18


                                 Figure 3-3
                     Sample Description file BIRTH.DMD

                       ------------------------------
   CREATING THE DATA BASE                                       Page 3-11
   Revision 4


   This description file can be used to describe the  data  file  records
   shown in figure 3-4:

                       ------------------------------

        Jones  3511/10/40<CR><LF>
        D'Amato28        <CR><LF>
        Harris 2709/08/47<CR><LF>

                                 Figure 3-4
                         Sample Data file BIRTH.DMI

                       ------------------------------



   3.3.1  Basic ATTRIBUTE Statements

   ATTRIBUTE statements describe each attribute, defining its name,  data
   type,  and  position in the record.  This is the structure of the data
   set.  You may print the structure of an existing  data  set  with  the
   INFORM STRUCTURE command (see Chapter 7, "INFORM Command").  The basic
   ATTRIBUTE statement has the form:

                                              { COLUMN <m><n> }
       ATTRIBUTE <name> [ [TYPE] <data type>] {               } [KEYED]
                                              {  LENGTH <n>   }

   This is the simplest form of the ATTRIBUTE statement.  See  the  "More
   Complex  ATTRIBUTE Statement" section below for the full syntax.  This
   statement must give  at  least  the  attribute  name  and  data  field
   position  in  the  input  record.   The data type need not appear;  it
   defaults to TEXT if omitted.



   3.3.1.1  Attribute Names In ATTRIBUTE Statements

   Attribute  names  contain  letters,  numbers,  and   the   under-score
   character  (back-arrow  on  many  terminals).   The names begin with a
   letter and contain a maximum of 25 characters.

   An abbreviation may be specified with the  ABBREVIATION  clause.   For
   example:

        ATTRIBUTE BIRTHDAY ABBREV BDAY TYPE DATE COLUMN 10 18

   Abbreviations are up to five characters  long.   The  first  character
   must  be  a  letter.   All  attribute  names and abbreviations must be
   unique, and may not match any of the  1022  reserved  words  found  in
   Appendix B.

   The names and abbreviations of attributes may be changed after loading
   CREATING THE DATA BASE                                       Page 3-12
   Revision 4


   with the MODIFY command (see Chapter 7, "MODIFY Command").



   3.3.1.2  Data Types In ATTRIBUTE Statements

   The data type may be any of those  described  above  in  "Data  Types"
   (INTEGER,  DOUBLE  INTEGER,  REAL,  COMP, DOUBLE COMP, COMP1, TEXT, or
   DATE) or one of those described in the section "Special Data Types  in
   ATTRIBUTE  Statements" below.  The keyword TYPE may be omitted;  it is
   included in examples for clarity only.  If the data type  is  omitted,
   TEXT is assumed.



   3.3.1.3  COLUMN Or LENGTH In ATTRIBUTE Statements

   The COLUMN clause specifies the starting and ending positions  of  the
   data field:

        ATTRIBUTE NAME  TEXT  COLUMN 1 7

   indicates that the value for NAME is in the first seven  positions  of
   the  record.   Successive attributes need not occupy successive column
   positions, although this is most natural.  Not all columns need to  be
   used;  unused ones are ignored.

   The LENGTH clause specifies a position by giving the field width.  The
   field begins where the last field ended.  For example:

        ATTRIBUTE NAME TEXT LENGTH 7
        ATTRIBUTE AGE INTEGER LENGTH 2

   The value for AGE is in a  field  two  characters  wide,  starting  at
   column  8.   COLUMN  or  LENGTH  determines  where  the  value  for an
   attribute is found in the DMI file, but it does not necessarily  limit
   the  values which may be stored in numeric attributes.  Although 99 is
   the greatest value for AGE that the two columns of the DMI  file  will
   hold,  an  ADD  or  CHANGE  command  could specify a greater age.  The
   values that an integer attribute will accept and store are  determined
   by the RANGE values for that attribute (see "RANGE Clause in ATTRIBUTE
   Statements").



   3.3.1.4  FILLER Statement

   The FILLER statement is used to ignore parts of an input  record  when
   the  LENGTH  clause is used.  The FILLER statement may be used to skip
   the blanks between the AGE and BIRTHDAY fields, as follows:

        ATTRIBUTE NAME TEXT LENGTH 7
        ATTRIBUTE AGE INTEGER LENGTH 2
   CREATING THE DATA BASE                                       Page 3-13
   Revision 4


        FILLER 2
        ATTRIBUTE BIRTHDAY DATE LENGTH 8


   FILLER  does  not  have  the  same  meaning  as  in  a  COBOL   record
   description.   FILLER  only  skips  over  data  on input;  it does not
   allocate unused space in the data set.

   The following is an example of  a  data  description  which  uses  the
   FILLER   statement  to  align  COMP  and  COMP1  data  types  on  word
   boundaries.  The RECMODE statement is described below.

             RECMODE SIXBIT

             ATTRIBUTE JOB KEYED TEXT LEN 13
             ATTRIBUTE SSN KEYED TEXT LEN 9
             FILLER 2
             ATTRIBUTE SALARY COMP1 LEN 6
             ATTRIBUTE AGE INTEGER RANGE 1 100 LEN 3
             FILLER 3
             ATTRIBUTE BONUS COMP LEN 6

   Do not use the FILLER statement with delimited input  (see  "Delimited
   Fields in ATTRIBUTE Statements").



   3.3.1.5  Keyed Attributes In ATTRIBUTE Statements

   ACCESS KEYED specifies that 1022 build a key table for the attribute.

        Example:     ATTRIBUTE AGE INTEGER ACCESS KEYED

   The clause may be collapsed to the single word KEY or KEYED:

        Example:     ATTRIBUTE AGE INTEGER KEY

   Keyed attributes may appear in FIND commands to locate records quickly
   by  using  the key tables which are constructed during the building of
   the data set.  Because the key tables require additional  storage  and
   maintenance,  the user should designate attributes for keyed access as
   needed;  do not start by keying all attributes.  You  may  change  the
   access  designation  of  an  attribute with the KEY and UNKEY commands
   after  loading  the  data  set.   (See  Chapter  5,  "KEY  and   UNKEY
   Commands").

   DOUBLE INTEGER and DOUBLE COMP attributes may not be keyed.
   CREATING THE DATA BASE                                       Page 3-14
   Revision 4


   3.3.2  More Complex ATTRIBUTE Statements

   The basic ATTRIBUTE statement fills most needs in  describing  a  data
   set.   The  complete ATTRIBUTE statement offers additional options for
   more complex situations,  greater  efficiency,  and  system-maintained
   attributes.

   The full syntax of the ATTRIBUTE statement is:

       ATTRIBUTE <name> [ABBREVIATION <2nd name> ] [ [ACCESS] KEYED]


                   { INTEGER [RANGE <m><n>]    }
                   { REAL                      }
                   { COMP                      }
                   { COMP1                     }
                   { TEXT                      }
|         [ [TYPE] { DATE                      } ] [ KEYFILE <name> ]
                   { DOUBLE INTEGER            }
                   { DOUBLE COMP               }
                   { DATE OF ENTRY             }
                   { DATE OF CHANGE            }
                   { INTEGER OF IDENTIFICATION }


          { COLUMN <m><n> }         { TYPE     }  {  RECOVER    }
          {               }  [ERROR {          }  {             } ]
          { LENGTH <n>    }         { [NOTYPE] }  { [NORECOVER] }


                   {character}
          [DELIMIT {SPACE    } ]  [ADDITIVE]
                   {LF       }
                   {NONE     }



   3.3.2.1  RANGE Clause In ATTRIBUTE Statements

   For the INTEGER data type, an  optional  RANGE  clause  specifies  the
   range of permitted values for the attribute.  For example:

        ATTRIBUTE AGE INTEGER RANGE 1 99

   If 1022 detects input  values  outside  this  range,  it  gives  error
   messages and sets the values to zero.

   A RANGE clause reduces storage space for INTEGER attributes in bundled
   data  sets.  Without a RANGE clause, an INTEGER attribute occupies one
   word of disk  storage  and  stores  a  value  between  plus  or  minus
   34,359,738,367.   With  a  RANGE clause it occupies only the number of
   bits required to accommodate the range of zero to  the  larger  value,
   plus a sign bit if the range includes a negative number.
   CREATING THE DATA BASE                                       Page 3-15
   Revision 4


   Values which alter integer attributes are checked  to  be  within  the
   allowed ranges.  Messages print when the range is exceeded:

        %SYSID# nnn attribute OUT OF RANGE

   for each record in error.  The number nnn is the SYSID of the  record,
   and attribute is the name of the attribute being changed.  System 1022
   sets the attribute value to zero.

   The user suppresses the printing of these messages by typing:

        LET SYSRNGMSG 1.

   The messages are suppressed until the variable is reset to zero.



   3.3.2.2  Special Data Types In ATTRIBUTE Statements

   Some attributes in a data set may be designated for  special  purposes
   and  have special data types.  Only one attribute of each special data
   type may be used in any data set.  The special data types are DATE  OF
   ENTRY, DATE OF CHANGE, and INTEGER OF IDENTIFICATION.



   3.3.2.2.1  DATE OF ENTRY

   The user may define any one DATE attribute to be  the  DATE  OF  ENTRY
   attribute, the date that each record is added to the data set.

   Example:     ATTRIBUTE DE LENGTH 8 DATE OF ENTRY

   Whenever a record is added to the data set, the value of its  DATE  OF
   ENTRY  attribute  automatically becomes the current date.  The DATE OF
   ENTRY attribute cannot be specified in a CHANGE or ADD command; it  is
   maintained by 1022 and is available for reading only.

   As the data set is built, the value for the DATE OF ENTRY is read from
   its  field  on  the  input record.  You may override this by using the
   RESET option.  If the keyword RESET appears immediately after ENTRY in
   the  description  file, then the data on the input records is ignored,
   and the value of the DATE OF ENTRY attribute in  each  record  becomes
   the current date.

   Example:     ATTRIBUTE DE LENGTH 8 DATE OF ENTRY RESET

   Whenever it is used, RESET must immediately follow the  data  type  in
   the   ATTRIBUTE  statement.   RESET  does  not  affect  values  during
   execution of a CREATE command (described later).
   CREATING THE DATA BASE                                       Page 3-16
   Revision 4


   3.3.2.2.2  DATE OF CHANGE

   The user may define any one DATE attribute in a data  set  to  be  the
   DATE  OF  CHANGE attribute, the date that each record was changed by a
   CHANGE, ADD, or TRANSACT command.  Its use is analogous to the DATE OF
   ENTRY  attribute;  it  cannot  be  modified,  and  the RESET option is
   available when the data set is built.



   3.3.2.2.3  INTEGER OF IDENTIFICATION

   The user may define any one INTEGER attribute to  be  the  INTEGER  OF
   IDENTIFICATION attribute, an integer unique to each record.

   Example:     ATTRIBUTE IDN LENGTH 4 INTEGER OF IDENTIFICATION

   When a record is added to the data set, the INTEGER OF  IDENTIFICATION
   attribute  is  assigned  a  unique  number.   This attribute cannot be
   changed, but the RESET option is available when the data set is built.

   The INTEGER OF IDENTIFICATION attribute is a unique  identifier  which
   does  not  change  during  DUMP  and  LOAD  operations unless RESET is
   specified.  As a comparison, SYSID can be used to locate records,  but
   may  change when a data set is reloaded.  The values for an INTEGER OF
   IDENTIFICATION  start  at  1  and  increase  by  1  for  each  record.
   Previously  assigned  numbers are not reused, such as when a record is
   deleted.

   If RESET is not used when a data set is built, the initial values  are
   taken  from  the  field  designated by the user.  1022 does not verify
   that there are no duplicate values.  The values assigned by 1022  upon
   adding records start one higher than the highest value seen during the
   LOAD or DUMP.  When RESET is not used with CREATE, the values assigned
   by 1022 start at 1 upon adding records.

   A RANGE clause affects the INTEGER OF IDENTIFICATION attribute just as
   it  affects other attributes:  if the assigned value falls outside the
   range, 1022 gives an error message and sets  the  attribute  value  to
   zero.
|  
|  
|  
|  3.3.2.3  The KEYFILE Clause In ATTRIBUTE Statements (Large Data Sets)
|  
|  You can use the KEYFILE clause of the ATTRIBUTE statement to store the
|  attribute's  key tables in a separate auxiliary file.  You specify the
|  name of the auxiliary file  immediately  after  the  keyword  KEYFILE,
|  having  declared  the  file  in  the LOADING SECTION of the data set's
|  description file (see "LOADING SECTION of the DMD" below).
   CREATING THE DATA BASE                                       Page 3-17
   Revision 4


   3.3.2.4  Error Handling Options In ATTRIBUTE Statements

   The error handling described later in this  chapter  can  be  modified
   separately  for  each  attribute  by the ERROR clause in the ATTRIBUTE
   statement.  The clause has the form:

              { TYPE     }  {  RECOVER    }
        ERROR {          }  {             }
              { [NOTYPE] }  { [NORECOVER] }

   If errors are encountered, 1022 produces  an  error  log  file  called
   <name>.DME  where <name> is the same as the data set name.  This error
   log file contains a listing of all  the  errors  encountered  in  data
   during loading (see this chapter, Error Handling).

   The options TYPE and NOTYPE control the typeout of error  messages  on
   the  user's  terminal.  If TYPE is specified, error messages are typed
   on the terminal for each record in error during loading  (as  well  as
   sent  to  the  error log file).  The default of NOTYPE causes only one
   message to type at the terminal  for  each  attribute  which  had  any
   errors,  and  not  for  each record.  In either case, errors are still
   entered in the log file.

   With the RECOVER option, 1022 recovers from any errors  on  input  for
   integer  and  double integer attributes by ignoring illegal characters
   encountered.  If NORECOVER is specified  (default),  bad  data  causes
   zero or blanks to be used.

   Example:  ATTRIBUTE AGE INTEGER LENGTH 2 ERROR RECOVER

   In the above example, illegal characters are  ignored  on  input,  and
   error messages for each record do not appear on the user's terminal.

   ERROR NOTYPE NORECOVER is the default when there is  no  ERROR  clause
   for an attribute.



   3.3.2.5  Delimited Fields In ATTRIBUTE Statements

   Input fields are usually  defined  in  fixed,  columnar  format.   For
   convenience  with  hand-typed  records,  the LOAD command also accepts
   delimited-field records in which separate  fields  are  defined  by  a
   delimiter  rather  than column position.  For example, it is easier to
   type the following data file where fields are defined by commas rather
   than position:


   CREATING THE DATA BASE                                       Page 3-18
   Revision 4


        21,Johnson,Doris,A,1/1/83<CR><LF>
        36,Duplessis,Philippe,,1/1/83<CR><LF>
        55,McPherson,Mary,K,1/1/83<CR><LF>

                                 PERSON.DMI

        In this example, commas delimit each field.   The  second  record
        has no value for MIDDLE_INITIAL.

   You  specify  delimited-field  records  by  a  RECMODE  ASCII  DELIMIT
   statement  in  the  LOADING SECTION of the DMD (see "DELIMIT Clause in
   the DMD").  Such records must be ASCII variable-length  format.   This
   clause  usually defines the single delimiter used to end all the input
   fields.  For example, "RECMODE ASCII DELIMIT ," means that each  input
   field ends with a comma.

   In the following example, the PERSON.DMD file describes  the  data  of
   PERSON.DMI shown above:

        LOADING SECTION
           RECMODE ASCII DELIMIT ,
        STRUCTURE SECTION
           ATTRIBUTE AGE INTEGER LENGTH 2
           ATTRIBUTE SURNAME LENGTH 10
           ATTRIBUTE FIRST_NAME LENGTH 8
           ATTRIBUTE MIDDLE_INITIAL LENGTH 1
           ATTRIBUTE DOE DATE OF ENTRY LENGTH 8

                                 PERSON.DMD

   It is usual to use LENGTH specifications in descriptions of  delimited
   input.   The  length  of  each  attribute  is  the  maximum  number of
   characters which will be accepted for the attribute  from  the  input,
   not  counting the following delimiter.  Any extra input characters for
   an attribute are ignored.  Do not use  FILLER  clauses  for  delimited
   input;  they are ignored.

   COLUMN specifications may be used for  delimited  input,  for  example
   when  they  carry over from a description file originally designed for
   columnar  input.   Ensure  that  the  column  specifications  are   in
   increasing  order,  so that the stated order of attributes is also the
   order in which they are read from the record.  Any gaps in the columns
   specified  will  be  ignored;   only the lengths of the attributes and
   their order will affect delimited input.

   DIFFERENT DELIMITERS

   It may be convenient to mix delimiters in a data file, using different
   delimiting  characters  for different fields.  In these cases, use the
   DELIMIT clause in  an  ATTRIBUTE  statement  to  specify  a  different
   delimiter  for  an  individual  attribute.   The RECMODE ASCII DELIMIT
   clause is still required in the LOADING SECTION of the  DMD.   Without
|  it,  1022  ignores  DELIMIT  clauses in the ATTRIBUTE statements.  The
   CREATING THE DATA BASE                                       Page 3-19
   Revision 4


|  delimiter specified in the RECMODE ASCII DELIMIT clause is the default
|  for  all  attributes  except  those  for which some other delimiter is
|  specified in the ATTRIBUTE statement.

   For example, to describe the data of PERSON.DMI  using  the  slash  to
   divide  a  date  into  three  fields,  use  the  following description
   PERDAY.DMD:

        LOADING SECTION
           RECMODE ASCII DELIMIT ,
        STRUCTURE SECTION
           ATTRIBUTE AGE INTEGER LENGTH 2
           ATTRIBUTE SURNAME LENGTH 10
           ATTRIBUTE FIRST_NAME LENGTH 8
           ATTRIBUTE MIDDLE_INITIAL LENGTH 1
           ATTRIBUTE DAY INTEGER DELIMIT / LENGTH 2
           ATTRIBUTE MONTH INTEGER DELIMIT / LENGTH 2
           ATTRIBUTE YEAR INTEGER LENGTH 4

                                 PERDAY.DMD

        In this example, commas delimit all the  fields  except  DAY  and
        MONTH.  They are delimited by slashes.

   DELIMITERS COMBINED WITH POSITION

   You may also  mix  position-defined  and  delimited  fields  within  a
   record.  An individual attribute is position-defined when DELIMIT NONE
   is specified for it.

   In the following example, the data uses one position-defined field and
   several different characters for delimiters:

        LOADING SECTION
           RECMODE ASCII DELIMIT ,
        STRUCTURE SECTION
           ATTRIBUTE AGE INTEGER DELIMIT NONE LENGTH 2
           ATTRIBUTE SURNAME LENGTH 10
           ATTRIBUTE FIRST_NAME DELIMIT SPACE LENGTH 8
           ATTRIBUTE MIDDLE_INITIAL DELIMIT . LENGTH 1
           ATTRIBUTE DOE DATE OF ENTRY LENGTH 8

                                 PEOPLE.DMD


        21Johnson,Doris A.1/1/83<CR><LF>
        36Duplessis-Mornay,Philippe .1/1/83<CR><LF>
        55McPherson,Mary K.1/1/83<CR><LF>

                                 PEOPLE.DMI

        In this example, the first two columns of each record are read as
        AGE.   No  delimiter  is read by 1022 because of the DELIMIT NONE
   CREATING THE DATA BASE                                       Page 3-20
   Revision 4


        clause for the ATTRIBUTE AGE statement;   LENGTH  2  defines  the
        field.   The  SURNAME  field  is  terminated  with  a  comma, the
        delimiter specified in the RECMODE statement.   A  space  is  the
        delimiter  for  FIRST_NAME  and a period for MIDDLE_INITIAL;  the
        space and period are not stored in the  data  set.   The  SURNAME
        Duplessis-Mornay is truncated to Duplessis- because the LENGTH of
        SURNAME is limited to 10.

   You may specify any single character in the DELIMIT clause  in  either
   the  RECMODE  or ATTRIBUTE statements.  In addition, SPACE specifies a
   space as delimiter.  LF specifies a line-feed character,  or  <CR><LF>
   combination  for  convenience,  as  delimiter.   NONE specifies that a
   delimiter not be used for this attribute;  relative position  is  used
   to  determine  the  field.  The last field of each record may end with
   the <CR><LF> that ends the record, instead of any delimiter.  However,
   if  LF  ends  the  last  field, then a <CR><LF> must follow to end the
   record.

|  The LOAD, APPEND, and TRANSACT  commands  all  accept  delimited-field
|  records.



   3.3.2.6  Additive Attributes In ATTRIBUTE Statements

   The user may specify any attribute of  data  type  real,  integer,  or
   double   integer,  except  INTEGER  OF  IDENTIFICATION,  as  ADDITIVE.
   ADDITIVE attributes are only  used  with  the  TRANSACT  command  (see
   Chapter 5, TRANSACT Command).  When performing transactions, 1022 adds
   the value of an ADDITIVE attribute in  the  transaction  file  to  the
   corresponding  value  in  the  master  file.   The following statement
   defines "BALANCE" as an ADDITIVE attribute.

        ATTRIBUTE BALANCE REAL ADDITIVE LENGTH 6



   3.3.2.7  Order Of ATTRIBUTE Statements

   The description file contains a series of ATTRIBUTE  statements  which
   usually  appear  in  the same order as the corresponding fields in the
   input record.  System 1022 sorts the attributes by  first  column  and
   last  column  as  it builds the data set.  Prompts for the ADD command
   and the response to INFORM STRUCTURE follow the internal  order.   The
   internal order may differ from the order in the description file.
   CREATING THE DATA BASE                                       Page 3-21
   Revision 4


   3.3.3  Full Description File

   A description file often consists only of ATTRIBUTE statements, but  a
   full  description  file  can  contain  three  sections.  The ATTRIBUTE
   statements form the STRUCTURE SECTION.

   The possible sections are:

   1.  The LOADING section is optional and describes  the  input  device,
       the  output  device,  the scratch device, and other parameters for
       the loading process.

   2.  The STRUCTURE section describes the attributes of the data set.

   3.  The PARAMETER section is optional and specifies miscellaneous 1022
       parameters.

   The only required section of the description  file  is  the  STRUCTURE
   section.  The LOADING SECTION, if included, must precede the STRUCTURE
   SECTION.  The title lines, LOADING  SECTION,  STRUCTURE  SECTION,  and
   PARAMETER SECTION, may be omitted.

   The general form of the file is:

        [LOADING SECTION]

        [  option 1            ]
        [  option 2            ]
        [      .               ]

|       [PARAMETER SECTION    ]
|  
|       [  option 1           ]
|       [  option 2           ]
|       [      .              ]
|  
|       [STRUCTURE SECTION]
|  
|       attribute-description-1
|       attribute-description-2
|             .               
   CREATING THE DATA BASE                                       Page 3-22
   Revision 4


   3.3.4  LOADING SECTION Of The DMD

   The LOADING SECTION of the description file contains information about
   the devices and options used to load data.  The 1022 standard defaults
   apply to options that are not specified.

   Regardless of the loading section, any options specified in the  LOAD,
   CREATE,  or  DUMP  command  will  be used for that command.  See those
   commands for more information.

   The form of the LOADING section is:

    [LOADING SECTION]

       [DATA  <file-descriptor>*]

|                                                 { PAGES  <n> }
|      [SET  <data set-desc>* [ [ RECORDS <n> ] [ {            } ]**] ]
|                                                 { BLOCKS <n> }
|  
|                                           { PAGES  <n> }
|      [ [ AUXFILE <name> [ RECORDS <n> ] [ {            } ] ]...**]
|                                           { BLOCKS <n> }
|  
|                       { ASCII [ALIGN] }            {character}
|      [ RECMODE [ISAM] {               }  [DELIMIT  {SPACE    } ] ]
|                       { SIXBIT        }            {LF       }
|                                                    {NONE     }
|  
|             { V }
|      [LRECL {   } ] [ SCRATCH  <file-structure> ]
|             {<n>}

       [ ALLOCATE  <n>  [TRUNCATE [<m>] ]  [ATTEMPTS  <p>] ]

       [ NULL  <n> ]

       [ BLOCKSIZE  <n> ]

       [ BLOCKED <n> ]

                  { TERMINATOR }
       [ FORMFEED {            } ]
                  { IGNORE     }

   (* indicates that a file-structure name without a filename may be used
|  in  place of the more detailed file descriptor.  ** indicates that the
|  option is available only with the Large Data Sets Module.)

   The LOADING SECTION, when it is used, precedes the  STRUCTURE  SECTION
   containing  the ATTRIBUTE statements.  All of the above statements are
   optional.  Each is described below.
   CREATING THE DATA BASE                                       Page 3-23
   Revision 4


   3.3.4.1  DATA Statement In The DMD

   The DATA statement specifies the source of the input  data.   Normally
   1022  searches  for a file called <name>.DMI in the user's area, where
   <name> is the description file name given with the LOAD command.   Any
   of  the  default  values can be overridden by giving another choice in
   the DATA statement.  Unspecified parts remain as the default.
   For example:

        DATA PUBA:SECT1.LST[407,12]        ! There are no defaults

        DATA PUBA:SECT1                    ! .DMI and the user's area are
                                           ! the defaults

   The DATA statement also can specify any input device,  including  disk
   structures  and magnetic tape drives, by using the physical or logical
   device name.  For example:

        DATA DSKA:
        DATA MTA03:
        DATA JOE:

   When device names are used alone, 1022 continues to  use  the  default
   values  for the directory name (TOPS-20), or file name, extension, and
   project-programmer number (TOPS-10).  If  a  logical  device  name  is
   used, the name must be assigned to the device with an operating system
   command before the LOAD, CREATE, or, DUMP command is given.



   3.3.4.2  SET Statement In The DMD

   The SET statement specifies the 1022 output data  set  file.   If  not
   specified,  the  data set name is <name>.DMS, where <name> is the same
   as the DMD file name.  The file is written onto the user's  disk  area
   by  default.   The  SET statement can specify a device, file, and user
   area to override the default.  The data set may  be  written  only  to
   disk structures.

   If the user desires many data sets in one file, then both the data set
   name  and file-descripter are specified.  (See "Multiple Data Sets Per
   File" in this chapter.)

   Examples:

        If the following SET statements appear in  the  description  file
        TEST.DMD,  the commands LOAD TEST, CREATE TEST, or DUMP TEST have
        the following effects.


        SET PARTS.DMS

        This creates the data set named  PARTS  in  the  file  PARTS.DMS,
   CREATING THE DATA BASE                                       Page 3-24
   Revision 4


        using  TEST.DMD  as  the  description  file,  and TEST.DMI as the
        default input data.  A previous file PARTS.DMS is deleted  if  it
        contains  only the data set PARTS.  Otherwise, the data set PARTS
        is added to the file, making obsolete any previous data set  with
        that name and without reclaiming the obsolete data set space.

        SET PNUM IN PARTS.DMS

        This creates the data set named PNUM in the file  PARTS.DMS.   If
        the  file PARTS.DMS already exists, the data set PNUM is added to
        the file.  Should the file PARTS.DMS already contain a  data  set
        named PNUM, it is made obsolete by the new data set PNUM, and the
        obsolete blocks are not reused.  Other data sets are unaffected.



   3.3.4.2.1  SET Statement Protection

   You  may  specify  a  different  protection   code   in   the   output
   file-descriptor  than  the one the monitor would normally assign.  The
   protection code is enclosed in angle brackets (TOPS-10) or follows  ;P
   (TOPS-20) at the end of the file-descriptor.  For example:

        SET PUBD:TEST.DMS[502,100]<357>

        SET PUBD:<SMITH.MAIN>TEST.DMS;P775252

        SET <357>

        SET ;P775252

   If  only  the  protection  code  is  included,   the   rest   of   the
   file-descriptor has the standard default values.

   The TOPS-20 user can also specify a protection  code  by  setting  the
   1022  variable SYSPROT20, a 6 character text string which represents a
   protection code.  This code is used by the  LOAD,  CREATE,  DUMP,  and
   FILE   COPY   commands.   The  SYSPROT20  value  overrides  protection
   specified by the SET clause.  For example:

           LET SYSPROT20 EQ "775252".

   If the protection code is  not  specified  by  SYSPROT20  or  the  SET
   statement,  the  default file protection of the connected directory is
   used.
   CREATING THE DATA BASE                                       Page 3-25
   Revision 4


|  3.3.4.2.2  The SET And AUXFILE Statements In A Multifile Data Set  DMD
|             (Large Data Sets)
|  
|  Sites that have licensed the Large Data Sets module  can  split  large
|  data sets over several files on multidisk devices.  The user can place
|  groups of records or the  key  tables  for  individual  attributes  in
|  separate   auxiliary   files.   The  user  can  thereby  maintain  the
|  contiguity of the data and can also control the  allocation  of  space
|  and balance the system load.
|  
|  The distribution of records and key  tables  over  separate  files  is
|  specified  in  the DMD file with the SET and AUXFILE statements in the
|  LOADING  SECTION,  and  with  the  KEYFILE  clause  of  the  ATTRIBUTE
|  statements  in  the  STRUCTURE SECTION.  Consider the following sample
|  DMD file:
|  
|  LOADING SECTION
|    SET MYFILE.DMS RECORDS 0
|    AUXFILE AUX1.DMM RECORDS 10000
|    AUXFILE AUX2.DMM
|    AUXFILE AUX3.DMM RECORDS 10000
|            .
|            .
|            .
|  STRUCTURE SECTION
|    ATTRIBUTE LAST_NAME ABBREV LN KEYED TEXT KEYFILE AUX2.DMM LENGTH 15
|            .
|            .
|            .
|  
|  In this case, the SET statement specifies that no records  are  to  be
|  stored in MYFILE.DMS.  Instead, they are to be stored in the auxiliary
|  files AUX1.DMM and AUX3.DMM.  If the RECORDS argument is omitted  from
|  the SET statement, the default number of records that the DMS file may
|  hold is the maximum (134,000,000).  The SET statement with an explicit
|  RECORDS  specification  must appear in the DMD file if auxiliary files
|  are to be used to store records.  The SET statement need not appear if
|  auxiliary files are to be used for storing key tables.
|  
|  Auxiliary files, whether to hold records or key tables, are  specified
|  in  the  LOADING SECTION of the DMD file after the SET statement.  The
|  keyword AUXFILE precedes the name of each auxiliary file.  The default
|  extension for auxiliary files is DMM.  If an auxiliary file is to hold
|  records, the keyword RECORDS followed by a number must appear  in  the
|  AUXFILE  statement.   Otherwise, it is assumed that the file will hold
|  key tables.
|  
|  When an auxiliary file is  named  without  a  RECORDS  clause  in  the
|  LOADING SECTION of a DMD file, that file may only be used to store key
|  tables.  In the STRUCTURE SECTION of that file, the KEYFILE clause  of
|  an  ATTRIBUTE  statement  assigns  the  key table associated with that
|  attribute to that auxiliary file as shown in the example given  above.
|  It is not necessary that the attribute be KEYED in the DMD file to use
   CREATING THE DATA BASE                                       Page 3-26
   Revision 4


|  the KEYFILE clause.  The KEYFILE clause can mean that if the attribute
|  is keyed in the future, the key tables will be stored in the specified
|  auxiliary file.
|  
|  
|  
|  3.3.4.2.2.1  Determining File Size
|  
|  SET and AUXFILE statements may include a BLOCKS clause to specify  the
|  maximum   size  that  the  file  can  reach.   (On  TOPS-20,  a  PAGES
|  specification may take the place of the BLOCKS clause.)  For example,
|  
|       SET MYFILE.DMS RECORDS 100000000 PAGES 10000000
|  
|  or
|  
|    AUXFILE AUX1.DMM RECORDS 60000000 BLOCKS 6000000
|  
|  If no BLOCKS (or PAGES) specification is explicitly made,  each  named
|  file,  except the last, defaults to an upper limit of 8,000,000 blocks
|  (2,000,000 pages).  The last file named in the LOADING SECTION may  be
|  as  large  as the difference of the combined limits of the other named
|  files and  the  maximum  of  268,000,000  blocks  (67,000,000  pages).
|  User-specified  limits  on the last file are ignored by System 1022 up
|  to this number.
|  
|  As a general rule, it suffices to let the size of the key  tables  (or
|  the  set  of  records)  limit  the size of the files to which they are
|  assigned with no explicit mention of  blocks  or  pages.   The  BLOCKS
|  (PAGES)  clause has essentially two uses.  When the default limits are
|  too small for the projected size of  your  auxiliary  files,  you  may
|  specify  a  larger  number  of  blocks (pages) with the BLOCKS (PAGES)
|  clause.  Numbers smaller than the default may be  specified  when  the
|  key  tables  and  records  are  to be split over more than 64 separate
|  files (the maximum number of blocks for a file as a whole  divided  by
|  the 8,000,000 block auxiliary file default).
|  
|  The BLOCKS (PAGES) clause should be used with caution.   Suppose  that
|  the  block  limits  for a record-holding auxiliary file are too low to
|  accommodate the number of records specified.  System 1022 then  stores
|  the excess records in the next auxiliary file capable of holding them.
|  If no other auxiliary file named in the DMD can hold  the  records,  a
|  warning is issued and no more records are added.
   CREATING THE DATA BASE                                       Page 3-27
   Revision 4


   3.3.4.3  RECMODE Statement In The DMD

   The RECMODE statement specifies the mode, the overall file format,  of
   the  input  data  file.   System  1022  assumes ASCII if no RECMODE is
   specified.  The possible modes for a data input  file  are  ASCII  and
   SIXBIT and either may be ISAM.

|  In a "word-aligned" data file, each line of the file occupies an exact
|  number  of  computer words in the output file.  This is necessary, for
|  example, when a FORTRAN program is  to  read  the  file  using  direct
|  access  methods.  To do this, prepare a data description file with the
|  following clause in the LOADING section:
|  
|       RECMODE ASCII ALIGN
|  
|  System 1022 fills out each record to the next word boundary with nulls
|  following the <RET> which ends the line.



   3.3.4.3.1  DELIMIT Clause In The DMD

   The RECMODE ASCII DELIMIT statement specifies  the  delimiter  for  an
   ASCII   variable-length-record   file   with  delimited  fields.   See
   "Delimited Fields in ATTRIBUTE Statements" above.



   3.3.4.3.2  ISAM Data Files

   RECMODE ISAM specifies that the data file is an ISAM file.  A data set
   can be built from an ISAM file with the CREATE or LOAD command.

   The data file is the data portion (the .IDA  file)  of  an  ISAM  file
   system,  produced  by  the ISAM utility of the COBOL language.  An IDA
   file may be ISAM ASCII or ISAM SIXBIT.  If neither ASCII nor SIXBIT is
   specified with the ISAM option, 1022 assumes the file is SIXBIT.

   System 1022 does not read the IDX description file which  ISAM  builds
   to  describe  the data file.  The data file must be freshly created by
   ISAM or only updated in  place  after  creation.   If  ISAM  adds  new
   records  to  the IDA file, they may be linked into the data file using
   structures which 1022 cannot read.

   The DMD file used in the CREATE command must completely  describe  the
   full  ISAM  record,  including  FILLER at the end to describe trailing
   characters that are not part  of  1022  attributes.   Alternately  the
   LRECL  clause  can  state  the record length in characters, counting 6
   characters for each COMP or COMP-1 field in a SIXBIT ISAM data file.

   The logical record length (LRECL) of an ISAM record includes only  the
   defined  fields  of  the record.  Do not count any <CR><LF> characters
   following the record.
   CREATING THE DATA BASE                                       Page 3-28
   Revision 4


   3.3.4.4  LRECL Statement In The DMD

   The LRECL clause specifies the logical record length in bytes  of  the
   input data.  For example:

        DATA CARDS.DMI
        LRECL 80

   reads 80 character fixed-length records from DMI file CARDS.

   Normally  1022  assumes  variable-length  records,  terminated  by   a
   <CR><LF>  pair.   This  default condition can be specified by LRECL V.
   However, if the LRECL clause is used  with  a  numeric  argument,  all
   characters  including  <CR><LF>  are  treated  as  data  or  FILLER as
   specified in the DMD, and each  record  is  taken  as  the  number  of
   characters  specified.   The  <CR><LF>  sequence appears only in ASCII
   data files.

   The LRECL clause counts every character.  Aligned  files  may  include
   non-printing nulls;  LRECL counts these nulls also.  For a SIXBIT ISAM
   data file, the  LRECL  clause  states  the  record  length  in  bytes,
   counting  6  bytes  for each COMP or COMP-1 field.  The logical record
   length of an ISAM record includes  only  the  defined  fields  of  the
   record.   Do  not  count  any  <CR><LF>  characters following the ISAM
   record.



   3.3.4.5  SCRATCH Statement In The DMD

   The  SCRATCH  statement  specifies  a  separate  disk  structure   for
   temporary  storage  of  data  during  the sorting phase of the loading
   process.  Using separate structures has two advantages:  processing is
   faster  because  there is less contention between sorting and data set
   operations, and the possibility  of  running  out  of  disk  space  is
   reduced.   The  increase  in  efficiency can be considerable for large
   data sets.

   The file structure name  is  terminated  by  a  colon  as  in  a  file
   descriptor.  For example:

        SCRATCH PAK0:

   Consult  the  computer  operations  staff  on  the   availability   of
   structures for this purpose.
   CREATING THE DATA BASE                                       Page 3-29
   Revision 4


   3.3.4.6  ALLOCATE Statement In The DMD

   For TOPS-10 users, the ALLOCATE statement in a data  description  file
   indicates  the number of blocks to be reserved for the output data set
   file.  If  the  ALLOCATE  statement  is  omitted,  1022  automatically
   allocates  and  writes  blocks  as  they are needed.  The advantage of
   including the ALLOCATE statement in a DMD file is that the output file
   is  then  written  in  a  few large disk segments, resulting in faster
   random access retrieval.

   If the TRUNCATE clause of the ALLOCATE statement  is  specified,  1022
   trims  the  size  of  the  output file to the number of blocks written
   during the loading process.  An integer  n  can  follow  the  TRUNCATE
   clause,  in  which case 1022 retains n additional blocks at the end of
   the written file and reduces the file to that size.  This is useful if
   you  plan  to  add  more records to the data set at a later time.  For
   example:

             ALLOCATE 10000 TRUNCATE 500

   1022 reserves 10000 blocks for the data set.  After writing the  file,
   1022  shortens  it  to  its  actual  size plus 500 reserved, unwritten
   blocks.

   1022 allocates the specified number of blocks in repeated requests  to
   the monitor.  Each request is called an "attempt" and yields a smaller
   than desired segment of  physically  contiguous  blocks.   The  entire
   ALLOCATE  is  successful when the sum of the attempts yields the total
   number of blocks requested.  The user may wish to set an  upper  limit
   on  the number of attempts, since a large number of attempts implies a
   fragmented data set.  The optional ATTEMPTS clause enables a  user  to
   set  such  a limit.  An error is reported if the allocation would need
   to exceed that limit for successful completion.  For example:

             ALLOCATE 5000 ATTEMPTS 10

   directs 1022 to make at most 10 attempts to reserve 5000 blocks.

   Because TOPS-20 does not allocate contiguous blocks as  TOPS-10  does,
   the  inclusion  of an ALLOCATE statement in a TOPS-20 data description
   file merely produces  an  informational  warning  on  loading  and  is
   otherwise ignored.

   CREATING THE DATA BASE                                       Page 3-30
   Revision 4


   3.3.4.7  NULL Statement In The DMD

   The NULL statement specifies the  percentage  of  space  reserved  for
   later  entries  to  the key tables.  Use it only when planning massive
   additions or changes to the data set.  The parameter may range from 0%
   to  50%.  If the user plans no additions or changes, use the statement
   NULL 0.  NULL 6 is the default.

   Even when NULL 0 is used, later updates may be  done;   they  will  be
   somewhat less efficient than if a larger NULL factor were used.



   3.3.4.8  BLOCKSIZE Statement In The DMD

   The BLOCKSIZE statement specifies nonstandard blocksize for input from
   magnetic  tape.   The  integer n is the blocksize in words and must be
   given if other than standard 128 word blocks are  read.   The  monitor
   command  SET  BLOCKSIZE (DEC-10) or SET TAPE BLOCKSIZE (DEC-20) is not
   sufficient.  If input is from disk, BLOCKSIZE is ignored.

   There are 5 ASCII characters per word, or 6 SIXBIT characters.  Divide
   by  the  right  factor  to  compute words from record lengths on tape.
   Count all characters, including <CR> and <LF> characters.

   Example:

        Your tape is described as having 10 ASCII  records  per  physical
        tape  block,  each containing 78 characters with ending <CR><LF>.
        Thus, each block contains 800  characters,  or  160  words.   Use
        BLOCKSIZE 160.



   3.3.4.9  BLOCKED Statement In The DMD

   The BLOCKED  (no  abbreviation)  statement  describes  the  number  of
   records  to  a continuous storage block.  Blocking is a characteristic
   of the data file and the BLOCKED  parameter  must  match  it.   It  is
   common  in ISAM and SIXBIT data files.  See also the "CREATE Command".
   For example:

        BLOCKED 40

   specifies that 1 continuous segment  of  the  data  file  contains  40
   records and starts on a physical block boundary.  A gap appears in the
   file after each 40 records so that the next record starts on  a  block
   boundary.   The  blocking  factor of 40 tells 1022 where the gaps are.
   The BLOCKED statement may be included on the same  line  as  the  DATA
   statement.  For example:

        DATA FILE.DMI BLOCKED 40
   CREATING THE DATA BASE                                       Page 3-31
   Revision 4


   specifies that 1 storage block equals 40 records in FILE.DMI.



   3.3.4.10  FORMFEED Statement In The DMD

   The FORMFEED statement controls 1022's interpretation of formfeeds  in
   the  input  data.  It is used only with variable-length input records.
   The format is:

                 {   IGNORE   }
        FORMFEED {            }
                 { TERMINATOR }

   Formfeeds are treated as any other character when no  FORMFEED  clause
   appears.   FORMFEED  IGNORE  ignores  all formfeeds in the input file.
   FORMFEED TERMINATOR treats a formfeed just like <CR><LF>.



   3.3.5  PARAMETER SECTION Of The DMD

   The PARAMETER SECTION of the description file specifies optional  1022
   parameters.  The format is:

             [PARAMETER SECTION]

|                                     {  ENQ    [ RECLOCK ]}
|                 [ADDCLUSTER <n> ] [ {                    }
|                                     { [NOENQ] [NORECLOCK]}
|  F
|  
|  
|  
|  3.3.5.1  ADDCLUSTER In The DMD
|  
|  The ADDCLUSTER statement is only applicable at TOPS-10 sites.

   ADDCLUSTER controls the amount of space allocated when new records are
   added  to  the  data  set.   Unless the ALLOCATE command is used, 1022
   allocates new record space in  "clusters"  for  retrieval  efficiency.
   The  amount  of space allocated when existing space is exhausted is n%
   of the space so far used  by  the  data  set  file.   Thus  if  15  is
   specified,  1022  allocates  15% additional space when necessary.  The
   value for n is between 5 and 100.  The default is 10.

   Normally, 1022 allocates space silently, without typing  any  message.
   However,  if  the  user  sets  the  system  variable SYSALCMSG to 1, a
   message is typed by 1022.  For example:
   CREATING THE DATA BASE                                       Page 3-32
   Revision 4


        ALLOCATING nn BLOCKS mmm RECORDS

   where nn is the number of blocks allocated,  sufficient  to  hold  mmm
   records.  To suppress these messages, reset SYSALCMSG to zero.
|  
|  
|  
|  3.3.5.2  ENQ In The DMD
|  
|  The ENQ statement specifies that 1022 will queue updates to  the  data
|  set,  servicing  each  request in turn.  The NOENQ statement specifies
|  that 1022 will use successive attempts to update.   See  "Waiting  for
|  Update  Access"  in  Chapter  5  for  a full discussion.  NOENQ is the
|  default.
|  
|  You can override a NOENQ specification in either of two ways:
|  
|       1.  You can use the ENQ clause of the OPEN command when you  open
|           the data set.
|  
|       2.  You can use the MODIFY $ACCESS ENQ command to change the data
|           set definition.
|  
|  If the data set is not RECLOCK (see below), you can  override  an  ENQ
|  specification in either of two ways:
|  
|       1.  You can use the NOENQ clause of the  OPEN  command  when  you
|           open the data set.
|  
|       2.  You can use the MODIFY $ACCESS NOENQ command  to  change  the
|           data set's definition.
|  
|  To override an ENQ specification in a RECLOCK data set, you must first
|  use the MODIFY $ACCESS NORECLOCK command, and then use either the OPEN
|  NOENQ or MODIFY $ACCESS NOENQ command.
|  
|  
|  
|  3.3.5.3  RECLOCK/NORECLOCK Statement In The DMD
|  
|  The  RECLOCK/NORECLOCK  statement  determines   whether   record-level
|  locking  can  be  applied  to  the  data  set  during updates (see the
|  "Record-level Locking"  section  of  Chapter  5).   NORECLOCK  is  the
|  default and means that record-level locking cannot be used in updating
|  the data set.  To be enabled for record-level locking, a data set must
|  be  both  ENQ  and RECLOCK.  A data set cannot be RECLOCK unless it is
|  also ENQ, though a data set can be ENQ without being RECLOCK.
|  
|  To override a RECLOCK specification, use the MODIFY $ACCESS  NORECLOCK
|  command  (see  Chapter 7, "Modify Command").  To make a NORECLOCK data
|  set RECLOCK , open the data set ENQ and then use  the  MODIFY  $ACCESS
|  RECLOCK command.
   CREATING THE DATA BASE                                       Page 3-33
   Revision 4


   3.3.6  Example Of A Data Description File:  TRUCKS.DMD

   The following examples show full description files for a  TRUCKS  data
   set.  These are followed by a commentary on the examples.

   For TOPS-10 users

           !TRUCKS.DMD

        LOADING SECTION

           DATA MTA:  LRECL 45
           SET PUBD:TRUCKS.DMS[5000,200]
           SCRATCH DSKB:
           ALLOCATE 3000 TRUNCATE 500 ATTEMPTS 20
           NULL 25

        STRUCTURE SECTION
           ! This DMD last changed by L.K. 6/15

           ATTRIBUTE MFGR ABBREV MAKE TEXT KEY LENGTH 9
           FILLER 1
           ATTRIBUTE MODELYEAR ABBREV YR INTEGER RANGE 40 80 KEY LENGTH 2
           FILLER 1
           ATTRIBUTE ENGINETYPE ABBREV ENG TEXT LENGTH 3
           FILLER 1
           ATTRIBUTE PRICE ABBREV COST REAL LENGTH 5
           FILLER 1
           ATTRIBUTE ACQUISDATE ABBREV ACDAT DATE OF ENTRY KEY LENGTH 8
           FILLER 1
           ATTRIBUTE MILES INTEGER RANGE 0 200000 KEY LENGTH 6
           FILLER 1
           ATTRIBUTE CONDITION ABBREV COND TEXT LENGTH 4

        PARAMETER SECTION

           ADDCLUSTER 20
   CREATING THE DATA BASE                                       Page 3-34
   Revision 4


   For TOPS-20 users:

           !TRUCKS.DMD

        LOADING SECTION

           DATA MTA:  LRECL 45
           SET PUBD:<SMITH>TRUCKS.DMS
           SCRATCH DSKB:
           NULL 25

        STRUCTURE SECTION
           ! This DMD last changed by L.K. 6/15

           ATTRIBUTE MFGR ABBREV MAKE TEXT KEY LENGTH 9
           FILLER 1
           ATTRIBUTE MODELYEAR ABBREV YR INTEGER RANGE 40 80 KEY LENGTH 2
           FILLER 1
           ATTRIBUTE ENGINETYPE ABBREV ENG TEXT LENGTH 3
           FILLER 1
           ATTRIBUTE PRICE ABBREV COST REAL LENGTH 5
           FILLER 1
           ATTRIBUTE ACQUISDATE ABBREV ACDAT DATE OF ENTRY KEY LENGTH 8
           FILLER 1
           ATTRIBUTE MILES INTEGER RANGE 0 200000 KEY LENGTH 6
           FILLER 1
           ATTRIBUTE CONDITION ABBREV COND TEXT LENGTH 4


   The data set has information about the vehicles owned  by  a  company.
   For each truck the data set contains the following information:

        MANUFACTURER  :  9 characters
        MODEL YEAR    :  2 characters
        ENGINE TYPE   :  3 characters
        COST          :  5 characters
        DATE ACQUIRED :  8 characters
        MILEAGE       :  6 characters
        CONDITION     :  4 characters

   The information is loaded from magnetic  tape,  and  is  contained  in
   fixed-length records as follows:

        MACK      72 DSL 12000  3/7/72  75000  GOOD<CR><LF>
        LEYLAND   69 V-8 9000   4/12/69 120000 FAIR<CR><LF>

   The fields are separated by one  filler  space,  and  each  record  is
   separated  from the next by a <CR><LF> combination.  Since the records
   are fixed-length, these last two characters are counted into the LRECL
   length.  (LRECL is not a necessary specification here because <CR><LF>
   is sufficient to delimit records in variable-length form.)

   The input device is given as MTA: in the LOADING section.   A  logical
   CREATING THE DATA BASE                                       Page 3-35
   Revision 4


   name  MTA: is used here;  a physical device could also have been used.
   The SET option  supplies  the  name  of  the  output  file,  its  disk
   structure  and  user  area.  These need not be specified if the person
   loading the data set is logged into or connected to that area  of  the
   same structure.

   A scratch structure is specified to speed up the loading process.

   For TOPS-10 users the ALLOCATE statement allocates 3000 disk blocks in
   20  attempts.   Further, the output file is truncated to the number of
   blocks written, plus 500 for future additions.

   The NULL option reserves  25%  extra  space  in  the  key  tables  for
   anticipated large-scale updates to the data set.

   The TOPS-10 user PARAMETER SECTION contains the ADDCLUSTER option with
   a  value of 20, indicating that 20% additional space will be allocated
   when the space is needed.



   3.3.7  Overlapping Attributes

   In special cases, and with important limitations, a data set  can  use
   overlapping attributes.  That is, more than one attribute can take its
   values from all or part of the same input record field.  For  example,
   consider the following input file:

        GORDON 50  03/07/25<CR><LF>
        JONES  38  11/19/37<CR><LF>
        HAUSMAN22  06/30/53<CR><LF>

   The  following  data  description  makes   BIRTHDAY   and   BIRTH_YEAR
   overlapping  attributes.   Values  for  both  come from the field that
   includes columns 18 and 19.

        ATTRIBUTE NAME TEXT COLUMN 1 7
        ATTRIBUTE AGE INTEGER COLUMN 8 9
        ATTRIBUTE BIRTHDAY DATE COLUMN 12 19
        ATTRIBUTE BIRTH_YEAR INTEGER COLUMN 18 19

   This description is only possible with the COLUMN clause and not  with
   the LENGTH clause.

   Overlapping descriptions allow handling different parts  of  the  same
   data  item  independently.  Conflicts can arise if changes are made to
   such fields in unbundled data sets or if a DMD with overlapping fields
   is used to dump data.

   The conflicts are explained by the  way  that  1022  stores  data.   A
   bundled data set stores all attributes as independent internal fields,
   regardless of the placement of the fields in the DMI record.   Further
   processing  within  the  bundled  data  set  does  not depend on field
   CREATING THE DATA BASE                                       Page 3-36
   Revision 4


   placement.  Changes to one (bundled) attribute  do  not  affect  other
   attributes, and all key tables are maintained independently.

   The DUMP command writes each  attribute  field  independently  to  its
   destination  in  the  output  record,  when  dumping to a data file or
   unbundled data set.  The resulting value in any position is  the  last
   data written to that position.  The data from one field is overwritten
   by the data of an overlapping field.

   For example, the above description would write the value for  BIRTHDAY
   to  columns  12  through  19,  and  then  would  write  the  value for
   BIRTH_YEAR into columns 18 and 19,  overwriting  the  previous  digits
   there.  This causes no problems if either no changes have been made in
   BIRTHDAY and BIRTH_YEAR, or if the  user  has  been  careful  to  make
   matching  changes at all times.  System 1022 does not enforce matching
   changes to overlapping attributes in bundled datasets.

   There is no conflict in using DUMP to form  other  bundled  data  sets
   from  the  original  one,  even  when using DMD files with overlapping
   fields.  The internal representation that receives the data  does  not
   have overlapping fields in a bundled dataset.

   Unbundled  data  sets  offer  some  advantages  and   also   different
   conflicts.   The  data is stored in the data file exactly as described
   in the DMD description, including  the  overlap  of  characters.   For
   example,  a  change  in BIRTH_YEAR automatically changes BIRTHDAY with
   which it overlaps.

   The same considerations apply to the use  of  DUMP  as  are  described
   above in relation to bundled datasets.

   The most serious conflicts  can  occur  when  changes  to  overlapping
   attributes  "sneak"  changes  into  keyed  attributes.  Key values are
   updated only when the named attribute is changed,  to  match  the  new
   data value.  A change to a nearby overlapping attribute can change the
   data value without causing the key value to be updated.  An error will
   be  reported  at  the next attempt to change the named attribute, when
   1022 discovers the current key value does not match the  changed  data
   value.  These considerations also apply to the use of TRANSACT.

   Such conflicts can be avoided by (1) not keying overlapping attributes
   that  will  be  changed,  or (2) keying at most one of any overlapping
   group, and changing that one first whenever an update will result in a
   "sneak" change of its value.

   In common practice, a user might use an overlapping description  as  a
   convenient way of reading data into a data set and then change the DMD
   file to eliminate overlap if data is dumped in the future.
   CREATING THE DATA BASE                                       Page 3-37
   Revision 4


   3.4  COMMANDS FOR BUILDING A DATA SET

   The LOAD, CREATE, and DUMP commands produce new data sets.   The  LOAD
   command  uses  a  description  file to read a data file and to build a
   bundled data set.  The CREATE  command  uses  a  description  file  to
   connect a data file into an unbundled data set.  The DUMP command uses
   a description file and a source data set to write out a new bundled or
   unbundled data set, or to write a data file.



   3.4.1  Bundled Vs.  Unbundled Data Sets

   The LOAD command produces a bundled data set  that  combines  records,
   key  tables,  and the description in the DMS file.  The CREATE command
   produces an unbundled data set that keeps the data file unchanged  and
   puts only the key tables and description in a separate DMS file.

   The following compares some of the  advantages  and  disadvantages  of
   bundled and unbundled data sets.

   ADVANTAGES OF UNBUNDLED

        1.  Fast setup

            The CREATE command does not read through the data file or set
            up   key   table  information,  so  the  setup  is  immediate
            regardless of the length of the data file.  In the ideal case
            of  a  sequential  report, the user can use CREATE to build a
            data set using the sequential file and process it with a 1022
            report procedure.

        2.  Outside data access

            The  data  file  remains  directly   readable   by   standard
            programming  languages  like  FORTRAN  and  COBOL  because no
            special information is stored in the data file by 1022.   The
            data  file may be updated independently of 1022, but problems
            will arise for 1022 procedures if KEYED  fields  are  changed
            outside  1022  without later rebuilding those keys, or if new
            records are added outside 1022.

        3.  Reduced disk contention

            The data and keys (DMI  and  DMS  files)  can  be  placed  on
            separate disk structures to reduce disk contention.

   CREATING THE DATA BASE                                       Page 3-38
   Revision 4


   ADVANTAGES OF BUNDLED

        1.  Data error

            The data file is not processed  by  the  CREATE  command,  so
            errors of misalignment, data type, and range appear only when
            the data is accessed.  In a LOAD  command  these  errors  are
            recognized during loading.

        2.  Fewer channels

            Each bundled data set file requires one system  I/O  channel.
            Each  unbundled data set needs an extra system I/O channel to
            access the data file.  When there are many  data  sets  in  a
            data  base,  the  number  of channels needed may exceed those
            available.

        3.  Data compaction

            The unbundled data set can not  undergo  data  compaction  of
            numeric  items.   The  saving in space may be significant and
            worth the time to use LOAD to build a bundled data set.

        4.  Data conversion

            Numeric items in a bundled data  set  are  stored  in  binary
            form.   In an unbundled data set they may be in display form.
            1022 must convert these to binary form for processing,  which
            takes some time.  This is not required for numeric items in a
            bundled data set.

        5.  Deleted Records

            Deleted records in an  unbundled  data  set  must  be  marked
            before  deletion  so that other program systems will know the
            records are removed.

   CREATING THE DATA BASE                                       Page 3-39
   Revision 4


   3.5  LOAD COMMAND

   The LOAD command builds a bundled data set.  The format for  the  LOAD
   command is:

        LOAD [ DESC ] <file-descriptor-1>

             [ DATA <file-descriptor-2> ] [SET <data set-descriptor>]
|  
|            [NOKEYS] [MAX <n>] [NOMSG] [NODME]
|  
|            [CORE <n>] [BUFFER <n>] [CUSTDMI]

                      {<n>}              {  IGNORE  }
             [ LRECL  {   } ] [ FORMFEED {          } ]
                      {[V]}              {TERMINATOR} 

   Where:

   DESC <file-descriptor-1>    References a file containing  a  data  set
                               description.     The    description   file
                               normally  is  given  the  extension  .DMD,
                               which  1022  assumes as default.  Thus the
                               commands

                                    LOAD STOCK
                                    LOAD DESC STOCK

                               look for the description file STOCK.DMD .

   DATA <file-descriptor-2>    Specifies the name of the input data file.
                               If  no DATA clause is given, 1022 uses the
                               file with the same name as the description
                               file  and  the extension DMI.  A different
                               file may be specified by the  DATA  clause
                               in  the LOAD command or by the DATA option
                               in the description file.  The DATA  clause
                               in  the  command takes precedence.  If the
                               data file is not specified  and  does  not
                               exist,  1022  makes  a  data  set  with no
                               records.  Records may then be added to  it
                               interactively with the ADD command.

   SET <data set-descriptor>   Specifies the name of the data set and the
                               file  that  contains it.  If no SET clause
                               is given, 1022 builds a data set with  the
                               same  name  as  the description file, in a
                               file with the same name as the description
                               file  and  the extension DMS.  A different
                               output file may be specified  by  the  SET
                               clause  in  the LOAD command or by the SET
                               loading option in  the  description  file.
                               The  SET  clause  in the command overrides
   CREATING THE DATA BASE                                       Page 3-40
   Revision 4


                               the option in the description file.

   NOKEYS                      Suppresses generation of the  key  tables.
                               The LOAD command builds KEY tables for all
                               KEYED   attributes   unless   NOKEYS    is
                               specified.   With  NOKEYS, attributes that
                               are   KEYED   will   have    the    status
                               KEYED INACTIVE.    Key   tables   can   be
                               generated later for these attributes by  a
                               KEY ALL  command.  Other attributes may be
                               keyed later, regardless of their status at
                               load  time.   See  Chapter 5, KEY Command,
                               for more information.

   MAX                         Specifies the maximum number of records to
                               be processed.  This option is for test and
                               debugging procedures.   For  example,  the
                               command

                                    LOAD STOCK SET TEST1 MAX 100

                               reads the first 100 records  in  STOCK.DMI
                               and loads them into the new data set TEST1
                               in TEST1.DMS using  the  description  file
                               STOCK.DMD.  This short load gives the user
                               a quick way to verify the  correctness  of
                               the   DMD   description  by  noting  error
                               messages and by displaying the data  after
                               loading.   MAX  0  may be used to build an
                               empty data set.

   NOMSG                       Suppresses  the  printout   of   non-error
                               messages  normally  printed  as  the  LOAD
                               command processes the input data file.  It
                               is useful in production command files.

|  NODME                       Suppresses the creation of an error  (DME)
|                              file.   If  errors are detected during the
|                              execution of the command, they are written
|                              to the terminal.

   CORE                        Specifies the number of 1024  word  memory
                               segments  to  use  for  key table sorting.
                               The default is 5.  A value larger  than  5
                               may improve performance for loading 10,000
                               or more records.

   BUFFER                      Specifies the number of buffers to be used
                               in I/O.  The default is 2.  A value larger
                               than  2  improves  performance  for  large
                               loads.
|  
|  CUSTDMI                     Allows  the  user  to  load   records   in
   CREATING THE DATA BASE                                       Page 3-41
   Revision 4


|                              nonstandard  format  from  a host language
|                              program containing the DBLODR call.

   LRECL                       Specifies the logical record size  of  the
                               input  data.  See LRECL in LOADING SECTION
                               of DMD.

   FORMFEED                    Specifies the treatment  of  formfeeds  in
                               the  data  file.   See FORMFEED in LOADING
                               SECTION of DMD.


   The following examples demonstrate the LOAD command:

        LOAD STOCK

             This is the minimum LOAD command.  1022 uses the description
             file  named  STOCK.DMD  to  create  the  data  set  STOCK in
             STOCK.DMS from the data records in STOCK.DMI.  If  STOCK.DMI
             is  not  found,  an  empty  data  set  is  produced with the
             structure of a regular data set, but no  data  records.   If
             STOCK.DMD  is  not  found,  a 1022 error message is printed.
             Don't type LOAD STOCK.DMI;  1022 will report  errors  trying
             to read your data as if it were a DMD file.

        LOAD DESC STOCK DATA STOCK SET STOCK

        LOAD DESC STOCK.DMD DATA STOCK.DMI SET STOCK.DMS

             The above two examples are equivalent to the first  example,
             except  that they require STOCK.DMI to exist or they give an
             error message.

        LOAD DESC STOCK DATA STOCK SET PARTS IN STOCK

             This is the same as the two preceding examples, except  that
             the  data set is PARTS in the file STOCK.DMS.  See "Multiple
             Data Sets Per File" this chapter.

        LOAD STOCK DATA OLDDAT SET CURRENT

             Here  the  data  set  CURRENT.DMS  is  produced,  using  the
             description found in STOCK.DMD and the data in OLDDAT.DMI.

        LOAD STOCK.001 DATA STOCK.DAT SET CURRENT.ZZZ

             This example demonstrates filename extensions  specified  in
             the  command.   The  data  set  CURRENT.ZZZ is created using
             information in the  description  STOCK.001  and  records  in
             STOCK.DAT.

        LOAD STOCK NOKEYS
   CREATING THE DATA BASE                                       Page 3-42
   Revision 4


             This creates the data  set  STOCK.DMS  using  STOCK.DMD  and
             STOCK.DMI  as in the first example, except no key tables are
             generated;  attributes defined as KEYED in the DMD file have
             the  status KEYED INACTIVE in the new data set.  The command
             KEY ALL builds these key tables.

        LOAD STOCK MAX 100

             Here the user has a file STOCK.DMI with a  large  number  of
             records, but wishes to create a test case data set using the
             first 100 records in STOCK.DMI.

        LOAD STOCK NOMSG

             In this  example,  all  non-error  messages  are  suppressed
             during  creation  of  the  data  set and processing of input
             records.




   3.5.1  LOAD Examples

   The following examples show the full procedure for loading a data  set
   on TOPS-10 and TOPS-20.  The examples load a data set using data and a
   description like those for TRUCKS shown earlier in this chapter.  Here
   data  is  loaded  directly  from a disk resident file.  These examples
   show the 1022 loading messages.

   If the file TRUCKS.DMD resides in the user's area, he loads  the  data
   set  as  follows.   (Commands  typed by the user are recognized by the
   monitor "." or "@", and 1022 "*" command prompts.)
   CREATING THE DATA BASE                                       Page 3-43
   Revision 4


   For TOPS-10 users:

        .R 1022
        3/17/83
        System 1022A 116A(177)

        * LOAD TRUCKS

        System 1022 Data Loading Program

        Allocated 3000 blocks in 12 attempts
        %Errors on input for attribute COST
        15000 records processed 1250 blocks written on phase 2
        processing keyed attributes:
        MFGR (30 blocks, 14 values)
        MODELYEAR (32 blocks, 16 values)
        ACQUISDATE (150 blocks, 280 values)
        MILES (300 blocks, 720 values)
        582 blocks written on phase 3
        2332 blocks final allocation, 500 reserved (unwritten) blocks


   For TOPS-20 users:

        @1022
        3/17/83
        System 1022A 116A(177)

        * LOAD TRUCKS

        System 1022 Data Loading Program

        No errors on DESCRIPTION file
        %Errors on input for attribute COST
        15000 records processed 313 pages written on phase 2
        processing keyed attributes:
        MFGR (8 pages, 14 values)
        MODELYEAR (8 pages, 16 values)
        ACQUISDATE (38 pages, 280 values)
        MILES (75 pages, 720 values)
        146 pages written on phase 3


   In this case, the 1022 response indicates that  errors  were  detected
   for  values  of  the  attribute  COST.  These can be checked using the
   error log file described in this section.

   To load data from a tape file, assign the tape.

   Example:

        .Assign MTA2: MTA:
        MTA2 Assigned
   CREATING THE DATA BASE                                       Page 3-44
   Revision 4


   or

        @ASSIGN MTA2:
        @DEFINE MTA: MTA2:

   "Examples of a Data Description File:  TRUCKS.DMD" shows  the  LOADING
   SECTION of the DMD for a tape file.



   3.5.2  Error Handling

   Error handling is similar for the LOAD, APPEND, and TRANSACT commands.
   System 1022 issues error messages when it detects illegal input in any
   of these commands or encounters record-matching irregularities in  the
   TRANSACT  command.   Errors  involving invalid data format or integers
   out of specified range result in error messages  being  typed  to  the
   terminal and written to an error log file on the disk.  Error messages
   of this sort appear at the terminal in the following form:
   CREATING THE DATA BASE                                      Page 3-44A
   Revision 4


        %errors on input for attribute <attribute-name>

   This message types only once for each attribute that has  any  errors.
   The  user  can  also  print  the  log file messages on the terminal by
   specifying the ERROR TYPE option for an attribute in  the  description
   file.

   In the case of record-matching irregularities in the TRANSACT command,
   the  user  must specify that these be typed on the terminal or written
   to an error file, or both, when the TRANSACT command is given.

   The error log file is called <name>.DME, where <name> is the  filename
   of the input data file.

   Log file error messages may have either of two forms depending on  the
   current setting of the system variable SYSDMETRID.  When SYSDMETRID is
   set to 0, error log file messages have the form:

        MASTER ID      ![ATTRIBUTE]      ERROR TYPE:LOCATOR VALUE

   Where:

        MASTER ID       Is the System 1022 internal identification number
                        (SYSID)  of the problematic record in the current
                        (master) data set.

        ATTRIBUTE       Is the name of the attribute  in  which  the  bad
                        data  appears.  The attribute name appears in the
                        error message only when the data  ERROR  TYPE  is
                        LAINVI, LARANG, TRINVI, or TRRANG.

        ERROR TYPE      For the LOAD and APPEND  commands,  the  possible
                        error types are:

                           LAINVI - Invalid  input.   Illegal  characters
                                    appear  in  the field, the data is in
                                    incorrect form or does not  represent
                                    a  permitted value.  If ERROR RECOVER
                                    is specified, 1022 makes a value  out
                                    of  the  illegal  characters, if any.
                                    See  "Error   Handling   Options   in
                                    ATTRIBUTE statements."

                           LARANG - Out  of  range.   The  value  of   an
                                    integer is out of the specified range
                                    for the attribute.  The bad  data  is
                                    changed to 0.

                        For the  TRANSACT  command,  the  possible  error
                        types are:

                           TRINVI - Invalid Input.  TRINVI is  equivalent
                                    to LAINVI.
   CREATING THE DATA BASE                                      Page 3-44B
   Revision 4


                           TRRANG - Out of range.  TRRANG  is  equivalent
                                    to LARANG.

                           TRAPIG - APPLIED IGNORE.  A transaction record
                                    matches  a master data set record but
                                    the match has been ignored.

                           TRUNAP - UNAPPLIED.   The  transaction  record
                                    does  not  match  any master data set
                                    record.

                           TRMDUP - Duplicates for the locator value have
                                    been found in the master data set.

                           TRTDUP - Duplicates for the locator value have
                                    been found in the transaction file.

                           TRADLT - APPLIED DELETE.   A  matching  master
                                    data set record has been deleted.

                           TRAPLY - APPLIED  APPLY.   Changes  have  been
                                    made  in  a  master  data  set record
                                    using the values of  the  transaction
                                    fields  in  the  matching transaction
                                    record.

        LOCATOR VALUE   Is the data string containing the error, when the
                        ERROR  TYPE is LAINVI, LARANG, TRINVI, or TRRANG.
                        Otherwise, LOCATOR VALUE  is  the  value  of  the
                        locator for the record involved.

   When SYSDMETRID is set to 1, error log messages have the form:

        
   5;MASTER ID  !TRANSACTION ID  [ATTRIBUTE]  ERROR TYPE:LOCATOR VALUE

   where TRANSACTION ID is the System 1022 internal identification number
   (SYSID)   of  the  problematic  transaction  record,  and  MASTER  ID,
   ATTRIBUTE, ERROR TYPE, and LOCATOR VALUE are as just defined.

   The format of the error log file  allows  a  FIND  command  to  easily
   select all error records as a group for inspection.  The user may then
   use CHANGE commands to correct the values.

   To select all error records, use the command:

        FIND SYSID EQ @name.DME

   The log file thus is used as a command file, supplying the  conditions
   for  the  FIND  command  (comments are ignored), and the user may then
   determine what the errors are.
   CREATING THE DATA BASE                                       Page 3-45
   Revision 4


   For greater flexibility in using the error information, the  user  may
   also  issue  a  LOAD or CREATE command to build an error data set with
   the error file and with either of  the  following  description  files,
   depending on the setting of the system variable SYSDMETRID:

                               SYSDMETRID = 0

             ATTRIBUTE MASTER_IDNUMBER INTEGER COLUMN 2 10
             ATTRIBUTE ATTRIBUTE_NAME COLUMN 14 38
             ATTRIBUTE ERROR_TYPE COLUMN 40 45
             ATTRIBUTE LOCATOR_VALUE COLUMN 47 70

                                     or

                               SYSDMETRID = 1

             ATTRIBUTE MASTER_IDNUMBER INTEGER COLUMN 1 9
             ATTRIBUTE TRANSACTION_IDNUMBER INTEGER COLUMN 13 21
             ATTRIBUTE ATTRIBUTE_NAME COLUMN 24 48
             ATTRIBUTE ERROR_TYPE COLUMN 50 55
             ATTRIBUTE LOCATOR_VALUE COLUMN 57 80

   When the LOAD command includes an  LRECL  clause,  normal  line  break
   characters  are  read  as  data.   Occasionally  these  characters are
   included with invalid input and must be written on the error file.
   The following substitutions are made to keep this file readable:

             Original character           Its form in the error file             ________ _________           ___ ____ __ ___ _____ ____

             Carriage Return              <CR>
             Linefeed                     <LF>
             Formfeed                     <FF>
             Escape                       <ES>



   3.6  CREATE COMMAND

   The CREATE command is similar to to the  LOAD  command;   it  prepares
   data  for  processing  by  1022.   The  CREATE  command keeps the data
   "unbundled" in its original file, without changing the  data  file  in
   any  way.   All records in the unbundled data file (DMI) must be fixed                                                                    _____
   length.  All other information is maintained  in  the  DMS  file.   In   ______
   contrast,  the  LOAD  comand  "bundles"  data records, keys, and other
   information into one data set by copying data  from  the  source  data
   file.   See  the  comparison  of  these  commands  in the "Bundled Vs.
   Unbundled Data Sets" section earlier in this chapter.

   Although an unbundled data set has a different physical structure from
   a  bundled one, all System 1022 procedures are the same for both.  For
   example, an OPEN command looks the same whether a user  is  opening  a
   bundled  or  unbundled  data  set.   OPEN  with the unbundled data set
   actually  opens  both  the  data  set  and  data  file,  but  this  is
   CREATING THE DATA BASE                                       Page 3-46
   Revision 4


   transparent to the user.

   The CREATE command does not  automatically  build  keys  as  the  LOAD
   command  does.   Attributes  specified  as  ACCESS  KEYED  in the data
   description file become KEYED INACTIVE after creation of the unbundled
   data  set.   A  KEY  ALL  command  can be used to generate the keys if
   desired.  Other attributes can also  be  keyed,  regardless  of  their
   initial keyed status.

   The format of the command is:

        CREATE DESC <file-descriptor-1>

           [DATA <file-descriptor-2>] [SET <data set-descriptor>]

           [NOMSG] [LRECL <n>]

   Where:

   DESC <file-descriptor-1>  Specifies the name of the DMD file.

   DATA <file-descriptor-2>  Specifies the name of the DMI file.

   SET <data set-descriptor> Specifies the name of the DMS  file  or  the
                             name of a data set in a DMS file.

   NOMSG                     Suppresses  the  printout  of  informational
                             messages  normally printed during processing
                             of the CREATE command.

   LRECL <n>                 Specifies the logical record  length.   Same
                             as  LRECL  in  LOADING  SECTION of DMD.  See
                             there.

   The user may update information in the data file of an unbundled  data
   set  by using commands in System 1022.  Any keys which have been built
   are automatically maintained when changes are done with 1022.

   When numeric display fields are updated in the data file, the new data
   is  written  according  to  the default numeric to display conversions
   (described later in this chapter).  When records are added with ADD or
   APPEND,  the new records go at the end of the data file and extend its
   length.  The form of the new records is compatible with the data file,
   as  described  in  the LOADING SECTION of the description file used in
   the CREATE command.

   When records are deleted using System 1022, the records  in  the  data
   file remain unchanged.  The record is deleted logically to 1022 alone.
   To mark records as deleted to other program  systems,  the  user  must
   change  a  tag  field value to indicate the deletion, before doing the
   DELETE command.

   Examples:
   CREATING THE DATA BASE                                       Page 3-47
   Revision 4


        1.  CREATE DESC STOCK

            This creates STOCK in STOCK.DMS and accesses the data records
            in STOCK.DMI.


        2.  CREATE DESC STOCK DATA INPUT.DAT

            Creates STOCK in STOCK.DMS and accesses the data  records  in
            INPUT.DAT.


        3.  CREATE DESC STOCK SET BONDS.SET

            Creates BONDS in BONDS.SET and accesses the data  records  in
            BONDS.DMI.
   CREATING THE DATA BASE                                       Page 3-48
   Revision 4


        4.  CREATE DESC STOCK SET OUTPUT IN PARTS.DMS NOMSG

            Creates OUTPUT in PARTS.DMS with the structure  described  in
            STOCK.DMD  and  the  data  in  OUTPUT.DMI.  No non-error 1022
            messages are printed during the processing of this command.


   A specification on the LOAD, CREATE, or DUMP  command  line  overrides
   any DATA or SET clause inside a DMD file.

   If no data file is found when building a data set with CREATE, a  null
   data file is created, and the data set contains zero records.

   Users should not use CREATE to build a data set with a data file  that
   is  already  part  of an unbundled data set and is being updated.  The
   two different resulting data sets will update the same data file,  and
   conflicts will occur.

   The special attributes, INTEGER OF IDENTIFICATION, DATE OF ENTRY,  and
   DATE  OF  CHANGE are not reset by a RESET statement in the description
   when the CREATE command executes.



   3.6.1  RELOCATE DATA Command

   The RELOCATE DATA command modifies  the  information  in  the  current
   unbundled  DMS file about the location and name of the associated data
   file.  Use this command if you change the location or name of the data
   file.

   The command has the form:

        RELOCATE DATA file-descriptor

   The following example uses the RELOCATE  command  and  then  the  FILE
   RENAME command to change the location and name of the data file of the
   RTEST data set.

   Example:

        * OPEN RTEST
        * INFORM FILES
        JFN 7 PS:<ABRAMS>RTEST.DMS
        JFN 9 PS:<ABRAMS>RTEST.DMI
        * RELOCATE DATA PS:<ABRAMS.OLD>RESERV.DMI
        RELOCATE DATA PS:<ABRAMS>RTEST.DMI => PS:<ABRAMS.OLD>RESERV.DMI
        %WARNING: New datafile does not currently exist.
        * FILE RENAME PS:<ABRAMS>RTEST.DMI PS:<ABRAMS.OLD>RESERV.DMI
        * INFORM FILES
        JFN 7 PS:<ABRAMS>RTEST.DMS
        JFN 9 PS:<ABRAMS.OLD>RESERV.DMI
   CREATING THE DATA BASE                                       Page 3-49
   Revision 4


   Only the data set owner can issue the RELOCATE DATA  command;   change
   the owner of the data set using the ADMIT OWNER commmand before moving
   the DMI portion of the unbundled data set.

   RELOCATE DATA is also useful to fully specify a DMI  file.   When  you
   build  an  unbundled  data  set with CREATE, 1022 records the DMI file
   descriptor in the DMS file.  When you open the  data  set,  1022  uses
   this information to locate the DMI file.  Usually you specify the full
   DMI file descriptor in the CREATE command.  For example:

        * CREATE DESC RTEST DATA PS:<ABRAMS>RTEST.DMI

   If you create the data set using the 1022 defaults for the data  file,
   a user on another directory may not be able to access your data set.

   For example, a user logged in as PS:<ABRAMS> creates a data set in his
   area without specifying all the file name information:

        * CREATE DESC RTEST

   When another user, PS:<BARTLETT>, tries to open the data set from  her
   own area, she gets an error:

        * OPEN PS:<ABRAMS>RTEST
        1022 GTJFN error (600104) File not found, File: DSK:RTEST.DMI
        ? (OP2) Dataset not found

   Since the device and area have not been specified  in  the  DMS  file,
   1022 checks the default device DSK: and finds no file DSK:RTEST.DMI.

   ABRAMS can use the RELOCATE DATA command to  specify  the  device  and
   directory and allow other users access to his data set:

        * OPEN RTEST
        * RELOCATE DATA PS:<ABRAMS>RTEST

   If OPEN does not locate the DMI file on the area recorded in  the  DMS
|  file, it first checks the directory in which the DMS file resides.  If
|  it does not find it there, it checks the user's current area or PPN to
   locate  the  file.   If  it then finds it, the OPEN proceeds, but 1022
   gives a warning message.  If the RTEST.DMI file is moved from <ABRAMS>
   to  <BARTLETT>, BARTLETT receives the following message when she opens
   the data set:

        * OPEN PS:<ABRAMS>RTEST
        1022 GTJFN error (600077) No such file type,
        File: PS:<ABRAMS>RTEST.DMI
        % Using data file RTEST.DMI for dataset #1
        *

   If an unbundled data set  is  moved  to  a  new  area,  these  warning
   messages  will appear until the owner issues the RELOCATE DATA command
|  to validate the new data file location.  If an unbundled  file  cannot
   CREATING THE DATA BASE                                       Page 3-50
   Revision 4


|  be  parsed,  it  defaults to the same file name as the data set.  This
|  only happens with a data set is moved from TOPS-10 to TOPS-20 or  from
|  TOPS-20 to TOPS-10.

   RELOCATE DATA, unlike CREATE, writes a logical name into the DMS  file
   that is interpreted when the data set is opened.  The command RELOCATE
   DATA LOG:RTEST.DMI writes LOG:RTEST.DMI into the data set.   When  you
   open  the  RTEST data set, 1022 uses the current definition of LOG: to
   locate RTEST.DMI.
|  
|  
|  
|  3.6.2  RELOCATE AUXFILE Command (Large Data Sets)
|  
|  At sites licensing the Large Data Sets Module, the user has the option
|  of  moving an auxiliary file to a new location, such as to a different
|  device.  This involves a six-step procedure, the first step  of  which
|  is optional:
|  
|       1.  Before entering 1022, create an empty file  whose  descriptor
|           names the new location;
|  
|       2.  Enter 1022 and open the main file
|  
|       3.  Issue the RELOCATE AUXFILE command
|  
|       4.  Close the main file
|  
|       5.  Exit from 1022
|  
|       6.  Either rename the auxfile to its new location or copy  it  to
|           the new location and delete the original.
|  
|  If you omit step  1,  the  following  message  will  appear  when  the
|  RELOCATE AUXFILE command finishes executing:
|  
|       %WARNING:  New AUXFILE does not currently exist
|  
|  The following illustrates the procedure for  relocating  an  auxiliary
|  file on TOPS-20:
|  
|       *OPEN MYFILE
|  
|       *RELOCATE AUXFILE AUX2.DMM PS:<LOPEZ>MYAUX2.DMM
|  
|       *CLOSE                             
|  
|       *EXIT
|  
|       @RENAME AUX2.DMM PS:<LOPEZ>MYAUX2.DMM
|  
|                                           or
   CREATING THE DATA BASE                                       Page 3-51
   Revision 4


|       @COPY AUX2.DMM PS:<LOPEZ>MYAUX2.DMM
|  
|       @DELETE AUX2.DMM
|  
|  On TOPS-10, the procedure is:
|  
|       *OPEN MYFILE
|  
|       *RELOCATE AUXFILE AUX2.DMM DSKA:MYAUX2.DMM[203,507]
|  
|       *CLOSE
|  
|       *EXIT
|  
|       .RENAME DSKA:MYAUX2.DMM[203,507] = AUX2.DMM
|  
|                        or
|  
|       .COPY DSKA:MYAUX2.DMM[203,507] = AUX2.DMM
|  
|       .DELETE AUX2.DMM
|  
|  Note that both the old and new names for the auxiliary  file  must  be
|  given  in  issuing  the RELOCATE AUXFILE command.  The device on which
|  the file is  to  reside  must  also  be  specified.   To  successfully
|  relocate  (and  later  retrieve) an auxiliary file, all of these steps
|  must be executed in the order given here.



   3.7  DUMP COMMAND

   The DUMP command writes a new data set or data file containing records
   selected  from  an existing data set.  In this discussion, we call the
   new data set or data file the output  data  set  or  data  file;   the                                 ______  ____  ___      ____  ____
   existing data set is the master data set.                            ______ ____ ___

   The output data set or data file may differ from the master  data  set
   in  several  ways:   the type of the output data set can be changed to
   bundled or unbundled;  the records may be reordered;  and the data may
   be  restructured  using a new data description file.  The DUMP command
   writes a new data set without keys, leaving the  user  the  option  of
   rebuilding  key tables.  (See Chapter 5, "The KEY Command".) DUMP does
   not check for data errors or range errors.   The  user  specifies  the
   output  data  set  or  data  file  through  the description file or by
|  specifying clauses to the DUMP command.  The output data set cannot be
|  a multifile data set.

   CREATING THE DATA BASE                                       Page 3-52
   Revision 4


   The format of the DUMP command is:

          { [ SET ] data-set-descriptor                               }
     DUMP { [ UNBUNDLED SET data-set-descriptor ] [ DATA file-desc1 ] }
          { DATA file-desc1                                           }

          [ DESC file-descriptor2 ]

          [ BUFFER n ] [ SORTED [ BY ] sort-clause ]                         ____

   Where:

   UNBUNDLED                   Creates  an  unbundled  data  set.    When
                               UNBUNDLED is used, it immediately precedes
                               the SET option.  If UNBUNDLED  appears  in
                               the  command but the DATA clause does not,
                               a default data file is written.  The  name
                               of  this  data  file  comes  from the DESC
                               file, when one  is  specified,  or  it  is
                               named after the SET file name.

   SET data-set-descriptor     Specifies the name of the output data  set
                               written  by  the DUMP command.  If this is
                               an unbundled DUMP, this data file contains
                               only   1022   information.   If  the  file
                               extension is not  specified,  the  default
                               extension is DMS.

   DATA file-descriptor1       In unbundled dumps, this is  the  name  of
                               the  data  file  which contains the output
                               data records.   Only  this  data  file  is
                               written  when  the  SET clause is omitted.
                               If the file extension  is  not  specified,
                               the default extension is DMI.

   DESC file-descriptor2       Is the name of the data  description  file
                               that  describes  data set and/or data file
                               written by  the  DUMP  command.   If  this
                               clause  is  omitted,  the structure of the
                               current data set is used for the new  data
                               set.    If   the  file  extension  is  not
                               specified, the default extension is DMD.

   BUFFER n                    Assigns  the  number  of   internal   disk
                               input/output buffers to be used during the
                               dump.  When n is large, (for example,  12)
                               efficiency improves for large dumps.  This
                               clause is only useful  for  dumping  large
                               data sets (3000 blocks or 750 pages).  The
                               default value for this clause is 2.

   CREATING THE DATA BASE                                       Page 3-53
   Revision 4


   SORTED BY sort-clause       A full SORT  command  physically  reorders
                               the  records  while they are dumped to the
                               new data set.  The sort-clause may include
                               the  expressions  and sequence-descriptors
                               of the 1022 SORT command.  (See Chapter 4,
                               "SORT Command".)



   3.7.1  Extracting Records

   Records are extracted from a master data set  by  opening  the  master
   data  set,  creating  a  selection  group  using  the FIND, SEARCH, or
   comparable commands, and dumping the selection group  to  a  new  data
   set.  In the simplest form of the command, the output data set has the
   same structure and attribute names as the master data set.  The output
   data  set  can  be  placed  into  a multiple data set file by giving a
   complete data set descriptor.

   The following commands perform a DUMP:

        * OPEN COMPNY        _
        * FIND DIVISION EQ 6        _
        322 RECS FOUND        ___ ____ _____
        * DUMP SET SMDIV        _

   In the above example, the output data  set,  SMDIV.DMS,  receives  the
   DIVISION  SIX  records.   This new data set may be opened immediately.
   It has the same structure as the master  data  set,  COMPNY.   No  key
   tables  are  built  during  the  DUMP.   The user may build needed key
   tables using the KEY command.

   There are two ways to change the order of the records  in  the  output
   data  set.   The  fastest  way  is  usually to specify the "SORTED BY"
   clause within the DUMP command.  The  other  method  is  to  give  two
   commands:  the SORT command followed by the DUMP command.  This sorted
   order becomes the physical order of the output data set.  This  allows
   reports and print requests to be done in the future without additional
   sorting.

   Users can reclaim the space occupied by deleted records  by  selecting
   all  the records in the master data set and dumping them to a new data
   set of the same name.  The DUMP command copies only the records in the
   current  selection  group and not the deleted records, so the new data
   set is smaller.  Users must then rebuild the keys.


   The following examples show how the command "DUMP  SET  MEMO"  handles
   the file MEMO.DMS under a variety of circumstances.

        A. There is no file MEMO.DMS:

           MEMO.DMS is written.
   CREATING THE DATA BASE                                       Page 3-54
   Revision 4


        B. There is a file MEMO.DMS, with MEMO as the only data set:

           The file MEMO.DMS is deleted and a new MEMO.DMS is written.

        C. The file MEMO.DMS contains a data set other than MEMO:

           The new data set, MEMO, is appended to the file MEMO.DMS.  Any
           old copy of MEMO is deleted;  this space is not reused.

           If an old data set MEMO is deleted  in  a  multiple  data  set
           file,  the resulting file may be compacted by dumping the data
           sets to a new file.  There will be no wasted space in the  new
           file.   The  old  file,  MEMO.DMS, can be deleted, and the new
           file renamed to take its place.



   3.7.2  Changing The Type Of Data Set

   DUMP can produce an unbundled data  set  from  a  bundled  one,  or  a
   bundled data set from an unbundled one;  or it can write out data to a
   simple data file.

   The keyword "UNBUNDLED" directs 1022 to write an unbundled  data  set.
   (See  the  "Bundled  vs.   Unbundled"  section  of  this chapter for a
   complete description.)

   The SET clause  specifies  the  output  DMS  file.   The  DATA  clause
   specifies  the DMI file.  If no DATA clause is specified, the DMI file
   name comes from the DESC clause.

|  You can dump to a file with a different format from that of the master
|  data  set  by  using  the  DESC  clause  that  specifies  a DMD with a
|  different LOADING SECTION.  In the  absence  of  a  DESC  clause,  the
|  output  data  set  or  data  file  takes  its format (ASCII or SIXBIT,
|  aligned or nonaligned, blocked or unblocked, etc.)  from  the  LOADING
|  SECTION  parameters  used  to  build  the  master  data  set.  The one
|  exception to  this  rule  concerns  the  ALLOCATE  clause  on  TOPS-10
|  systems.  Here, if an ALLOCATE clause was specified in the creation of
|  the master data set, this clause is  ignored  when  the  DUMP  command
|  executes.  In this case, the allocation is determined by the number of
|  records selected for dumping.
|  
|  The field widths for each item become the output field widths  in  the
|  data  file.   Conversions  from  numeric  to  display numeric are done
   automatically to fill the output fields.  If numeric data is too large
   to   be   correctly   displayed  in  the  associated  field  width,  a
   conversion-error message prints on the terminal.
   CREATING THE DATA BASE                                       Page 3-55
   Revision 4


   If the DATA clause is used alone, then only the data file  portion  of
   the  unbundled data set is written.  This is usually done when data is
   to be read by another program system without further action by  System
   1022.

   Records can not be dumped to an ISAM data file.



   3.7.3  Restructuring A Data Set

   A new data description file may be specified in  the  DESC  clause  to
   restructure  the  output  data  set  or  data file.  Attributes in the
   source data set are directed to the fields of the new  description  by
   matching   attribute  names  (not  abbreviations).   (See  Chapter  5,
   "TRANSACT Command").  The output data set resulting from a  DUMP  DESC
   clause  is  identical to a data set made with the LOAD command, except
   that keys have not been built.

   Users can restructure their data sets  to  make  room  for  additional
   attributes.   The  old data set is dumped using a new description that
   contains extra attributes to be filled in later.  These new attributes
   are  given  blank  or zero values in the DUMP.  After building the new
   data set, the user builds the necessary keys and may fill in  the  new
   fields with the desired data with the CHANGE or TRANSACT command.

   If a new data description file contains an attribute of  type  INTEGER
   OF  IDENTIFICATION  (IID) with RESET, the new IID is reset by the DUMP
   operation.  The IID is not reset unless called for in a new DMD  file,
   regardless of whether RESET appears in the description file of the old
   data set.



   3.7.4  Examples Of The DUMP Command


        1.  DUMP SET NEWSET

            This produces a new data set called NEWSET.DMS containing the
            currently  selected  records  in  the  current data set.  The
            records are written out with  the  same  description  as  the
            master data set and in the order that they appear there.


        2.  DUMP SET NEWSET DESC NEWDES

            The  data  set  NEWSET.DMS  is  written  from  all  currently
            selected  records,  according  to  the  default  order of the
            master data set.  The description file  NEWDES.DMD  describes
            the  structure  of  NEWSET.DMS.   The  effect  is  as  if the
            extracted information in the  master  data  set  were  loaded
            without   keys   into  the  data  set  NEWSET.DMS  using  the
   CREATING THE DATA BASE                                       Page 3-56
   Revision 4


            description NEWDES.DMD.

        3.  DUMP SET INFOR1 IN NEWSET DESC NEWDES

            The data set being created is named INFOR1 and resides in the
            physical  file  NEWSET.DMS, along with any other data sets in
            that physical file.  If NEWSET.DMS does not already exist, it
            is  created  to hold INFOR1.  This command is similar to that
            in example 2 except for the destination of the new data set.

        4.  DUMP SET NEWSET DESC NEWDES SORTED BY LNAME FNAME

            This is similar to example 2, except that a new physical sort
            order  is  imposed  on  the records of NEWSET.DMS.  We assume
            that LNAME and FNAME are attributes of the master  data  set.
            The  data  set  NEWSET.DMS  is  ordered by major key LNAME in
            ascending order, and by next minor  key  FNAME  in  ascending
            order.  (These need not be KEYED fields to be sort keys.  See
            the SORT command for more information.) These fields need not
            appear in the output description of NEWSET;  they control the
            order for selecting the records to be written out to NEWSET.

        5.  DUMP UNBUNDLED SET NEWSET DESC NEWDES

            This creates an unbundled data set, with the 1022 information
            residing in a file separate from the data records of the data
            set.  System 1022 information is written to file  NEWSET.DMS.
            A  data  file  is  written  in  a  form described by the data
            description file NEWDES.DMD.  Since  the  data  file  is  not
            named,  the  name  comes  from  the  DATA  clause (if any) in
            NEWDES.DMD.  If it is not specified there, the data file name
            defaults to NEWDES.DMI, from the name of the data description
            file.

        6.  DUMP UNBUNDLED SET NEWSET DATA NEWDAT.ABC

            This writes an unbundled data set.  There is no DESC  clause,
            so  the  structure  is the same as the current data set.  The
            new data set is called  NEWSET.DMS,  and  the  data  file  is
            called NEWDAT.ABC.

        7.  DUMP DATA DATFIL

            Since no SET or UNBUNDLED clause appears, a data set  is  not
            created;   no  DMS file results.  A pure data file is written
            according to the description of the current data set.  A data
            description  file  could  be  specified to obtain a data file
            with a different format.  Use this form of the  DUMP  command
            to  create  data  files  for  transfer  to  other programs or
            systems.

   CREATING THE DATA BASE                                       Page 3-57
   Revision 4


   3.7.5  Default Numeric-to-Display Conversions

   The following describes how 1022 converts numeric data to display form
   when  dumping  data to an unbundled data set, or whenever a numeric to
   display conversion is required.




   3.7.5.1  Binary Integer To Display Integer

   The output field is cleared to blanks.  If the number does not fit  in
   the  output field, the field is left as blank.  If the number fits, it
   is right-justified with preceding blanks, and preceding minus sign (-)
   if negative.  Positive numbers have no preceding sign.




   3.7.5.2  Binary Real To Display Real

   The numeric value is placed into the  output  field  as  an  F  format
   number:   leading  numeric  sign  if  negative,  integer part, decimal
   point, and fraction.  Leading blanks fill in if the  field  is  larger
   than required for printing the number.

   No more than 27 digits are produced  (provided  space  is  available).
   The full 27 digits are used only for large numbers, to accommodate the
   integer part, or for small numbers, to accommodate the leading  zeroes
   of  the  fraction.   The  fraction  is  generated  only  to  display 9
   significant digits, not counting leading insignificant zeroes  in  the
   fraction.

   Should the value be too large to fit in the field, or be so small that
   the  fraction  would  start  with  5 or more insignificant digits, and
   would contain fewer than 9 significant digits, then an E format number
   is produced.  The E format is:  a leading numeric sign if the value is
   negative, decimal point, up  to  9  significant  digits  depending  on
   available  space, the letter E, a + or - sign preceding the power, and
   two digits for the power.  Again, leading blanks preceding this output
   are  filled  in,  should there be more than enough room to display the
   number.

   Should neither attempt at conversion result in at least 1  significant
   digit in the output number, then the field is filled with blanks.

   Where fewer than 9 significant digits appear, the  number  is  rounded
   before being displayed.

   CREATING THE DATA BASE                                       Page 3-58
   Revision 4


   3.7.5.3  Binary Date To Display Date

   The date value is written to  the  output  field  as  6  or  8  digits
   right-justified in the field, with preceding blanks.  The first 2 or 4
   digits are the year, then two digits for the month, and  two  for  the
   day.

   If space permits, all dates have a 4-digit  year.   If  there  is  not
   enough room for an 8-digit date, a 6-digit date is used.  Dates within
   the range of years 1900 to 1999 have a 2-digit year, dropping the  19.
   Illegal dates are output as blanks.



   3.8  FILE CONVERSION

   The CREATE command, in combination with the DUMP command, allows  1022
   to be used as a general purpose file conversion program.  For example,
   to convert a SIXBIT data file to an ASCII data file:

        A. Make a description file DS for the SIXBIT data file S.

        B. Make a description file DA for the new ASCII file A.

        C. Give the 1022 commands:

              * CREATE SET S DESC DS DATA S
              * OPEN S.  FIND ALL
              * DUMP DATA A DESC DA




   3.9  MULTIPLE DATA SETS PER FILE

   The user has the option of placing many  data  sets  in  one  file  by
   specifying  both a data set name and a file name in a SET clause.  For
   example, SET OUTPUT IN PARTS.DMS builds the data  set  OUTPUT  in  the
   file  PARTS.DMS.   The  file PARTS.DMS can contain multiple data sets.
   The SET clause can be used in the description file  or  in  the  LOAD,
   CREATE, or DUMP command.

   If another data set already exists in the file when a new data set  is
   written into the file, the new data set is appended to the file.  If a
   data set of the same name already exists in the file, the old copy  is
   made obsolete, but the space is not reclaimed.

   An OPEN command with a file name opens all the data sets in the  file.
   OPEN  PARTS  opens all the data sets in PARTS.DMS.  To open a specific
   data set in the file, specify it in the OPEN  command.   For  example,
   OPEN  OUTPUT  IN  PARTS  opens  only  OUTPUT and no other data sets in
   PARTS.DMS.
   CREATING THE DATA BASE                                       Page 3-59
   Revision 4


   Multiple data sets per file have both  disadvantages  and  advantages.
   In  general,  put  only  one  data  set in each file for the following
   reasons:

        The files can be distributed among several  file  structures
        (separate  disk  units)  for better access time in a complex
        data base of many related data sets.

        Should the file become damaged due to hardware  or  software
        problems,  only one data set file has to be regenerated.  It
        also may be possible to continue running with the other data
        sets.

        Should  a  data  set  become  obsolete,  the  space  can  be
        reclaimed  by  deleting the file.  All active data sets need
        to be moved with DUMP to a new file to reclaim  space  in  a
        multiple data set file.

        During an AUDIT BACKUP, blocks added since the backup  point
        are  deallocated.  In a multi-data set file these blocks are
        not deallocated.  (See Chapter 10, THE AUDIT TRAIL.)

   However, put several data sets in one file for the following reasons:

        Many data sets need to be  open  at  once.   Fewer  channels
        (TOPS-10)  or  JFNs (TOPS-20) are required.  This may result
        in lower monitor overhead.

        The user has several small data sets for  table  lookups  of
        encoded  values  in  other  data sets, which are always open
        together.  It may be easier to maintain  the  several  small
        data  sets  in  one  file  rather than to have several small
        files in the user's directory.
   CREATING THE DATA BASE                                       Page 3-60
   Revision 4















                                 CHAPTER 4

                          EXAMINING THE DATA BASE



   This chapter describes the  commands  used  to  retrieve  and  display
   information  from  the  data  base.   The  commands  used  for  report
   generation are described in Chapter 9.  First become familiar with the
   commands and procedures described below before reading that chapter.



   4.1  CHOOSING THE DATA SET

   The user may work with many data set files at a time.  More  than  one
   data  set  may be in a data set file.  The following commands open the
   data sets, select them, and close them when required.



   4.1.1  OPEN Command

   The OPEN command opens one or more data sets for processing by  System
   1022.   A data set must be opened before its contents can be retrieved
   or changed.  The OPEN command is not ordinarily issued inside a PL1022
   or report program.  The form of the OPEN command is:

|       OPEN [NOCLOSE]  item-1 [ item-2...]
|  
|  where an item is:
|  
|       [ data-set-descriptor  IN ] file-name [PASSWORD pswd]
|  
|                     {READONLY}                {  ENQ  }
|          [ [ACCESS] {        } ] [AS alias] [ {       } ] [ $MISSING ]
                      {   RO   }                { NOENQ }

   Commas can not be used as separators;  only spaces are allowed.

   If the NOCLOSE keyword is included, then any data  sets  already  open
   remain  open;   without NOCLOSE, any data sets already open are closed
   first, leaving only the named data sets open.

   EXAMINING THE DATA BASE                                       Page 4-2
   Revision 4


   If a file name without extension is specified, the  default  extension
   DMS is assumed and all data sets within that file are opened.  Thus if
   SALES contains data sets A, B, and C, the command:

        OPEN SALES

   is equivalent to

        OPEN A IN SALES.DMS B IN SALES.DMS C IN SALES.DMS

   The PASSWORD option is used when a password has been  established  for
   any  specified  or  implied  data  set.  The ADMIT command establishes
   passwords and restrictions (see Chapter 7, ADMIT  Command).   PASSWORD
   may be abbreviated to PASS.  For example:

        OPEN SALES PASS ABC

   If each of the data sets in SALES has a different  password  then  the
   user must specify each data set and its password.  For example:

        OPEN A IN SALES PASS ABC B IN SALES PASS XYZ C IN SALES PASS MNO

   If the password is omitted but required, 1022  prompts  for  it.   The
   password  is  accepted in noecho mode for full duplex terminals and is
   overprinted for local copy terminals.

   The ACCESS READONLY option prevents the user from  updating  the  data
   set.   Only  data  retrieval  and  display  are permitted.  The entire
   expression may be abbreviated as follows:

        OPEN PARTS.INV ACC RO

|  The PASSWORD, ACCESS, AS, ENQ or NOENQ,  and  $MISSING  clauses  apply
   only  to  the  data-set-descriptor  that  they immediately follow.  If
   several data sets are to be opened  as  readonly,  the  ACC RO  clause
   follows each data-set-descriptor.  For example:

        OPEN A IN SALES.JAN ACC RO B IN SALES.FEB ACC RO

   If a file has multiple data sets and all are to be opened as  readonly
   then the ACCESS clause can follow the file name.  If SALES.DMS has the
   same data sets as above then the command:

        OPEN SALES ACC RO

   opens A, B and C with readonly access.
   EXAMINING THE DATA BASE                                       Page 4-3
   Revision 4


   Examples:

        OPEN STOCK.DMS
        OPEN BOSTON.INV NEWYRK.INV CHICAG.INV
        OPEN PERSNL PASSWORD DYGP TAXTBL[50,51]
        OPEN NOCLOSE DSKC:PARTS PASS MYOPY ACC RO
        OPEN NOCLOSE CODES(2120,14) ORDER.FIL

        OPEN ACCPAY PASS ABC ACCREC PASS DEF

        OPEN ACCPAY ACCREC
        Password for ACCPAY in <JOHN>ACCPAY.DMS        ________ ___ ______ __ ________________
        (password typed by user here does not print)

        Password for ACCREC in <JOHN>ACCREC.DMS        ________ ___ ______ __ ________________
        (password typed by user here does not print)

   The "AS <alias>" clause allows you to assign an additional name to the
   data set when you open it.  The additional name is up to 25 characters
   long.  It may not be the same as the internal name or alias of an open
   data set, including any named in the OPEN command.

   For example, if STOCK is the only data  set  in  the  file  STOCK.DMS,
   either of the following commands will open the data set with the alias
   PARTS as long as PARTS is not the internal name or alias of any  other
   open data set:

        OPEN STOCK IN STOCK.DMS AS PARTS

                  or

        OPEN STOCK AS PARTS

   Similarly, if a copy of  the  data  set  STOCK  resides  in  the  file
   PARTS.DMS  (and  it  is the only data set in that file), either of the
   following commands will open the data set with the alias PARTS as long
   as PARTS is not the internal name or alias of any other open data set:

        OPEN STOCK IN PARTS.DMS AS PARTS

                  or

        OPEN PARTS AS PARTS

   This last command is allowed because PARTS is not the name of an  open
   data set or the alias of a previously opened data set.  The command

        OPEN STOCK AS STOCK

                  or

        OPEN PARTS AS STOCK
   EXAMINING THE DATA BASE                                       Page 4-4
   Revision 4


   would both result in the error message

        ?(OP14) Dataset alias already in use.

   This same error message would appear if the data set STOCK  were  open
   and  the  user  attempted  to  open another data set and assign it the
   alias STOCK without closing STOCK.  Similarly, if the  user  tries  to
   assign  an  alias when opening a file that contains more than one data
   set, the following error message is generated:

        ?(OP16) Alias not allowed for multi-data set OPEN

   because all of the open data sets would have the same alias, which  is
   not allowed in 1022.

   The one apparent exception to this rule occurs when the user  opens  a
   data set and assigns it an alias identical with the internal name of a
   closed data set and then opens the second data set without closing the
   first.  For example:

        OPEN STOCK AS BOLTS

        OPEN BOLTS

   This is a situation to be generally  avoided  because  any  subsequent
   command  that  references  "BOLTS" will be ambiguous and will generate
   the following error message:

        ?(CS82) Multiple match to data set name.

   The alias is established only for the user opening the  data  set  and
   only  as  long  as  the  data set is open.  It is especially useful in
   writing readable application programs.  With an  alias  assigned,  the
   program can reference a data set by a name that corresponds to its use
   in the application.  Also, the use of an alias clarifies references to
   the  correct  data set when you open the same data set more than once.
   JOIN, DBSET, MAP commands, and attribute qualification  can  reference
   different  views  of  the  same data set by name as well as by number.
   The following example suggests a typical use:

             OPEN NAMES AS PARENT NAMES AS CHILD. 
             DBSET CHILD.
             FIND SURNAME JONES.
             GETREC.
             MAP TO PARENT VIA PARENT_ID.
             PRINT PARENT.FN CHILD.FN CHILD.SURNAME.

   An alias can be used in any 1022 command that accepts a data set name.

   The alias of the current data set can also be  displayed  by  printing
   the  system  variable  SYSDSALIAS,  and  can be assigned or changed by
   assigning a name to SYSDSALIAS.
   EXAMINING THE DATA BASE                                       Page 4-5
   Revision 4


   The ENQ or NOENQ clause specifies that the data set is a queued-access
   (ENQ)  or  retry-access (NOENQ) data set.  Normally the access mode is
   specified when the data set is built.  Use the ENQ or NOENQ clause  to
|  override  the  data  set's normal access mode.  You cannot open a data
|  set NOENQ if it is a RECLOCK data set (see the "Multiple Access  of  a
|  Data Set" section of Chapter 5).

   For example, the following command opens a NOENQ data set  as  an  ENQ
   data set:

        OPEN STOCK ENQ

|  When you give an OPEN command for a multifile data  set,  System  1022
|  automatically checks to make sure that all of the data set's auxiliary
|  files are present.  When the system variable SYSAUXCHK  is  set  to  0
|  (the  default),  1022  gives an error message if any of the data set's
|  auxiliary files are damaged or skewed.  When SYSAUXCHK is set to 1, no
|  such  checking  is performed and no such error messages are displayed.
|  SYSAUXCHK is both user settable and default settable.
|  
|  If an auxiliary file is lost, whether  through  improvident  deletion,
|  renaming,  relocation, or disk damage, an attempt to open the data set
|  to which it belongs will produce a system error message:
|  
|       1022 GTJFN error (600104) File not found, File:  <filespec>
|  
|                                     or
|  
|       1022 GTJFN error (600077) No such file type, File:  <filespec>
|  
|  where <filespec> is the file specification of the first auxiliary file
|  that  1022 discovers missing from the data set.  This is followed by a
|  1022 error message:
|  
|       ? (OP15) Auxiliary file not found or has invalid dataset ID.
|  
|  To open the data set when one or more of its auxiliary files has  been
|  lost, issue the command:
|  
|       OPEN <data set name> $MISSING
|  
|  The system error message is then repeated, followed by the message:
|  
|       %%MISSING AUXFILE, CONTINUING...
|  
|  If more than one auxiliary  file  has  been  lost,  the  system  error
|  message  is  repeated with the name of the next missing file, followed
|  by  another  %%MISSING  AUXFILE,  CONTINUING...  These  messages   are
|  repeated until all the missing auxiliary files have been listed.
|  
|  System 1022 distinguishes among three types of auxiliary file loss:
   EXAMINING THE DATA BASE                                       Page 4-6
   Revision 4


|       1.  Loss of an empty file (an auxiliary file with no  records  or
|           key tables in it) or a file containing only key tables
|  
|       2.  Loss of a file holding the last records in the data set
|  
|       3.  Loss of a file holding records other than the  last  ones  in
|           the data set.
|  
|  If an empty file was lost, a replacement will be created for  it  when
|  the  user  issues  an update command (such as UPDATE ON, ADD, or KEY).
|  If key tables were lost, 1022 displays a warning message informing you
|  of  that  fact  when  you give the first command involving key tables.
|  You should then rekey with a KEY NOREUSE command.   System  1022  will
|  create  a  new  auxiliary file to hold the key tables.  Note that when
|  key tables have been lost, rekeying must be  accomplished  before  any
|  update commands can be safely issued.
|  
|  If an auxiliary file holding records becomes lost, a  warning  message
|  is  displayed  after  the system messages.  It lists the SYSIDs of the
|  missing records and gives the file specification  of  the  lost  file.
|  For example, if the auxiliary file AUX1.DMM of the data set MYFILE.DMS
|  holds records 1000-2000 and this file is lost, the command
|  
|       OPEN MYFILE $MISSING
|  
|  will produce the following messages:
|  
|       1022 GTJFN error (600104) File not found:  File DSK:AUX1.DMM
|       %%MISSING AUXFILE, CONTINUING ...
|       %%WARNING:  records 1000 through 2000  in  AUXFILE  AUX1.DMM  are
|       missing!
|  
|  
|  If the lost file holds the last records in the  data  set,  1022  will
|  only  open  the  data  set  READONLY  and  will  issue  the  following
|  additional messages:
|  
|       %%New records would be liable to be added to this AUXFILE
|       %%Data set restricted to READONLY access
|  
|  This restriction keeps users from trying to add records to the end  of
|  the  data  set after that part of the data set has been lost.  When an
|  auxiliary file holding the last records in the data set is  lost,  the
|  best  the user can do is to FIND all of the records except those whose
|  SYSIDs are listed as missing, DUMP the found  records  to  a  new  DMI
|  file,  and reload.  If the lost file does not contain the last records
|  in the data set, the user has two options:
|  
|       1.  FIND the missing records, DELETE them, and then, if possible,
|           append  a  back-up copy of the records in the lost file.  You
|           will probably then wish to DUMP all of the records to  a  new
|           file, since you cannot rekey until you do so.
   EXAMINING THE DATA BASE                                       Page 4-7
   Revision 4


|       2.  FIND all but the lost records, DUMP the found  records  to  a
|           new file, and reload.
|  

   See Chapter 7, INFORM BASE to display at any time the  open  data  set
   names.




   4.1.2  DBSET Command

   When more than one data set is open, the DBSET command establishes the
   current  data  set.   Most System 1022 commands operate on the current
   data set.

   The DBSET command has the form:

                { <data-set-descriptor> }
       DBSET    { <alias>               }
                { <n>                   }

   The data-set-descriptor selects a data set  by  giving  its  name  and
   whatever  additional  file name and device information is necessary to
   distinguish it from the other open data sets.  The  alias  is  a  name
   assigned to the data set when it is opened.

   The parameter <n> identifies the  current  data  set  by  its  number.
   System  1022  assigns  the first data set specified in an OPEN command
   the number 1 and increments the number for each  additional  data  set
   that  appears  in  the same OPEN command.  Later OPEN NOCLOSE commands
   reuse numbers left available by intervening CLOSE commands.  Using the
   data-set-descriptor  or  alias  in  the DBSET command is often clearer
   than using the data set number.

   Specifying the data set alias or number distinguishes one copy of  the
   same data set opened on more than one data set channel.

   All later commands following a DBSET command operate on  the  selected
   data  set  until  another DBSET, MAP, or OPEN.  An OPEN command leaves
   the user set to the first data set named;  an OPEN NOCLOSE leaves  the
   user set to the last data set (usually the only data set) named in the
   command.

   EXAMINING THE DATA BASE                                       Page 4-8
   Revision 4


   For example, a user has  given  the  following  commands.   (SALES.DMS
   contains the data sets A, B, and C.)

        OPEN BOSTON.INV AS BOS NEWYRK.INV AS NY

             BOSTON.INV is the current data set.

        OPEN NOCLOSE CHICAG.INV CHICAG.ORD SALES

             C in SALES.DMS becomes the current data set.

   Then,

        DBSET 1 or DBSET BOSTON or DBSET BOS
        selects BOSTON.INV;

        DBSET 2 or DBSET NEWYRK or DBSET NY
        selects NEWYRK.INV;

        DBSET 3 or DBSET CHICAG.INV
        selects CHICAG.INV. (DBSET CHICAG is not enough);

        DBSET 4 or DBSET CHICAG.ORD
        selects CHICAG.ORD.

        DBSET 5 or DBSET A
        selects A in SALES.DMS

   The  INFORM SET  command  (see  Chapter  7,   Displaying   Data   base
   Characteristics)  prints  the  name  and  file  specification  for the
   current data set.




   4.1.3  CLOSE  Command

   This command closes the current data set.  Its format is:

        CLOSE        __

   with no options.  A closed data set is unavailable  for  retrieval  or
   modification  until  it  is  opened  again.  Also, its data set number
   becomes available for re-assignment to a different data set on a later
   OPEN NOCLOSE command.  The lowest numbered data set still open becomes
   the current data set after a CLOSE command.
   EXAMINING THE DATA BASE                                       Page 4-9
   Revision 4


   4.2  SELECTING RECORDS FOR EXAMINATION

   The commands in this section select records  from  the  data  set  for
   display  or  processing  by  other commands.  The records selected are
   called the selection group for the data set.  When multiple data  sets              _________ _____
   are  open, 1022 remembers an independent selection group for each data
   set.  Thus, the user may  switch  freely  between  data  sets  without
   losing the selection groups.

   System 1022 provides the following  commands  for  creating  selection
   groups.   The following commands do not change or update data items or
   key tables.


        FIND      Builds a selection group from all  active  records        _
                  in  the data set which satisfy conditions on keyed
                  attributes.  It  uses  key  tables  for  immediate
                  retrieval.

        DFIND     Is similar to FIND, but builds the selection group        _____
                  from all inactive (deleted) records.

        SEARCH    Builds a  selection  group  from  records  in  the        ___
                  previous  selection group which satisfy conditions
                  on any attributes.  It searches the  actual  data,
                  and is usually slower than FIND.

        SELECT    May be used in place of SEARCH  whenever  a  later        ___
                  command  must  read  through  the selected records
                  sequentially.  This saves reading through twice.

        MAP       Locates records  in  a  second  data  set  sharing        ___
                  attribute  values  with  records  of  the  current
                  selection group.

        SAVE      Creates a disk file containing  an  index  to  the        ___
                  records  in the current selection group.  The file
                  can be used later in selection conditions.

        GETREC    Switches into local  mode  for  processing  single        ____
                  records  in  the  selection  group.  The selection
                  group remains unchanged.

        DROP      Removes an individual record, selected by  GETREC,        ____
                  from the selection group.

        STARTREC  Returns to global mode following GETREC  activity.        ________
                  The  selection group is restored as before, except
                  for any records that may have been  removed  by  a
                  DROP command or by SELECT criteria.
   EXAMINING THE DATA BASE                                      Page 4-10
   Revision 4


   4.2.1  FIND Command

   The FIND command quickly retrieves information from the data set.  The
   key  tables,  built  and  maintained for keyed-access attributes, make
   fast retrieval possible.  The FIND  command  operates  only  on  keyed
   attributes  and  on  the system-defined attribute SYSID.  In contrast,
   the SEARCH command retrieves information on unkeyed attributes.

   The form of the FIND command is:

        FIND <selection-condition>

                  [<logical-operator> <selection-condition>]...

   Selection conditions have the form:

        <attribute> <relational-operator> <value>

   Logical operators are optional.  They  link  selection  conditions  to
   form  more  complex  selection  criteria.   (See  the section, Logical
   Operators, in this chapter for a complete discussion.)

   The following examples illustrate the FIND command.

        FIND AGE EQUALS 30
        FIND SALARY LT 30000 AND AGE GT 50
        FIND WEIGHT GT 200 OR HEIGHT GT 6.0

   In  these  examples,  the  selection  conditions  are  given   in   an
   English-like  form.   Advanced users may prefer to use the abbreviated
   form of the selection  conditions  discussed  in  this  chapter  under
   Collapsing The FIND Command.

   System 1022 normally responds to the FIND command (and also to  SEARCH
   and  MAP)  with  one  of  three  messages,  depending on the number of
   records found which satisfy the command:

        "n RECS FOUND"
        "FOUND"
        "NOT FOUND"

   The user may alter this response with the FMSG and FERR options to the
   SET command.  (See Chapter 7, SET Command.)



   4.2.1.1  Selection Conditions

   The basic selection condition used to create a selection group has the
   following form:

                   Attribute    Relational Operator   Value

   For example:       AGE              EQUALS           30
   EXAMINING THE DATA BASE                                      Page 4-11
   Revision 4


   Where:

   Attribute is the name or abbreviation of an attribute.  When used with   _________
   the FIND command, the attribute must be keyed.

   Relational operator is an  operator  which  defines  the  relationship   __________ ________
   between the attribute and the value.

   Value is the expression to which the attribute is compared.   _____




   4.2.1.1.1  Relational Operators


   The following table defines the relational  operators  used  in  basic
   selection conditions.


                      TABLE 4-1. RELATIONAL OPERATORS


      OPERATOR         SHORTER FORMS           MEANING      ________         _______ _____           _______


      EQUALS           EQUAL, EQ           Attribute equal to value.                                                     _____

|     NEQ              NE                  Attribute not equal to value.                                                     ___ _____

      GT                                   Attribute greater than value.                                                     _______ ____

      GE                                   Attribute greater than or                                                     _______ ____ __
                                           equal to value.                                           _____ __

      LT                                   Attribute less than value.                                                     ____ ____

      LE                                   Attribute less than or equal                                                     ____ ____ __ _____
                                           to value.                                           __

      CONTAINS         CONT, CT            Attribute contains text string                                                     ________
                                           in value (text attributes
                                           only).

|     NCONT            NCT                 Attribute does not contain                                                          ___ _______
|                                          text string in value
|                                          (text attributes only).

      BEGINS           BEG                 Attribute begins with text                                                     ______
                                           string in value (text
                                           attributes only).

|     NBEGINS          NBEG                Attribute does not begin with                                                          ___ _____
   EXAMINING THE DATA BASE                                      Page 4-12
   Revision 4


|                                          text string in value
|                                          (text attributes only).
|  
|     BETWEEN          BET                 Attribute's values are within
|                                          specified range. Takes two 
|                                          arguments.
                      
|  
|     NBETWEEN         NBET                Attribute's values are
|                                          not within specified range.
|                                          Takes two arguments.
|  
|     MATCHES          MAT                 Portion of attribute's value
|                                          matches wildcard argument
|                                          (text attributes only).
|  
|     NMATCHES         NMAT                Portion of attribute's value
|                                          does not match wildcard                                                ___
|                                          argument (text attributes
|                                          only).

   The system variable SYSBETWEEN controls the operation of  the  BETWEEN
   and  NBETWEEN  relational  operators  in  FIND, SEARCH, SELECT, and IF
   commands.  When SYSBETWEEN is 0, the first argument for  the  operator
   should  be  less  than  the  second  argument.  "BETWEEN arg1 arg2" is
   equivalent to "GE arg1 AND LE arg2".  "FIND  attribute  BETWEEN  5  3"
   never  finds any records.  When SYSBETWEEN is 1, order of arguments is
   not significant.  "BETWEEN arg1 arg2" is equivalent  to  "GE  MIN(arg1
   arg2) AND LE MAX(arg1,arg2)".  When SYSBETWEEN is 1, "BETWEEN 5 3" has
   the same result as "BETWEEN 3 5".

|  There are two ways to express the negation of the relationship between
|  attribute  and value defined by any of the relational operators listed
|  in the preceding table.  The preferred way is to  use  the  relational
|  operator whose meaning is the opposite of the one in question.
|  
|  For example, the negation of the command
|  
|       FIND LAST_NAME BEGINS "A"
|  
|  may be expressed as
|  
|       FIND LAST_NAME NBEGINS "A"
|  
|  and the negation of the command
|  
|       FIND SYSID GT 10
|  
|  may be expressed as
|  
|       FIND SYSID LE 10
|  
|  since any SYSID that is not greater than 10 must be less than or equal
   EXAMINING THE DATA BASE                                      Page 4-13
   Revision 4


|  to 10.
|  
|  A second way of expressing negation is by using  the  keyword  NOT  to
|  qualify the relational operator.  For example,
|  
|       FIND SYSID NOT GT 10
|  
|  This returns all the SYSIDs with a value not greater than 10, that is,
|  with a value less than or equal to 10.
|  
|       FIND LAST_NAME NOT NBEGINS "A"
|  
|  returns all last names beginning with "A".
|  
|  We recommend against the use of NOT in  complex  selection  conditions
|  because  the  way  in  which 1022 evaluates such expressions is not as
|  transparent as it is with expressions containing NEQ, NCONT, NMATCHES,
|  and  NBEGINS.   (See  the "Logical Operators" and "Collapsing the FIND
|  Command" sections of this chapter.)



   4.2.1.1.2  Values

   Values can be numeric or text constants,  date  items,  system-defined
   quantities,  the values of user-defined variables, or expressions made
   of these.

   System 1022 stores text values in  key  tables  exactly  as  they  are
   input.   Most comparisons in a FIND command look for an exact match of
   upper and lower case between your text value and  the  values  in  the
   tables.   This  makes  the  FIND command run faster, since it does not
   have to check for all possible case combinations.
|  
|  If you set the system variable SYSCASE to  1,  case  distinctions  are
|  ignored  in  matching  the  text  values  that  follow  the relational
|  operators BEGINS, NBEGINS, CONTAINS,  NCONT,  MATCHES,  and  NMATCHES.
   These  relational  operators  search  the keys character by character.
   Setting SYSCASE to 1 does not change the operating speed of  CONTAINS,
   but it does slow down the execution of BEGINS.

   Text values are compared alphabetically.  For example, "AAAAA" is less
   than  "AAAAB",  and greater than "AAAA".  Lower case characters have a
   greater value in comparisons  than  upper  case  characters:   "a"  is
   greater than all upper case letters.

   If text and date values do not contain spaces, the user may type  them
   without  enclosing  them  in quotation marks.  This saves typing time.
   If a text value or value name is the same as an  attribute  name,  the
   user  must  put  quotation  marks around it to distinguish it from the
   attribute.

   EXAMINING THE DATA BASE                                      Page 4-14
   Revision 4


   The following restrictions apply to text values:

         1. Text values cannot be compared with numeric  attributes,
            nor can numeric values be compared with text attributes.
            To compare numeric  and  text  values,  values  must  be
            converted   to  the  same  type  using  the  appropriate
            conversion function.

         2. Text  values  containing   upper-case   and   lower-case
            characters  are  compared  using the full character set.
            Thus, the string "JOE" does not have the same  value  as
|           the string "joe" unless SYSCASE is set to 1.

         3. Trailing blanks are ignored in a value except  when  the
            value  is  used  with  BEGINS,  NOT BEGINS, CONTAINS, or
            NCONT.  Use string functions to ignore  trailing  blanks
            with these operators.

|        4. Trailing blanks are  not  ignored  by  the  MATCHES  and
|           NMATCHES  operators.   Use the appropriate wildcard with
|           these operators to ignore trailing blanks.

         5. The system variable SYSTEXTDOT  controls  the  way  1022
            handles  invalid  qualified  attribute references.  When
            SYSTEXTDOT is 0,  1022  returns  an  error  message  for
            unquoted  references  in  the SET.ATTRIBUTE form that do
            not correspond to an attribute.  When SYSTEXTDOT  is  1,
            1022  treats  invalid  qualified attribute references as
            text.  See "Attribute Descriptors" in  the  General  Use
            chapter.
|  
|  
|  
|  4.2.1.1.3  Using Wildcards To Locate Text Values
|  
|  There are six wildcard characters  that  may  be  used  in  FIND,
|  DFIND,  SEARCH,  SELECT,  DBFIND,  DBSRCH,  and DBSEL commands to
|  locate records based on some portion  of  the  value  of  a  text
|  attribute.   Wildcard  selection  expressions consist of a quoted
|  text string containing one or more wildcard  characters  and  are
|  used  with  the  relational  operators MATCHES and NMATCHES.  The
|  operator MATCHES creates a selection set of all the records whose
|  values  agree with the wildcard expression that you specify.  The
|  operator NMATCHES selects all the records  whose  values  do  not
|  meet the conditions of the wildcard expression.
|  
|  For example, the following command finds all the records  with  a
|  value of MCDONALD or MACDONALD for the attribute SORT_NAME:
|  
|       FIND SORT_NAME MATCHES "M*DONALD@"
|  
|  A user might issue the following command to isolate all  obsolete
|  telephone  numbers  that  are  not  in the standard form of three
|  digits, a dash, and then four digits:
   EXAMINING THE DATA BASE                                      Page 4-15
   Revision 4


|       FIND PHONE NMATCHES "###-####"
|  
|  MATCHES  and  NMATCHES  may  be   abbreviated   MAT   and   NMAT,
|  respectively.
|  
|  The following table lists  the  System  1022  wildcards  and  the
|  characters that they match.
|  
|  
|          Wildcard        What It Matches           ________        ____ __ _______
|  
|          *       Any number of characters or spaces,
|                  including no characters or spaces
|  
|          @       Any number of spaces or tab characters,
|                  including no spaces or tab characters
|  
|          %       Any single character or space
|  
|          &       Any single alphanumeric character
|  
|          $       Any single alphabetic character
|  
|          #       Any single numeric character
|  
|  
|  You can  specify  any  of  the  1022  wildcards  in  a  selection
|  expression  with  MATCHES  or  NMATCHES.   Like  the  other  1022
|  relational operators, MATCHES  and  NMATCHES  are  case-sensitive
|  when  SYSCASE  is  0.  And, like CONTAINS, NCONTAINS, BEGINS, and
|  NBEGINS, they ignore the distinction between upper and lower case
|  when  SYSCASE is set to 1.  To constitute a match, each character
|  of the attribute value, including any spaces, must correspond  to                           _________ ___ ______
|  a text character or the appropriate wildcard in the corresponding
|  position in the selection expression.  Thus, if SORT_NAME  is  an
|  attribute of length 15, the command
|  
|       FIND SORT_NAME MATCHES "M*CDONALD"
|  
|  will find no matches because 1022 would pad  the  "MCDONALD"  and
|  "MACDONALD"  values  for SORT_NAME out to fifteen characters each
|  with spaces.  To find the desired match, the selection expression
|  would have to end in a wildcard to account for these spaces:
|  
|       FIND SORT_NAME MATCHES "M*CDONALD@"
|                    or
|       FIND SORT_NAME MATCHES "M*CDONALD*"
|  
|  Examples:
|  
|  
|      *    The asterisk wildcard (*) matches  any  number  of  text
|           characters  or  spaces, including no character or space.
|           Thus,
   EXAMINING THE DATA BASE                                      Page 4-16
   Revision 4


|                FIND SORT_NAME MATCHES "M*CDONALD*"
|  
|           matches  the  values  "MCDONALD  [ trailing   spaces ],"
|           "MCDONALD'S  [ trailing spaces ]," "MACDONALD [ trailing
|           spaces ]," and "MACDONALD'S [ trailing spaces ]," and so
|           on.
|  
|      @    The at-sign wildcard (@) matches any number of spaces or
|           tab characters, including no space or tab.  Thus,
|  
|                FIND SORT_NAME MATCHES "DI@ANGELIS@"
|  
|           matches the values "DIANGELIS [ trailing  spaces ]"  and
|           "DI ANGELIS [ trailing spaces ]."
|  
|      %    The percent-sign wildcard (%) matches  any  single  text
|           character or space.  Thus,
|  
|                FIND SORT_NAME MATCHES "A%B*"
|  
|           matches "A&B PIZZA [ trailing spaces ]," "A B C MOVERS [
|           trailing spaces ]," and "ALBANO [ trailing spaces ]."
|  
|      &    The  ampersand   wildcard   (&)   matches   any   single
|           alphanumeric character (A-Z, 0-9, a-z).  Thus,
|  
|                FIND ZIP_CODE NMATCHES "&&&@&&&@"
|  
|           might be  used  to  check  for  errors  in  a  data  set
|           containing  Canadian  zip  codes  (such  as  H3A 3C7 and
|           H3C3H5),  trapping  all  entries  with  non-alphanumeric
|           characters.
|  
|      $    The  dollar-sign  wildcard  ($)   matches   any   single
|           alphabetic  character (A-Z, a-z).  The following command
|           isolates all US zip codes (such as 02144 and 02144-6102)
|           in  a  data  set  containing both numeric and hyphenated
|           numeric US  zip  codes  and  Canadian  alphanumeric  zip
|           codes:
|  
|                FIND ZIP_CODE NMATCHES "*$*"
|  
|      #    The pound-sign wildcard (#) matches any  single  numeric
|           character (0-9).  The following command might be used to
|           check  for  errors  in  a  data  set   containing   only
|           non-numeric data:
|  
|                FIND SORT_NAME MATCHES "*#*"
|  
|  Suggestions:
|  
|  For greatest efficiency in dealing with large data sets, create a
|  selection  set  with  a FIND CONTAINS command, and then narrow it
|  with a SEARCH MATCHES command.
   EXAMINING THE DATA BASE                                      Page 4-17
   Revision 4


|  Remember to take account of trailing blanks when wildcarding with
|  MATCHES or NMATCHES.



   4.2.1.2  Logical Operators

   Basic selection conditions may be linked by logical operators  to
   narrow  or  broaden  the  criteria  for  inclusion in a selection
   group.  System 1022 uses the following logical operators:

        OPERATOR                       DESCRIPTION        ________                       ___________

           AND       Records satisfy both selection conditions.

           OR        Records satisfy either or both of the selection
                     conditions.

           XOR       Records  satisfy  one  or  the  other  of   the
                     selection conditions, but not both.

           EQV       Records  satisfy  both  conditions  or  neither
                     condition.

           NOT       Records do not satisfy the selection condition.                                ___

   Expressions containing logical operators are  evaluated  according  to
   the following order of precedence:

        1.  All  expressions  within  parentheses  are  evaluated  first,
            starting  with  those  enclosed within innermost parentheses;
            then,

        2.  all expressions containing either XOR or EQV  are  evaluated;
            then

        3.  all expressions containing AND are evaluated;  then

        4.  all expressions containing OR are evaluated.

   Examples:

   The following examples use the data set BLOOD  whose  records  contain
   values  for  the attributes SEX, RH FACTOR (RH), BLOOD GROUP (BG), and
   AGE.

        FIND SEX EQ M OR SEX EQ F AND RH EQ NEG

             This first finds the records of all who  are  both
             female  and  RH negative and then adds the records
             of all who  are  male.   The  resulting  selection
             group  is made up of all and only those who are Rh
             negative and female and those who are  male.   The
   EXAMINING THE DATA BASE                                      Page 4-18
   Revision 4


             process of selection may be diagrammed as follows:


             FIND |SEX EQ M| OR |SEX EQ F| AND |RH EQ NEG|
                  |________|    |________|     |_________|
                       |             |             |
                       |         8 RECORDS     8 RECORDS
                       |             |             |
                       |             |_____________|
                       |                    |
                  9 RECORDS             4 RECORDS
                       |                    |
                       |____________________|
                                 |
                            13 RECORDS


        FIND AGE BET 25 35 AND SEX EQ F EQV RH EQ NEG

             This first finds the records of all who are either
             both female and Rh negative or else neither female
             nor Rh negative.  Then then the records are  found
             of  all who are both between the ages of 25 and 35
             and either female and Rh negative or else  neither
             female  nor  Rh negative.  The resulting selection
             group is made up of all and only those Rh negative
             females  and Rh positive males who are between the
             ages of 25 and 35.

        FIND (BG EQ A OR BG EQ B) EQV RH EQ POS

             This first finds the records of all who belong  to
             blood group A and all who belong to blood group B.
             Then the records are found of all  who  belong  to
             either  blood group A or B and are Rh positive and
             all who belong to neither blood group A nor B  and
             are  not  Rh  positive.   The  resulting selection
             group is made up of all and only those who  are  A
             positive,  B positive, O negative, or AB negative.
             A less succinct version of this command finds  the
             same selection group in a slightly more roundabout
             way:

        FIND ((BG EQ A OR BG EQ B) AND RH EQ POS) OR
           ((BG EQ O OR BG EQ AB) AND RH EQ NEG)

             This first finds the records of all who belong  to
             blood group A and all who belong to blood group B,
             on the one hand, and all who belong to blood group
             O  and  all  who  belong to blood group AB, on the
             other.  Then the records are found of all who  are
             A positive or B positive, on the one hand, and all
             who are either O negative or AB negative,  on  the
   EXAMINING THE DATA BASE                                      Page 4-19
   Revision 4


             other.   Finally,  the  records  of  all who are A
             positive  or  B  positive  or  O  negative  or  AB
             negative  are combined to form the final selection
             group.

   The use of NOT is illustrated in the following examples.  NOT operates
   only  on  the  selection  condition  or  parenthetical expression that
   immediately follows it.

   EXAMPLES:

        FIND NOT AGE BET 25 35 AND SEX EQ M

             This finds the records of all who  are  both  male
             and not between the ages of 25 and 35.

        FIND NOT AGE BET 25 35 AND NOT SEX EQ M

             This finds the records of all who are neither male
             nor  between  the ages of 25 and 35.  This command
             could also be written

        FIND AGE NOT BET 25 35 NOT AND SEX EQ M

                       or

        FIND AGE NOT BET 25 35 AND SEX NOT EQ M

             That is, NOT may immediately follow or immediately
             precede  the first term of the selection condition
             to which it applies, or it may immediately precede
             the  logical  operator  which immediately precedes
             that selection condition.

        FIND NOT (AGE BET 25 35 AND SEX EQ M)

             This first finds the records of all who  are  both
             male  and  between  the ages of 25 and 35 and then
             finds the records of all who do not belong to this
             group to form the final selection group of all and
             only those who are either male and under  the  age
             of  25,  male  and  over  the  age  of 35, or else
             female.  Nested expressions are  treated  in  like
             fashion:

        FIND NOT (((BG EQ A OR BG EQ B) AND RH EQ POS) OR
           ((BG EQ O OR BG EQ AB) AND RH EQ NEG))

             This ultimately yields a selection group  made  up
             of  all  and  only  those  who  are  A negative, B
             negative, O positive, or AB positive.

   Note that parentheses must balance, as above, and must not cut up  any
   EXAMINING THE DATA BASE                                      Page 4-20
   Revision 4


   selection group.  Note also that the foregoing rules of precedence are
   altered in commands of the form

        FIND NOT (X OR Y AND Z)

                  or

        FIND NOT (Z AND Y OR X)

   where X, Y, and Z are selection conditons.  In such  cases,  selection
   conditions  linked  by  OR  are  evaluated before selection conditions
   linked by AND.  For example,

        FIND NOT (SEX EQ F OR SEX EQ M AND RH EQ NEG)

             This first finds the records of all males and  all
             females.  Then it finds the records of all who are
             either male and  Rh  negative  or  female  and  Rh
             negative.   And  then  it finds the records of all
             who do not belong to that group, thus  yielding  a
             final  selection  group  made  up  of all and only
             those  who  are  Rh  positive.   The  process   of
             selection may be diagrammed as follows:


             FIND |NOT| (|SEX EQ M| OR |SEX EQ F| AND |RH EQ NEG|)
                  |___|  |________|    |________|     |_________|
                    |         |             |             |
                    |     9 RECORDS     8 RECORDS         |
                    |         |             |             |
                    |         |_____________|             |
                    |                |                    |
                    |          17 RECORDS             8 RECORDS
                    |                |                    |
                    |                |____________________|
                    |                           |
                    |                       8 RECORDS
                    |                           |
                    |___________________________|
                                  |
                              9 RECORDS


   Again,

        FIND NOT (SEX EQ F AND RH EQ NEG OR SEX EQ M)

             This first finds the records of  all  who  are  Rh
             negative  and all who are male.  Then it finds the
             records of all who are either both female  and  Rh
             negative  or  else both female and male.  And then
             it finds the records of all who do not  belong  to
             that  group  (which  is  made  up  of  Rh negative
   EXAMINING THE DATA BASE                                      Page 4-21
   Revision 4


             females  and  nobody),  thus  yielding   a   final
             selection  group made up of all and only those who
             are not Rh negative females.

   Such situations may be avoided in a variety of ways.  If, for example,
   you  want  to  find  the records of all and only those who are neither
   female and Rh negative nor male, any of the  following  commands  will
   work:

        FIND NOT SEX EQ M OR NOT SEX EQ F AND RH EQ NEG

                              or

        FIND NOT (SEX EQ M OR (SEX EQ F AND RH EQ NEG))

                              or

        FIND SEX EQ M OR SEX EQ F AND RH EQ NEG
        FIND NOT LAST

                or

        FIND SEX EQ F AND RH EQ POS.



   4.2.1.3  Special Selection Conditions

   The FIND command can also be used  with  the  four  following  special
   selection conditions.


   1) ALL

   The keyword ALL used as a condition in the FIND  command  selects  all
   active (not deleted) records in the data set, and is the preferred way
   to do this.  The resulting message gives the number of active records.
   FIND ALL is the best way to set up the entire data set for a following
   SEARCH on unkeyed attributes through all the records.  FIND ALL  works
   even when there are no keyed attributes.

   DFIND ALL selects all deleted records in  the  data  set.   See  DFIND
   command.

   2) LAST

   The keyword LAST represents the records in the current selection group
   just  before executing the FIND command containing it.  This selection
   group is usually the result of the last FIND, DFIND,  SEARCH,  or  MAP
   command.   LAST may be combined logically with other selection groups,
   and thus may be used either to add records to those already  found  or
   to eliminate some previously found.
   EXAMINING THE DATA BASE                                      Page 4-22
   Revision 4


   Examples:

        FIND AGE 35
        FIND LAST AND SEX M

        The second FIND finds all people age 35 and sex M.

        FIND NOT LAST

        This FIND then selects all who are not both 35 and male.

        FIND LAST OR FN FRED.

        This adds all records  with  first  name  FRED  to  the  previous
        selection group.


   3) SYSID

   The reserved word SYSID  is  a  system-defined  attribute  name  which
   represents  the  internal  record  number  assigned  to  each data set
   record.  This number is maintained by 1022 and cannot  be  changed  by
   the  user.   Since  it is unique for each record, it provides a useful
   reference number.  Records with identical values can be  distinguished
   by selecting on the value of SYSID.  Also, during the LOADing phase of
   data set creation, errors are flagged  by  giving  the  SYSID  of  the
   record  in  error,  so  the  user may investigate these later with the
   command:

        FIND SYSID @name.DME

   where name is the name of the 1022 data set being loaded.         ____

   The SYSIDs of deleted records are unavailable for retrieval  with  the
   FIND  command.   Thus,  a  data  set with 2000 active records does not
   necessarily have its SYSIDs numbered from 1 to 2000.


   4) FILE <file-descriptor>

   Files created with the SAVE command (DMV files) are referenced by this
   FILE  selector  condition.  This makes it possible to retain different
   selection groups for later operation.

   EXAMINING THE DATA BASE                                      Page 4-23
   Revision 4


   Example:

        FIND AGE EQ 30
        SAVE GRP30
           .
           .
        FIND SEX EQ MALE AND FILE GRP30

        The retrieval information for records with AGE  equal  to  30  is
        saved  in  the  file  called  GRP30.DMV.  The clause "FILE GRP30"
        stands for the records in that group.

   The file used in a FILE clause must have been created  with  a  System
|  1022  SAVE  command, and the version of the data set to which the FIND
|  FILE command  applies  must  be  the  one  from  which  the  file  was
|  extracted.   1022  gives  an error message if these conditions are not
|  met.



   4.2.1.4  Collapsing The FIND Command

   The FIND command allows many shortcuts in typing which make  sense  to
   1022 and which make the entire FIND command logical and natural.

   First, 1022 does not require that the relational EQ be typed  in  most
   cases.

        FIND AGE EQ 30                     Can be typed as

        FIND AGE 30

        FIND AGE EQ 30 AND JOB EQ PLUMBER  Can be typed as

        FIND AGE 30 AND JOB PLUMBER

   Second, the attribute name need not be repeated if it is the  same  as
   the last one used.

        FIND AGE 30 OR AGE 31              Can be typed as

        FIND AGE 30 OR 31

   Third, the logical  connective  OR  is  not  required  between  values
   occurring under the same attribute name, if values after the first are
   positive.

        FIND AGE 30 OR 31                  Can be typed as

        FIND AGE 30 31

   The logical OR is required before negative  values  after  the  first.
   1022  reads  the  expression  LOWTEMP  -20  -10 as LOWTEMP -30, not as
   EXAMINING THE DATA BASE                                      Page 4-24
   Revision 4


   LOWTEMP -20 OR -10.

   Fourth, the logical connective AND is not required between values used
   with  the  relational operators BETWEEN and NOT BETWEEN, if the second
   value is positive.

        FIND AGE BET 20 AND 30             Can be typed as

        FIND AGE BET 20 30

   The logical AND is required before negative values after the first, as
   with OR.

   Fifth, the logical connective AND is not  required  between  different
   attribute groups.

        FIND AGE 31 32 AND JOB PLUMBER CARPENTER     Can be typed as

        FIND AGE 31 32 JOB PLUMBER CARPENTER


   These rules can  be  stated  a  different  way,  allowing  for  a  few
   exceptions:

        1.  When the user omits a relational (like EQ, LT, GT)  1022
            supplies  one  which  is the same as the last one typed.
            1022 supplies EQUALS if no relational  is  typed.   1022
            fills  in  the  last  relational  until  a new selection
            condition begins, where the relational defaults again to
            EQ.

        2.  A logical (like AND, OR) which is omitted between values
            of the same attribute is filled in as OR.

        3.  A logical which is omitted  between  separate  selection
            conditions is filled in as AND.

   Thus,
|  
|       FIND AGE 31 32 33 JOB PLUMBER CARPENTER LAST_NAME BEGINS "K"
|       "L"
|  
|  is the same as typing
|  
|       FIND (AGE EQ 31 OR AGE EQ 32 OR  AGE  EQ  33)  AND  (JOB  EQ
|       PLUMBER  OR  JOB  EQ CARPENTER) AND (LAST_NAME BEGINS "K" OR
|       LAST_NAME BEGINS "L")
|  
|  That is, find everybody who is either 31, 32,  or  33  years  old,  is
|  either  a  plumber  or  a  carpenter,  and whose last name begins with
|  either "K" or "L".
|  
|  The relational operators with a negative sense (NEQ,  NCONT,  NBEGINS)
   EXAMINING THE DATA BASE                                      Page 4-25
   Revision 4


|  cause an implicit OR to be replaced by an AND.  Thus,
|  
|       FIND AGE NE 31 32 33 JOB PLUMBER CARPENTER LAST_NAME NBEG "K" "L"
|  
|  is the same as typing
|  
|       FIND (AGE NE 31 AND AGE NE 32 AND AGE NE 33) AND (JOB EQ  PLUMBER
|       OR  JOB  EQ CARPENTER) AND (LAST_NAME NBEG "K" AND LAST_NAME NBEG
|       "L")
|  
|  That is, find everybody who is either a plumber  or  a  carpenter,  is
|  neither  31,  32,  or 33 years old, and whose last name does not begin
|  with either "K" or "L".  Note that this is not the same as
|  
|       FIND AGE NOT EQ 31 32 33 JOB PLUMBER CARPENTER LAST_NAME NOT  BEG
|       "K" "L"
|  
|  which 1022 interprets as
|  
|       FIND NOT (AGE EQ 31 AND AGE EQ 32 AND AGE  EQ  33)  AND  (JOB  EQ
|       PLUMBER  OR  JOB  EQ  CARPENTER)  AND  NOT (LAST_NAME BEG "K" AND
|       LAST_NAME BEG "L")
|  
|  That is, find everybody who is not simultaneously 31, 32, and 33 years
|  old,  is either a plumber or a carpenter, and whose last name does not
|  simultaneously begin with  "K"  and  "L".   This  amounts  to  finding
|  everybody  who  is either a plumber or carpenter, regardless of age or
|  last name.  To avoid such unintended results, the user  should  either
|  make AND and OR explicit in complex expressions or else should use the
|  operators NEQ, NBEGINS, and NCONT.

   One common ambiguity happens because of this  generally  free  command
   form.   Assume that the user has defined the two attributes DEGREE for
   academic degree, and MS for marital-status.  One of the values of  the
   attribute  DEGREE might be MS (standing for Masters Degree).  The user
   might type:

        FIND DEGREE PHD MS

   meaning FIND  all  people  having  PHD  or  MS  degrees.   1022  would
   interpret the MS as the start of a new clause for Marital-Status.  The
   user can eliminate the mistake by typing:

        FIND DEGREE PHD "MS"

   1022 knows that any word in quotes  is  never  an  attribute  name  or
   reserved word.

   Although the System 1022 command language is word oriented  and  space
   delimited, the user may type parentheses (and the final command period
   in  files)  without  worrying  about  separating  them  from   values,
   attribute names, or logicals.  Thus the user may type correctly:
   EXAMINING THE DATA BASE                                      Page 4-26
   Revision 4


        FIND(AGE 30)OR(JOB PLUMBER)AND(DEGREE PHD)



   4.2.2  SAVE Command

   The SAVE command stores the  retrieval  information  for  the  current
   selection  group  in  a disk file, using the default extension ".DMV".
   SAVE preserves the sorted order of the selection  group.   The  syntax
   is:

        SAVE file-descriptor


   A FILE clause in a FIND command retrieves the information in the  save
   file.   Sorted order is retained if the FILE clause appears alone in a
   FIND command.  If a mixed selection  condition  is  used,  the  sorted
   order is lost.  (See Special Selection Conditions in this chapter.)

   Example of the SAVE command:

        FIND AGE EQ 30
        SAVE GRP30
           .
           .
        FIND SEX EQ MALE AND FILE GRP30



   4.2.3  DFIND Command

   The DFIND command (like FIND) selects records, but only from among the
   deleted  records  in  a  data  set.   The  form  of a DFIND command is
   identical to that of the FIND command.  For example:

        DFIND FIRST_NAME JOHN

   finds all deleted records with the  first  name  JOHN.   Once  deleted
   records are located with DFIND, then PRINT, SEARCH, GETREC, and SELECT
   commands operate on this  selected  group  as  if  these  were  active
   records in the data set.

   When working with deleted records, DFIND commands may be chained  (For
   example  DFIND  LAST  OR ...), and may use FILE clauses to reference a
   previous group of deleted records saved with the SAVE command.

   Whenever the user  switches  between  FIND  and  DFIND  commands,  the
   current  selection  group  is  cleared;   a  selected group is made up
   entirely of active or  entirely  of  deleted  records,  and  is  never
   intermixed.
   EXAMINING THE DATA BASE                                      Page 4-27
   Revision 4


   4.2.4  SEARCH Command

   The SEARCH command has the same logical structure and  format  as  the
   FIND  command.   However,  the  SEARCH  command  locates  records in a
   different physical way.

   The FIND command selects a subset of the entire data  set  using  only
   keyed attributes.  The selection is rapid due to the special structure
   that 1022 builds for keyed attributes.

   The SEARCH command searches only among the records currently selected,
   usually  by the last FIND, SEARCH, or MAP command.  SEARCH can perform
   attribute-to-attribute comparisons on the values found in the  records
   and is not limited to keyed attributes.

   The SEARCH command reduces the selection of a FIND  command.   Because
   the  SEARCH  command  reads  through the data records, and not special
   tables, it usually takes longer than an equivalent FIND  command.   An
   efficient  strategy  is  to  use  a  FIND  command  to narrow down the
   possibilities and then use a SEARCH on those records found.

   The selection condition using the FILE clause is not allowed.  This is
   because the SEARCH command always searches the last group found.

   A SEARCH command can test  a  condition  between  attributes  in  each
   record.   A  FIND  command cannot do this because records are selected
   only against fixed values supplied at the beginning of the  retrieval.
   FIND  does  not  allow  attributes  to  the  right  of  the relational
   operator.

   The following are examples of the SEARCH command:

        SEARCH AGE EQ 30

        SEARCH AGE EQ RETAGE-2

        SEARCH RATING1 GT (RATING2+RATING3)*(RATING4-38*9)


   In the SEARCH command, expressions may follow the relational  operator
   but  they  may not precede it.  Only attributes may appear to the left
   of a relational operator.  In the following example,  the  user  finds
   all records entered during the month of September:

        SEARCH DOE EQUALS DOE + $MONTH(DOE) - 9.

   Note that "SEARCH $MONTH(DOE) EQUALS 9" is illegal in 1022.

   SEARCH uses all the relational operators listed in table 4.1.

   "SEARCH CONTAINS", which allows searching  for  text  attributes  that
   contain  the  value  as  a substring, may be more efficient than "FIND
   CONTAINS" in the case of a small subset of records since FIND CONTAINS
   EXAMINING THE DATA BASE                                      Page 4-28
   Revision 4


   requires that the entire key table be scanned.

   SEARCH and SELECT may  use  a  qualified  attribute  reference  to  an
   alternate data set following the relational operator.  For example,

        SEARCH PNAME EQ CHILD.CNAME

   selects records in the current PARENT data set that have  PNAME  equal
   to  CNAME  in  the  first  selected  record  in  the  CHILD  data set.
   Qualified attributes without a JOIN in effect reference only the first
   record  of the selection group in the other data set.  (See "Attribute
   Descriptors" in the General Use Chapter).

   The system variable SYSTEXTDOT controls the way 1022  handles  invalid
   qualified attribute references.  When SYSTEXTDOT is 0, 1022 returns an
   error message for references in the SET.ATTRIBUTE  form  that  do  not
   correspond to an attribute.  When SYSTEXTDOT is 1, 1022 treats invalid
   qualified attribute references as text.  See  "Attribute  Descriptors"
   in the General Use chapter.

   The system variable SYSCASE controls  whether  upper  and  lower  case
   characters  match in SEARCH, SELECT, and IF comparisons.  The user may
   LET SYSCASE 1 to ignore case differences.   The  default  value  of  0
   distinguishes upper and lower, and all characters must match exactly.






   4.2.5  SELECT Command

   Use the SELECT command in place of the SEARCH command when the  SEARCH
   is  followed  by another command, such as a PRINT, which retrieves the
   records as part of its operation.  The form of the command is the same
   as the SEARCH command:

        SELECT <selector-group> [<logical> <selector-group> ] ...

   The SELECT command postpones use of the selection criteria  until  the
   records are retrieved by a later command, in order to avoid retrieving
   the same records twice.  For example:

        * FIND DATEOFPUB GT "1/1/75"        _
        600 RECS FOUND        ___ ____ _____
        * SEARCH TITLE CT "CHEMISTRY"        _
        400 RECS FOUND        ___ ____ _____
        * PRINT TITLE AUTHOR FMT A25 A10 END        _

   In this case, 1022  retrieves  600  records  during  the  search,  and
   narrows  the  group  down to 400 records.  The following PRINT command
   retrieves these 400 records a  second  time  for  output.   Thus  1022
   performs 600+400=1000 retrievals.
   EXAMINING THE DATA BASE                                      Page 4-29
   Revision 4


   Use the SELECT command instead of SEARCH, to reduce the  total  number
   of record retrievals.  For example:

        * FIND DATEOFPUB GT "1/1/75"        _
        600 RECS FOUND        ___ ____ _____
        * SELECT TITLE CT "CHEMISTRY"        _
        * PRINT TITLE AUTHOR FMT A25 A10 END        _

   This procedure avoids the second retrieval of  the  400  records.   It
   applies  the selection conditions to the records as they are retrieved
   by the PRINT command for output.  Only those  records  satisfying  the
   conditions  are  used.   The result is 600 record retrievals, of which
   400 records are printed.

   The SELECT command has no effect until  a  second  command  is  issued
   which cycles through all of the records in the selection group.
   These commands include:

        CHANGE, DELETE, DUMP, EVALUATE, GETREC, LET, MAP,
        PRINT, SEARCH, SORT, SPSS, TRANSACT, TYPE, UNDELETE.

   The SELECT conditions remain in force until one of these  commands  is
   given,  or  until  a  FIND  or another SELECT is issued with different
   selection conditions.

   In local mode (see this chapter, GETREC command),  SELECT  applies  to
   each  record  as  it  is  retrieved.  The GETREC command retrieves the
   first record in the group satisfying the SELECT conditions;  it  drops
   all  prior  records  from the group.  GETREC N selects the N'th record
   that satisfies the SELECT conditions; it drops all prior records  that
   do not satisfy the conditions.

   The SELECT conditions continue to be used in local mode until all  the
   records  in the selection group are exhausted or until another FIND or
   SELECT command is given.  Note  that  if  the  user  ends  local  mode
   operation  with  a FIND LAST command, the resulting selection group is
   mixed.  It contains records that do not satisfy the SELECT conditions,
   because they were not retrieved before single record processing ended.
   Restoring Global mode with the STARTREC command does not  disable  the
   SELECT  conditions.   Any  FIND command, including FIND LAST, disables
   the SELECT conditions.



   4.2.6  GETREC Command

   In an interactive session, the  user  usually  works  with  groups  of
   records  chosen  with SEARCH and FIND commands.  Sometimes he wants to
   look at just one or two of the group, or to select a particular record
   according  to  its  sequence  in  the  group.   This is most useful in
   PL1022, but is also  useful  in  the  interactive  mode.   The  GETREC
   command selects just one out of a group of records.
   EXAMINING THE DATA BASE                                      Page 4-30
   Revision 4


|       A.  GETREC [ $LOCK ]
|       B.  GETREC [ $LOCK ] <expression>

   In form A, the command selects  the  next  record  in  the  group  and
   singles  it  out  logically.   The  "next" record is the first one the
   first time the command  is  executed,  and  steps  down  the  list  of
|  selected  records  each  time the command is given again.  You can use
|  the $LOCK keyword to request exclusive update access to the record  if
|  the  data  set  is  a  RECLOCK  data set (see Chapter 5, "Record-Level
|  Locking").

   In form B, an integer or expression denotes the number of  the  record
   you  wish  to select, and this singles out that record logically.  The
   number of the record is its  sequence  number  (SYSRECNO)  within  the
   group,  not its data set location (SYSID).  Further GETREC commands of
   form A select records starting just after this point in the group.  If
   you  sort the records prior to selecting individual records, 1022 uses
   the sorted order.

   If the expression is not type integer, it is converted to integer  for
   the  command.   If  no record corresponds to the GETREC request, as at
   the end of a group of records, the user is notified with a message.


   After a successful GETREC command, 1022 goes  into  local  (or  single
   record) mode.  Subsequent 1022 commands such as PRINT and CHANGE refer
   only to the single record, and not to the rest of the group.  In  this
   way,  the  user  can  act individually on each record of the group.  A
   SORT command in local mode, however, sorts the entire selection group.
   After  an unsuccessful GETREC command (no record is found), local mode
   ends, and 1022 returns to global mode.

   The user can return to global mode and retain  the  current  selection
   group  by  typing  either  FIND LAST or STARTREC.  If the records were
   sorted prior to entering local mode,  typing  FIND LAST  destroys  the
   order,  while  typing STARTREC preserves the order.  Also, any FIND or
   SEARCH command causes  a  return  to  global  mode  and  forms  a  new
   selection group.

   DROP or DELETE commands can affect the sequence numbers of records  in
   a selected group.  See Chapter 5, DELETE command.

   The system variable SYSRECMODE is a flag that indicates  whether  1022
   is  in  global or local mode.  When SYSRECMODE is 0, 1022 is in global
   mode.  When SYSRECMODE is -1, 1022 is in local mode.  Examples:

        * FIND ALL        _
        400 RECS FOUND        ______________
        * GETREC        _
        * PRINT AGE        _
        35        __

        Since only one record is selected in Local mode, only one  record
   EXAMINING THE DATA BASE                                      Page 4-31
   Revision 4


        is referenced in the PRINT command.

        * GETREC 10        _
        * PRINT AGE        _
        64        __

        The 10th record of the group is selected.

        * GETREC 400/3        _

        The 133rd record of the group is selected.

        * FIND LAST        _

        400 RECS FOUND        ___ ____ _____

        The original group is restored to global mode.

        * GETREC 500        _
        ?(PL5) GETREC, no record        ______ _______ __ ______

        No such record exists in the group,  and  a  return  is  made  to
        global mode.



   4.2.7  DROP Command

   The user can investigate a group of records  and  individually  narrow
   down the selected records with the DROP command.

   The format of the DROP command is:

        DROP

   Use the DROP command in local mode (see GETREC).  Typically, the  user
   is investigating a group of records one by one using GETREC and PRINT.
   If the user finds a record he wishes to drop from  consideration,  the
   DROP command removes the current record.

   The attribute values in a record remain available after a DROP command
   until the next GETREC command or a return to Global mode.

   The DROP command does not alter any records and does not  delete  them
   from the data set.

   DROP or DELETE commands can affect the sequence numbers of records  in
   a selection group.  See Chapter 5, DELETE command.


   Example:

        * FIND AGE 30        _
   EXAMINING THE DATA BASE                                      Page 4-32
   Revision 4


        20 RECS FOUND        _____________
        * GETREC. PRINT FIRSTNAME        _
        ALFRED        ______
        * DROP        _

        We decided we don't want ALFRED  to  be  considered  in  the
        following operations.

        * FIND LAST        _
        19 RECS FOUND        _____________
        * FIND AGE 30 AND NOT LAST        _
        FOUND        _____

        We have found the dropped record, ALFRED.




   4.2.8  MAP Command

   The MAP command locates records in another data set (the  second  data
   set)  which share common attribute values with the selected records of
   the current data set.  The form of the command is:


                { KEY  }           { AND }
|       MAP [BY { SORT }] [LOGICAL { OR  }] [TO] <data-set-descriptor>
                {GETREC}           {CLEAR}

             [VIA] <attr-1> [ [TO] <attr-2> ]

             [ AND [VIA] <attr-3> [ [TO] <attr-4> ] ] ...

   Where:


   BY                    Specifies that MAP will locate records using the
|                        key  table (KEY), or by accumulating and sorting
|                        the locator values, ignoring duplicate values in
|                        the  MAP (SORT), or by examining one record at a
                         time  (GETREC).   Without  this   clause,   1022
                         usually chooses the best method.  Specifying the
                         method sometimes improves performance.

   LOGICAL               Tells how to combine the result of this MAP with
                         any  previously  selected  records in the second
                         data  set.   AND  forms  a  selection  group  of
                         records  that  share  values with the first data
                         set and were previously selected in  the  second                             ___
                         data  set.  OR selects records that share values
                         with the  first  data  set  or  were  previously                                                     __
                         selected  in  the  second  data set.  CLEAR, the
                         default when no  LOGICAL  clause  is  specified,
   EXAMINING THE DATA BASE                                      Page 4-33
   Revision 4


                         ignores  any  selection group in the second data
                         set.

   <data-set-descriptor> Is the data set name, alias, or data set  number
                         of  the  second  data set, where new records are
                         selected.

   VIA                   The whole locator clause, VIA attr-1 TO  attr-2,
                         is  optional  if the two data sets are joined by
                         those locators.   See  "Simplified  MAP  Command
                         with Joined Data Sets" below.

   <attr-1>              Is the name of the attribute in the current data
                         set used as the basis for the mapping.  MAP uses
                         the values of  this  attribute  in  the  current
                         group of records.  SYSID may be used.

   <attr-2>              Is the name of a keyed attribute in  the  second                                          _____
                         data  set  whose  values  are  compared with the
                         values of attr-1 as the basis for  the  mapping.
                         If  attr-2  is  omitted, it has the same name as
                         attr-1.  SYSID may be used.

   AND                   Specifies that more than one  attribute  in  the
                         current  data  set  be used to select records in
                         the second  data  set.   Any  records  that  are
                         selected match on all specified attributes.

   <attr-3>              Is the name of a second (or  nth)  attribute  in
                         the  current data set to be used in comparisons.
                         Any records that are selected are matched on all
                         the  specified  attributes  in  the current data
                         set.

   <attr-4>              Is the name of a second (or nth) keyed attribute                                                          _____
                         in the second data set whose values are compared
                         with  the  values  of  attr-3.   If  attr-4   is
                         omitted, it has the same name as attr-3.

   The MAP finds all the records in the second data set with attr-2 equal
   to any value of attr-1 appearing in selected records of the first data
   set.  The values of attr-1 point to the records  in  the  second  data
   set.   If  the  AND  clause  is  used,  subsequent  pairs  of  locator
   attributes select records in the same way.  Any number of AND  clauses
   may be used.  SYSID may be used as a linking attribute.

   Also, the MAP leaves the second data set as the current one.  MAP does
   a  DBSET  to  the  second data set, and has all the effects of a DBSET
   command in command files and programs.

   For example, consider two data sets PARENT and CHILD,  one  containing
   information  on  parents, the second on their children.  The data sets
   are linked by the Social Security Numbers of the  parents,  which  are
   EXAMINING THE DATA BASE                                      Page 4-34
   Revision 4


   stored  in  attribute SSN in the PARENT data set and in attribute PSSN
   in the CHILD data set.  Suppose we wish to find the  children  of  all
   parents older than 65.  The following commands accomplish this:

        * OPEN PARENT CHILD        _
        * FIND AGE GT 65        _
        6 RECS FOUND        _ ____ _____
        * MAP TO CHILD VIA SSN TO PSSN        _
        14 RECS FOUND        __ ____ _____

   The MAP finds 14 records in the  CHILD  data  set  related  to  the  6
   starting  records  in  the  PARENT  data  set.   The  CHILD  data  set
   automatically becomes the current data set, as if a DBSET  CHILD  were
   done.

             +---------------+          +---------------+
             |               |          |               |
             |    PARENT     |          |     SCHOOL    |
             |               |          |               |
             |     [SSN]     |          |  [SCHOOLNAME] |
             |  [FIRSTNAME]  |          |  [SCHOOLNUM]  |
             +---------------+          +---------------+

                          \                 /
                           \               /

                         +--------------------+
                         |                    |
                         |      CHILD         |
                         |                    |
                         | [PSSN] [SCHOOLNUM] |
                         |     [FIRSTNAME]    |
                         +--------------------+

   As an example of the LOGICAL clause,  consider  the  previous  example
   with  one  additional  data set.  The SCHOOL data set is linked by the
   school number of each child to the CHILD data set.  In both data  sets
   the  school  number  is  the  attribute SCHOOLNUM.  To find all of the
   students in the BAKER school with parents older than 60, we can type:

        * OPEN SCHOOL PARENT CHILD        _
        * FIND SCHOOLNAME BAKER        _
        FOUND        _____
        * MAP TO CHILD VIA SCHOOLNUM        _
        437 RECS FOUND        ___ ____ _____
        * DBSET PARENT        _
        * FIND AGE GT 60        _
        15 RECS FOUND        __ ____ _____
        * MAP  LOGICAL AND  TO CHILD VIA SSN TO PSSN        _
        9 RECS FOUND        _ ____ _____

   The first FIND locates the school record for BAKER school.   The  link
   to  child is by SCHOOLNUM.  We don't have to know what that number is;
   EXAMINING THE DATA BASE                                      Page 4-35
   Revision 4


   we can MAP to CHILD to select children in  that  school.   Turning  to
   PARENT, we find those over 60.  The second MAP locates the children of
   those parents and the  LOGICAL  AND  combines  this  result  with  the
   previous  group  in CHILD (BAKER school) to give those records in both
   selections.



   4.2.8.1  Multi-locator MAP

   In some cases it is necessary to map  using  more  than  one  pair  of
   locator attributes.  For example, we wish to find all the children who
   have the same first name as one of their parents.

        * OPEN PARENT CHILD        _
        * FIND ALL        _
        51 RECS FOUND        __ ____ _____
        *MAP TO CHILD VIA SSN TO PSSN AND FIRSTNAME        _
        5 RECS FOUND        _ ____ _____

   In the example above, the MAP selects records in the  CHILD  data  set
   based  on two attributes.  Child records which match parent records on
   SSN and FIRSTNAME are selected.

   The source data set in a MAP is not changed at all by  the  MAP.   The
   selection  group is unchanged when the user DBSETs back to make it the
   current data set.

   The user may do a MAP to the same data  set,  when  the  data  set  is
   OPENed twice.  For example:

        OPEN PARENT PARENT

   MAP may then be done from one to another, maintaining two views of the
   data in the single data set.  The data set number (1 or 2) or an alias
   must be used in the MAP to distinguish between the  two  views,  since
   the data set names are the same.  For example:

        * OPEN PARENT PARENT AS P        _
        * DBSET 1        _
        * FIND FNAME ALFRED        _
        3 RECS FOUND        _ ____ _____
        * MAP TO P VIA LNAME ! MAPs to the second view using the alias P        _
        5 RECS FOUND         ! as the source; 2 could be used        _ ____ _____

   A MAP operates from just  the  one  selected  record,  if  GETREC  has
   established local mode for one record of a group.
   EXAMINING THE DATA BASE                                      Page 4-36
   Revision 4


   4.2.9  JOIN Command

   The JOIN command relates data sets in pairs, automatically mapping  so
   that  a  record  in  the  current  data  set  is  extended  to include
   attributes from a paired data set.  The  join  relation  automatically
   selects records according to the common attribute value shared between
   them.  Commands that reference these added attributes regard  them  as
   part of the current record.  All and only those 1022 commands that may
   reference qualified attributes may reference the attributes of  joined
   data sets.  (See "Attribute Descriptors" in Chapter 2.)

   JOIN commands relate open data sets or  collections  (see  "JOIN  with
   Collections").   The  command specifies the data sets involved and the
   locators used to relate the sets.

   The syntax for the command is:

     JOIN set1 [TO] set2 [VIA] attr1 [[TO] attr2] [AS name] [UNI] [NOMSG]

   Where:

       set1  Are the data sets or collections to be joined.  The names
       set2  for set1 and set2 can be any form allowed for  DBSET  (name,
             file name, number, or alias).

       attr1 Is the attribute in the first data set used as a locator  to
             relate  the  data  sets.   It  must  be  keyed unless UNI is
             specified.  Any attribute descriptor may appear.

       attr2 Is the attribute the second data set used as a locator.  The
             default  for  attr2  is  attr1.   It  must  be  keyed.   Any
             attribute descriptor may appear.

       name  Is the unique name assigned to this join relation.  It  must
             begin with a letter and may not be a 1022 reserved word.  If
             no name is specified, 1022 names the join  relation  with  a
             unique number beginning at 10000.

       UNI   Specifies that the data  sets  are  joined  unidirectionally
             from  set1  to set2.  If UNI is not specified, the data sets
             are joined bidirectionally, from set1 to set2 and from  set2
             to set1.

       NOMSG Specifies that 1022 suppress the "More than 1 record  found"
             messages  for  one-to-many  maps.   If  more than one target
             record is selected, only the  first  one  is  used,  and  no
             warning is issued.

   For example, an employee data  base  includes  an  employee  data  set
   (EMPLOY)  and  a  spouse  data  set  (SPOUSE)  related  by an employee
   identification number attribute (EMPID) that appears in each data set.
   The  JOIN  command  allows you to print the names of each employee and
   his or her spouse easily.
   EXAMINING THE DATA BASE                                      Page 4-37
   Revision 4


   Example:

        * OPEN EMPLOY SPOUSE
        * JOIN EMPLOY TO SPOUSE VIA EMPID
        * FIND HIRE_DATE GE 1/1/83
        4 Recs Found
        * PRINT EMPID SURNAME SPOUSE.SURNAME
        73 Schmidt   Schmidt
        74 Johnson   Martinez
        75 Lee       Allison-Lee
        76 Harris

   This prints the surnames of the employees hired since the beginning of
   1983  and their spouses' surnames.  The PRINT command repeats a GETREC
   and MAP command for each record in the EMPLOY selection group.

   JOIN performs an implicit MAP when an attribute  is  referenced  in  a
   data  set  joined to the current data set.  If you change your current
   selection set or record, the selection set  in  the  joined  data  set
   remains unchanged until an attribute is referenced there.

   A single JOIN path is allowed between two data sets at any  time.   If
   EMPLOY  and  SPOUSE are joined via EMPID, an attempt to define another
   JOIN for these data sets, for example via  SURNAME,  yields  an  error
   message.   A  data set may be joined to more than one other set at any
   time.  For example, EMPLOY can be joined to  SPOUSE  and  CHILD.   The
   CLEAR JOIN command allows you to replace one JOIN path with another.

   JOIN paths must be explicitly defined.  If EMPLOY is joined to SPOUSE,
   and  SPOUSE is joined to CHILD, EMPLOY is not joined to CHILD by these
   paths.  You would need to explicitly join EMPLOY to CHILD.

   The JOIN command defines a join relation  as  part  of  the  data  set
   environment.   The  join  relation  so  established  can  then be used
   anywhere, including in following PL1022 and report programs.  The JOIN
   command  cannot itself be used conditionally and is not allowed within
   PL1022 or report programs.  See  the  ENABLE  JOIN  and  DISABLE  JOIN
   commands  for  ways to use a JOIN relation conditionally in PL1022 and
   reports.



   4.2.9.1  Multiple JOIN Matches

   In the preceding example we have one-to-one  mapping.   Each  employee
   has  at  most  one corresponding spouse record.  The JOIN command also
   allows many-to-one mapping where more than one record in  the  current
   data  set  relates  to  one record in the target data set.  So you can
   print a list of employees (one) and their children (many) with similar
   ease:
   EXAMINING THE DATA BASE                                      Page 4-38
   Revision 4


        * JOIN EMPLOY TO CHILD VIA EMPID
        * DBSET CHILD
        * FIND AGE GT 3
         6 Recs Found
        * PRINT EMPID EMPLOY.SURNAME CHILD.FIRSTNAME CHILD.SURNAME
        73 Schmidt   Klaus   Schmidt
        74 Johnson   Greg    Johnson
        74 Johnson   Alice   Johnson
        74 Johnson   Sally   Johnson
        75 Lee       Jane    Lee
        75 Lee       Ellen   Lee

   JOIN allows  one-to-one  and  many-to-one  mapping.   The  effects  of
   one-to-many  mapping  can  be achieved by making the data set with the
   many matching records the current data set.  In the example above, the
   command  DBSET CHILD makes CHILD the current data set.  If EMPLOY were
   the current data set, 1022 would issue a warning  when  you  gave  the
   PRINT  command.   One-to-many  mapping  can  also  be achieved through
   explicit MAP commands.  See "Joined Data Set Examples" below.

   JOIN does not allow  one-to-many  or  many-to-many  mapping  as  such.
   System  1022  issues a warning when one or more records in the current
   data set are related by the JOIN criteria to more than one  record  in
   the target data set.  The message is in the form:

        [More than 1 record found in JOIN attribute reference]
        [SYSID=18]

   The message gives the SYSID number for the source record with multiple
   matches in the target data set.  System 1022 will retrieve values from
   the first matching record after  printing  the  error  message.   When
   NOMSG is specified in the JOIN command, 1022 suppresses this message.



   4.2.9.2  CLEAR JOIN Command

   The CLEAR JOIN command removes JOIN definitions.  This allows  you  to
   join the data sets again using different locators.  The syntax is:

        CLEAR JOIN [J1]...[ [,] Jn]

   where J1 through Jn are join names.  If no names  are  specified,  the
   CLEAR JOIN command clears all joins.

   The CLEAR JOIN command, like the JOIN command,  establishes  the  data
   base  environment.  It cannot be used conditionally and is not allowed
   within PL1022 or report programs.  See the  ENABLE  JOIN  and  DISABLE
   JOIN commands for ways to use DISABLE JOIN as equivalent to CLEAR JOIN
   in such programs.
   EXAMINING THE DATA BASE                                      Page 4-39
   Revision 4


   4.2.9.3  ENABLE JOIN And DISABLE JOIN Commands

   The ENABLE JOIN and DISABLE JOIN commands turn on and  off  previously
   defined  JOIN  relations.   This  allows  flexibility  in  using  JOIN
   relations within PL1022 and report programs.

   The syntax is:

        ENABLE JOIN [J1]...[ [,] Jn]
        DISABLE JOIN [J1]...[ [,] Jn]

   where J1 through Jn are join names.  If  no  name  is  specified,  the
   ENABLE JOIN or DISABLE JOIN command enables or disables all joins.

   ENABLE JOIN and DISABLE JOIN execute at runtime.   They  can  be  used
   conditionally  and  may  be  included  in  PL1022 and report programs.
   Command files or an interactive user will use JOIN commands (and  OPEN
   commands)  before  the  beginning  of the program proper.  Then ENABLE
   JOIN and DISABLE JOIN commands turn on and off  those  JOIN  relations
   within the program.



   4.2.9.4  Simplified MAP Command With Joined Data Sets

   Some applications require  the  use  of  the  MAP  command  to  relate
   information  from  two  joined data sets.  Usually the same locator is
   used for the MAP as for the  join.   In  that  case,  you  can  use  a
   simplified  MAP  command  that  uses the same locator as the currently
   defined JOIN.  If the locators are not specified  in  the  usual  "VIA
   attr1 TO attr2" clause, the MAP command uses the locators specified by
   the join defined between the two data sets.

   For example:

        * JOIN EMPLOY TO CHILD VIA EMPID
        * FIND HIREDATE BET 1/1/82 2/1/82
         4 Recs Found
        * MAP TO CHILD
         6 Recs Found
        * PRINT EMPID EMPLOY.SURNAME CHILD.FIRSTNAME CHILD.SURNAME
        73 Schmidt   Klaus   Schmidt
        74 Johnson   Greg    Johnson
        74 Johnson   Alice   Johnson
        74 Johnson   Sally   Johnson
        75 Lee       Jane    Lee
        75 Lee       Ellen   Lee
        76 Harris

   The syntax for the simplified MAP is:

             MAP [TO] joined-data-set-name
   EXAMINING THE DATA BASE                                      Page 4-40
   Revision 4


   4.2.9.5  INFORM JOIN Command

   The INFORM JOIN command lists all the currently defined joins and  the
   join  names  or  numbers.   It  marks  disabled  joins.   (See "INFORM
   Commands" in the Special Commands chapter).



   4.2.9.6  Joined Data Set Examples

   Table lookups are done easily through JOIN.  Consider an example  with
   the following three sets:


             SET       ATTR-NAME            ABBREV
             ------    ---------            ------
             MACH:     MACH_CODE            MCODE<-|
                       PART_CODE            PCODE<-|--|
                       NUM_PARTS_REQUIRED          |  |
                                                   |  |
             MACNAM:   MACH_CODE            MCODE<-|  |
                       MACH_NAME            NAME      |
                                                      |
             PARNAM:   PART_CODE            PCODE<----|
                       PART_NAME            NAME

   The data sets have data on machines (a car and a bus) and their  parts
   (tires  and  rivets).   The  following shows values for each record in
   these data sets.

        MACH data set:

              MACH_CODE     PART_CODE              NUM_PARTS_REQUIRED

                  1           9000                            4
                  1           9001                         1000
                  2           9002                            6
                  2           9001                         3000


   PARNAM data set:

                            PART_CODE    PART_NAME

                              9000        Small tire
                              9001        Rivet
                              9002        Large tire


   EXAMINING THE DATA BASE                                      Page 4-41
   Revision 4


   MACNAM data set:

              MACH_CODE     MACH_NAME

                 1           CAR
                 2           BUS

   Each MACH_CODE entry in MACNAM  is  unique;   the  same  is  true  for
   PART_CODE in PARNAM.

   Note that the order that sets are specified in JOIN  commands  is  not
   important in the following examples since the link is bidirectional.



   4.2.9.6.1  EXAMPLE 1:  Table Lookup And Sort

   The following example uses JOIN for a table lookup and to  sort  using
   values in two data sets.  It prints part names required to build MCODE
   1 and 2.

        * OPEN MACH PARNAM
        * JOIN MACH TO PARNAM VIA PCODE ! Links MACH PART_CODE to
                                        ! PARNAM PART_NAME
        * DBSET MACH
        * FIND MCODE 1 2                ! Selects CAR and BUS in MACH
        4 RECS FOUND.
        * SORT MCODE PART_NAME          ! Sorts MACH by MACH and PARNAM
                                        ! values
        * PRINT MCODE PART_NAME         ! Prints from MACNAM and PARNAM
        1 Rivet
        1 Small tire
        2 Large tire
        2 Rivet

   SORT sorts values by looping  through  MACH  records  and  mapping  to
   PARNAM  for  each  PART_NAME.  The result is a selection group in MACH
   which is sorted by MCODE  and  PART_NAME.   The  PRINT  retrieves  and
   prints records in that order, mapping to PARNAM for PART_NAME.



   4.2.9.6.2  EXAMPLE 2:  Explicit MAP

   The following example uses three data  sets  for  table  lookups.   An
   explicit  MAP  command is one way to handle one-to-many mapping.  This
   prints the part names required to build MACH_NAME EQ CAR.

   EXAMINING THE DATA BASE                                      Page 4-42
   Revision 4


        * OPEN MACH PARNAM MACNAM
        * JOIN MACH TO PARNAM VIA PCODE ! Links MACH PART_CODE to
                                        ! PARNAM PART_NAME
        * JOIN MACH TO MACNAM VIA MCODE ! Links MACH MACH_CODE to
                                        ! MACNAM MACH_NAME
        * DBSET MACNAM
        * FIND NAME EQ CAR              ! Selects CAR in MACNAM
        FOUND.
        * MAP TO MACH                   ! Selects CAR parts in MACH
        2 RECS FOUND.
        * PRINT MACH_NAME PART_NAME     ! Prints from MACNAM and PARNAM
        CAR Small tire
        CAR Rivet

   An explicit one to many map (MACNAM to MACH) selects records  relating
   to the parts of interest.  PRINT cycles through MACH records, uses the
   join relation to select related PARNAM and  MACNAM  records  for  each
   MACH record, and prints the values of PART_NAME and MACH_NAME.



   4.2.10  COLLECT Command

   The COLLECT command groups one or more data sets  into  a  collection.
   System  1022  treats  a collection, in most respects, as a single data
   set containing all the records of the constituent data sets.   All  of
   the data sets in the collection must have the same structure and ADMIT
   protection.

   The syntax is:

              {set-1 ... [set-n] AS collection-name}
      COLLECT {                                    } [ADD set]
              {ALL [AS] collection-name            }

   Where:

   set-1 through set-n  Are data-set-descriptors of the open data sets to
                        group in the collection.  The data sets must have
                        identical structure and ADMIT protection.  A data
                        set  can be in only one collection at a time.  It
                        may  not  be  joined  to  another  data  set   or
                        collection when the COLLECT command is executed.

   collection-name      Is the collection name.  It may contain  letters,
                        numbers,  and the underscore character.  The name
                        must contain no more  than  25  characters.   The
                        collection name must be unique.  It may not match
                        the internal name, file name, or alias of an open
                        data set or another current collection.

   ALL                  Specifies that 1022 collect all  open  data  sets
                        into a single collection.
   EXAMINING THE DATA BASE                                      Page 4-43
   Revision 4


   ADD                  Specifies which data set records are added to  by
                        later  ADD  and  APPEND  commands.   By  default,
                        records are added to the last data set  named  in
                        the  COLLECT command.  This can be displayed with
                        the INFORM COLLECT command.


   Example:

        * OPEN JANSAL FEBSAL MARSAL
        * COLLECT ALL AS FIRSTQ
        * USE QUART.DMC
        * CLEAR COLLECT FIRSTQ

        The FIND, SEARCH, SELECT,  SORT,  CHANGE,  and  most  other  1022
        commands in the report program QUART.DMC use FIRSTQ exactly as if
        it were a  single  data  set.   The  structure  of  QUART.DMC  is
        typical;  we do not show it.

   COLLECT allows you to maintain separate data sets and then access them
   as  one  data  set  for  reports,  programs, or interactively.  In the
   preceding example, sales  records  are  kept  in  monthly  data  sets:
   JANSAL,  FEBSAL,  and MARSAL.  For a quarterly report, the identically
   structured monthly data sets are collected into FIRSTQ.  After running
   the report program QUART.DMC, the collection is cleared, and 1022 once
   again regards JANSAL, FEBSAL, and MARSAL as separate data sets.

   When you specify the COLLECT command, 1022 forms a collection  of  the
   specified  data  sets.  The sort order and selection conditions of the
   collected data sets are cleared.  The selection groups  in  each  data
   set  are  maintained,  so  the  selection  group  of  a  newly created
   collection includes all the records in the  selection  groups  of  the
   constituent  data  sets.   For  example,  if 5 records are selected in
   JANSAL, 4 records in FEBSAL, and 6 records in MARSAL when these  three
   data  sets  are  collected into FIRSTQ, the initial selection group of
   FIRSTQ is these 15 records of the constitutent selection groups.

   After a collection is made, selection groups  are  formed  within  the
   collection  just as they are formed in a data set:  with FIND, SEARCH,
   SELECT, MAP, and GETREC commands.

   Using collections also allows you to construct very large  data  sets.
   The  size  limits that apply to data sets do not apply to collections,
   so a collection can contain millions of records.



   4.2.10.1  Referencing Collections

   Collections are referenced by  name.   The  DBSET  command  makes  the
   specified collection or data set current.  The COLLECT command ends by
   making the specified collection current.  The OPEN command may not  be
   used to specify a collection.
   EXAMINING THE DATA BASE                                      Page 4-44
   Revision 4


   Data sets that are part of a collection can  only  be  referenced  and
   accessed  as  part of the collection.  The data sets are released from
   the collection and may be independently referenced and accessed  after
   you  give  a  CLEAR  COLLECT  command  (see  "CLEAR COLLECT Command").
   Exiting 1022 clears all collections.

   Example:

        * OPEN JANSAL FEBSAL MARSAL APRSAL MAYSAL JUNSAL JULSAL AUGSAL
        * COLLECT JANSAL FEBSAL MARSAL AS FIRSTQ
        * COLLECT APRSAL MAYSAL JUNSAL AS SECQ
        * DBSET FIRSTQ                           !FIRSTQ is current
        * DBSET AUGSAL                           !AUGSAL is current
        * OPEN NOCLOSE SEPSAL                    !SEPSAL is current
        * DBSET JANSAL
        ? (CS178) Reference to an element of a collection is illegal        _ _______ _________ __ __ _______ __ _ __________ __ _______
        DBSET JANSAL        _____ ______
        * INFORM COLLECT
        COLLECT JANSAL FEBSAL MARSAL as FIRSTQ ADD MARSAL.        _______ ______ ______ ______ __ ______ ___ _______
        COLLECT APRSAL MAYSAL JUNSAL as SECQ ADD JUNSAL.        _______ ______ ______ ______ __ ____ ___ _______

   See the INFORM command  in  the  Special  Commands  chapter  for  more
   information on INFORM COLLECT.

   Attributes  within  a  collection  may  be  referenced  by   attribute
   qualification  using  the  collection  name  just  as attributes in an
   uncollected data set may be referenced using the  data  set  name  and
   attribute name.

   Example:

        * PRINT DEPT SEPSAL.NET FIRSTQ.NET

        The  PRINT  command  displays  values  for  NET  from  both   the
        collection FIRSTQ and the data set SEPSAL.



   4.2.10.2  Differences Between A Collection And A Data Set

   System 1022 treats a collection like a data set in most respects,  but
   there are some differences:

        1.  SYSID is not a unique identifier in a collection.

        2.  Some 1022 commands cannot be used with a collection.

        3.  Joined data sets may not be collected,  although  collections
            may be joined.

   EXAMINING THE DATA BASE                                      Page 4-45
   Revision 4


   4.2.10.2.1  SYSID In Collections

   In a data set, SYSID is the unique internal  record  number  for  each
   record.   SYSID  is  unchanged  when  a  data  set  is  included  in a
   collection.  With more than one data set in a collection, you may have
   more than one record with the same SYSID.  MAP or JOIN via SYSID using
   a collection is not allowed.



   4.2.10.2.2  Commands Not Allowed With Collections

   The following 1022 commands are not allowed when  you  are  set  to  a
   collection:

        ALLOCATE            FIND FILE           SORT KEY
        ADMIT               KEY                 TRANSACT
        AUDIT commands      OPTIMIZE            UNKEY
        BACKTO              RELOCATE DATA       UPTO
                            SAVE                VALUES



   4.2.10.2.3  JOIN With Collections

   You may use JOIN to relate a collection to a data set  or  to  another
   collection.  However, you may not collect a data set that is joined to
   another data set by a JOIN command.  Procedures using collections  and
   JOIN  should collect data sets before using JOIN.  Since SYSID may not                                  ______
   be unique in a collection, you may not use SYSID as the locator  in  a
   JOIN command with a collection.

   Example:

        * COLLECT JANSAL FEBSAL MARSAL AS FIRSTQ
        * JOIN FIRSTQ APRSAL VIA DEPT

        These commands join the FIRSTQ collection to the APRSAL data  set
        using DEPT as the locator.



   4.2.11  CLEAR COLLECT Command

   The CLEAR COLLECT command releases data sets from collections  defined
   by the COLLECT command.  The syntax is:

        CLEAR COLLECT [collection-name-1] ...  [ [,] collection-name-n]

   Where:

   collection-names Are the names of the  collections  specified  in  the
                    COLLECT  command  and displayed by the INFORM COLLECT
   EXAMINING THE DATA BASE                                      Page 4-46
   Revision 4


                    command.  When no collection  name  is  specified  by
                    CLEAR  COLLECT, all currently defined collections are
                    cleared.

   CLEAR COLLECT does not alter the selection groups of  the  constituent
   data  sets.  The current data set after a CLEAR COLLECT command is the
   first constituent data set, if you were set to the collection when you
   gave  the  CLEAR  COLLECT  command.   Otherwise  the  current data set
   remains unchanged.



   4.3  DISPLAYING THE DATA

   The  commands  and  techniques  described  in  this  section   display
   information  from the records in the current selected group.  The data
   display commands are summarized below:



        PRINT     Directs output to the terminal or to a disk file.

        TYPE      Directs output to the terminal only.

        SORT      Sorts the selected records by attribute values  or
                  expressions,  in  either  ascending  or descending
                  order.

        SORT KEY  Sorts records by  the  value  of  a  single  keyed
                  attribute in ascending order only.

        VALUES    Prints the distribution  of  values  for  a  KEYED
                  attribute in the currently selected records.

        SPSS      Interfaces with the Statistical  Package  for  the
                  Social Sciences (SPSS).



   In addition,  the  user  may  display  totals  and  other  statistical
   information  about  the  record group.  In all cases the user controls
   the format and disposition of the output.

   A more complete discussion of output formatting and report  generation
   appears in Chapters 6 and 9 respectively.
   EXAMINING THE DATA BASE                                      Page 4-47
   Revision 4


   4.3.1  PRINT Command

   The PRINT command displays record values either to the terminal or  to
   a  disk  file.   It prints expressions formed from attribute values in
   the records being retrieved, general expressions, and also expressions
   containing attributes from other than the current data set.

   The PRINT command  displays  the  records  in  the  current  data  set
   selected  by  the  last  FIND,  SEARCH, SELECT, or MAP command.  Every
   record selected is retrieved and displayed by the PRINT  command.   In
   local  mode,  PRINT displays only the record last selected by a GETREC
   command.  For example:

        * FIND FN FRED        _
        3 RECS FOUND        _ ____ _____
        * PRINT FN LN AGE        _
        FRED      WILKINS    40        ____      _______    __
        FRED      BAILY      26        ____      _____      __
        FRED      MORRIS     48        ____      ______     __



   The form of the PRINT command is:

                    { file-descriptor }
        PRINT  [ ON {                 } ] [ print-list ] [ totals-list ]        _
                    { channel-#       }

   The form of the print-list is:

        item ... item FORMAT ----- END

   The form of the totals-list is:

        summary-function item ... summary-function item FORMAT ----- END


   For example:   PRINT FIRSTNAME LASTNAME AGE

                  PRINT ON NAMES.OUT FIRSTNAME LASTNAME AGE

                  PRINT ON 3 FIRSTNAME LASTNAME AGE

                  PRINT FIRSTNAME LASTNAME SALARY TOT SALARY


   The ON clause directs the output to a disk file specified  by  a  file
   descriptor,  or specified by a channel number that has been associated
   with a file with the INIT command.   If  the  ON  clause  is  omitted,
   output is sent to channel 1, to whatever file is assigned to channel 1
|  or to the terminal if no file  is  assigned.   The  PRINT  ON  command
|  directs  8-bit  ASCII output to a file that has been associated with a
|  channel with the INIT DIF command and directs 8-bit binary output to a
   EXAMINING THE DATA BASE                                      Page 4-48
   Revision 4


|  file  that  has  been  associated  with  a  channel  with the INIT 123
|  command.  A PRINT command must contain both the  ON  keyword  and  the
|  channel  number  specified in a preceding INIT DIF or INIT 123 command
|  to produce 8-bit output.  Otherwise, 1022 PRINT and PRINT ON  commands
|  produce 7-bit ASCII output.  (See the "System Output Channels" section
   of Chapter 2.)

   The exact operation of the PRINT command depends on the attributes  it
   references  and  on the number of records selected in the current data
   set.  The rules follow:

        1. The command prints once for  each  currently  selected  record
           when it references an attribute from the current data set.  It
           prints only once in Local mode.

        2. The command prints nothing and is completely ignored  when  it
           references  an  attribute  from the current data set and there
           are no records selected.

        3. The command  prints  once  when  it  does  not  reference  any
           attributes   from   the   current  data  set.   References  to
           attributes in other data sets do not change this behavior.

        4. References to attributes in other data sets are supplied from:

             a. In Local mode, the current record.
             b. In Global mode, the first record of the group.
             c. Null values if no record is selected.




   4.3.1.1  Print List

   The print list has the general form:

        [item ...  item [FORMAT----END]]

   The print-list is the keyword ALL and/or a  list  of  expressions  and
   attributes  which  are evaluated and printed for each record selected.
   The keyword ALL prints the value of each attribute in a record  as  if
   the user had typed the name of every attribute.

   Examples:

        PRINT ALL SYSID

        PRINT SALARY SALARY+BONUS NAME AGE

   Each expression is separated from the next one by at least  one  space
   or comma.  Spaces may be typed freely within and around expressions.

   The FORMAT clause is optional.  If it is omitted,  the  PRINT  command
   EXAMINING THE DATA BASE                                      Page 4-49
   Revision 4


|  uses  a  default  format to print all expressions and attributes.  For
|  7-bit ASCII files, this default format is:

        1. Each attribute value is followed by a space.

        2. TEXT values print in the full length of the item as  specified
           in  the  data  set;   the values are padded with blanks on the
           right, if necessary.

        3. INTEGER values print in the minimum number of spaces required.
           This means that a column of values may not align on the right.
           A minus sign precedes the value if it is  negative;   no  sign
           appears if it is positive.

        4. REAL  values  print  in  10  positions.    They   have   eight
           significant  digits,  with  decimal  point and preceding sign.
           The sign is "space" for plus and "-" for  minus.   Should  the
           value  be  too  large  or small to print in 10 positions, then
           scientific (E-field) notation is used.  The number prints as a
           preceding  sign,  decimal  point,  4  digit  fraction,  and  4
           character power of 10, like -.4368E+25 .

        5. DATE  VALUES  print  in  the  format  month/day/year,  as   in
           10/25/1984 .

|  The default formats for 8-bit files are described in Chapter  12.   If
   the  FORMAT  clause  is  included,  1022 follows the FORMAT exactly to
   print the data.  FORMAT gives you complete control over how  the  data
|  looks  on  the  output.   See  Chapter 6 and Chapter 12 for details on
|  PRINT format specifications.

   Examples:

        PRINT FNAME LNAME AGE CITY FORMAT 2A12 I5 2X A12 END

        The above command prints the following:

        JOHN        ABEL           30  MELROSE
        FRANK       ABRAMS         30  BEDFORD



   Elements of a print list can be literals, for example:

        PRINT "HOW ARE YOU" 3 6.7

        Prints:

        HOW ARE YOU 3 6.7000000

   EXAMINING THE DATA BASE                                      Page 4-50
   Revision 4


   4.3.1.2  The ALL Option

   The keyword ALL in  the  print-list  causes  the  values  of  all  the
   attributes in the data set description to be printed in the order they
   appear in the data set.  ALL stands for a list of all attribute  names
   in  the  record.   The  user  can  determine  the  names  and order of
   attributes in a PRINT ALL with the INFORM NAMES command.

   Example:  (Here, user input is underlined)

        * INFORM NAMES          ______ _____
        FIRSTNAME
        LAST_NAME
        AGE
        SEX
        SSN
        SCHOOL
        YEARS_ATTENDED
        SEMESTER_HOURS
        GRADE_POINT_AVERAGE
        DATE_OF_ENTRY
        GRADUATION_DATE
        DATE_OF_CHANGE
        * PRINT ALL          _____ ___
        MARK       JONES      45 M 100-10-1233 HOPKINS  2  80.850000
        1.6000000  9/07/1977  6/06/1980 11/09/1978
        ROGER      LEVINSON   41 M 100-10-1234 HOPKINS  0  .00000000
        2.2000000  9/07/1979  6/06/1982 11/09/1978
        LOUIS      MERZ       33 M 100-10-1235 CAL TECH 3  224.98000
        2.3000000  9/07/1976  6/06/1979 11/09/1978

   Use of ALL in the print-list does  not  exclude  use  of  any  or  all
   attribute names.  For example, PRINT ALL FN prints all attributes, and
   again prints FN (first name).

   The FORMAT clause for a print-list including ALL must contain a format
   for  every  attribute  in the proper order, as well as whatever format
   elements are required for other print-list items.

   The record identifier SYSID is not part of ALL, but can  be  specified
   separately.  For example:

        PRINT SYSID ALL

   EXAMINING THE DATA BASE                                      Page 4-51
   Revision 4


   4.3.1.3  Totals List

   The form of the totals-list is:

        [TOTALS] [summary-function] item ...  [summary-function] item

             [FORMAT ----- END]

   The totals-list prints just once after all selected records have  been
   processed  by  the print-list.  This allows the accumulation of totals
   and other functions which take  values  from  all  the  records.   The
   totals-list  need  not  be  only  functions,  but  it often is.  If it
   contains simple expressions (not in functions), they print  using  the
   values of the last record processed.

   The totals-list usually starts by default just  after  the  print-list
   format  clause,  or when the first function word is encountered.  This
   allows typing without confusion:

        PRINT LAST_NAME AGE TOT SALARY

   This prints the LAST_NAME and AGE from each record, and then the TOTAL
   SALARY  at  the  end.   The  print-list  is   LAST_NAME  AGE   and the
   totals-list is TOT SALARY.  If the totals-list is to start before  the
   first  function  is  encountered,  the  word  TOTALS  may be used as a
   separator, if no print-list format statement already acts as a default
   separator.

   Example:  PRINT LNAME AGE TOTALS SYSDATE TOT SALARY

   In this case, the totals line has today's date followed by  the  total
   SALARY.

   Sometimes the user wants only a totals line.  If  so,  leave  out  the
   print-list entirely, as in:

        PRINT TOT SALARY

        PRINT TOTALS SYSDATE TOT SALARY

   The quantities printed as totals are  not  at  all  related  to  those
   appearing in the print-list.  In particular, SALARY need not appear in
   the print-list to generate TOT SALARY in the totals-list.

   The totals-list functions may apply to expressions  by  following  the
   function  name by the expression to be evaluated.  They themselves may
   be combined into expressions.  (See Chapter 2, System Functions)

   The available summary-functions are:

        MIN    Prints the minimum attained value of the expression.

        MAX    Prints the maximum attained value of the expression.
   EXAMINING THE DATA BASE                                      Page 4-52
   Revision 4


        MEAN   Prints the mean value over all records of the expression.

        TOT    Prints the sum of the expression over all records.

        STDEV  Prints the standard deviation of the expression  over  all
               records.

   Example:

              PRINT NAME AGE SEX FORMAT A15 2X I5 2X A1 END -<RET>

              MIN AGE MAX AGE MEAN AGE TOT 1

   The last clause, TOT 1, prints the number of records in the  selection
   group.   The  print-list  has a user-supplied format;  the totals-list
   uses the default format.



   4.3.1.4  Printing And Totalling Real Values

   Attributes and expressions of type REAL usually do not store an  exact
   value for the values assigned to them.  Small integers and some simple
   fractions store exactly, but most decimals are  stored  with  a  value
   which   is   close  but  not  exact.   This  comes  from  the  machine
   representation for real numbers, and cannot be avoided.  The error  is
   at most 5/1,000,000,000 of the absolute value of the value stored.

   Real values are rounded when they  are  printed.   The  user  or  1022
   chooses  how  many  digits  of the value to print, and 1022 prints the
   best value it can in that number of digits.  Most users choose not  to
   print all digits of real fractions.  The error between what is printed
   and what is stored in the value is at most one-half  the  value  of  a
   number which has just a 1 in the last position printed.  For example:

        Print 45.6743287 in a field which prints 2 decimal positions.

        The result is 45.67 printed.  The difference between this printed
        result  and  the  stored  value  is  .0043287, which is less than
        one-half of 0.01 .

   Although the stored value of the number is very accurate, the  printed
   values  may  each differ from the stored value by significant amounts.
   If the user calculates bonuses by multiplication  of  a  factor  times
   salary  and  prints the results with two places for pennies, then each
   printed result may differ from the true value by one-half cent.

   The user sees the column of figures which are printed, but  1022  adds
   up  the  true  values  to  get a totalled result.  When there are many
   entries, the final result will almost always differ from  the  sum  of
   the  printed  results,  even  if  printed in the same way.  All of the
   half-pennies have their effect.
   EXAMINING THE DATA BASE                                      Page 4-53
   Revision 4


   Use integer values for totalling amounts when it is necessary that the
   sum  of the displayed amounts add up to the displayed total.  The user
   can base the values in integer attributes, or convert the real results
   of a computation into integer form for printing and totalling.

   For example:

        We wish to compute FACTOR  *  SALARY  to  derive  BONUS.   It  is
        sufficient  to  calculate  to  the  nearest  penny.  SALARY is in
        dollars;  FACTOR is a real value;  SALARY and BONUS are integers.

        LET BONUS EQUAL (FACTOR * SALARY * 100) + 0.5

        FACTOR * SALARY is a real quantity  in  fractions  of  a  dollar.
        Multiplying  by  100  makes  it a real quantity in fractions of a
        penny.  Adding 0.5 rounds the result up to the next higher  penny
        if  there  is at least half a penny left over.  The assignment of
        the result to the integer BONUS truncates any remaining fractions
        of a penny, to yield the integer number of pennies.  The user can
        print this number of pennies with the  proper  decimal  point  to
        indicate  dollar amounts.  Since the printed amounts are integer,
        the total of BONUS over all records will add and print exactly to
        match the printed column of figures.



   4.3.1.5  Pretotals

   Expressions made up of literals, variables and attributes  are  Simple
   Expressions.   They  have  a  value  which  is  generated immediately.
   Expressions made up of one or more totals functions  are  called  Pure
   Totals  Expressions.   Their value depends only on the entire group of
   records.   An  expression  which  is  made  up  of  both   independent
   attributes  and totals functions is a Mixed Totals Expression, and may
   have meaning independently for each record in a selected group.

   Example:

        Simple Expressions:        AGE

                                   SALARY+BONUS

        Pure Totals Expressions:   TOT SALARY

                                   (TOT BONUS)/(TOT SALARY)

        Mixed Totals Expressions:  100.0*SALARY/(TOT SALARY)
                                   (Salary as a percent of total salary)

                                   SALARY - (MEAN SALARY)
                                   (Variation of salary from the
                                   average -- Parentheses added
                                   for clarity)
   EXAMINING THE DATA BASE                                      Page 4-54
   Revision 4


   The most common use for a  mixed  totals  expression  is  to  print  a
   percentage on each print line for each record.  The expression:

        100.0*SALARY/TOT SALARY

   prints the percent SALARY of the total sum that the individual  SALARY
   represents, and does this for each record.

   The user includes Mixed Totals expressions in the main print list, and
   the  correct quantities print on each line.  System 1022 detects Mixed
   Totals expressions and does not prematurely  start  the  Totals  print
   list.   There  need not be a Totals print list in order to get correct
   results.

   1022 achieves the correct results by passing through the data once  in
   the  background  to  generate  the  required totals before the visible
   printing pass that displays the data.   This  is  called  pretotaling.
   See the EVALUATE command for another method of pretotaling.

   Example:

        * FIND SYSID LE 3        _
        3 RECS FOUND        _ ____ _____
        * PRINT FN SALARY 100*SALARY/TOT SALARY TOT SALARY        _
        ALFRED   15000 34        ______   _____ __
        JAMES    12000 27        _____    _____ __
        ERIKA    17000 38        _____    _____ __
        44000        _____
        *        _




   4.3.1.6  Output To Disk Files

   The PRINT command can direct output to the terminal, disk  files,  and
   to  spooled  devices  such  as  "LPT:".  These files are specified, by
   default, by a file descriptor, or by  a  1022  output  channel  number
   assigned  through  the  INIT  command  (see  Chapter  2, System Output
   Channels).

   The simplest way to write an output file is to use  a  file-descriptor
   in the ON clause.  For example:

        PRINT ON NAMES.LST FNAME LNAME

   This sets up a correspondence between the output  file  NAMES.LST  and
   output  channel  1.   A previous file by the same name is overwritten,
   not extended, by ON <filename>.  It is equivalent to

        INIT 1 NAMES.LST
        PRINT FNAME LNAME
   EXAMINING THE DATA BASE                                      Page 4-55
   Revision 4


|  Remember that PRINT ON must be  followed  by  an  appropriate  channel
|  number if 8-bit output is desired.  A PRINT ON <filename> command to a
|  pre-existing 8-bit file simply overwrites it in 7-bit ASCII, rendering
|  it unusable.  If an output device is specified in an ON clause without
   a file name, the PRINT command uses  a  file  named  PR1022  with  the
   user's  job number as an extension.  For example, PRINT ON DSK:  FNAME
   LNAME, sets up  a  correspondence  between  channel  1  and  the  file
   PR1022.025, assuming the user's job number is 25.

   A PRINT command without the ON clause directs its output to  the  file
   associated with channel 1.  If no file has been established, output is
   to the terminal.

   Once an output file is set up on channel 1, later PRINT commands  send
   output  to that file, provided the ON clause is not used and channel 1
   is not released or reassigned.  For example:

        * FIND AGE BET 30 40        _
        10 RECS FOUND        _____________
        * PRINT ON NAMES.LST FNAME LNAME        _
        * FIND AGE BET 41 50        _
        25 RECS FOUND        _____________
        * PRINT FNAME LNAME        _

   Output is sent to the file until one  of  the  following  commands  is
   issued:

        PRINT ON <file-descriptor>
        INIT 1 <file-descriptor>
        RELEASE 1
        QUIT

   The disk file is closed when the channel is released or reassigned, or
   when another ON <file-descriptor> clause is used.


   Be careful not to mistakenly overwrite a previous file by using the ON
   <file-descriptor> clause.  For example:

        * FIND AGE BET 30 40        _
        400 RECS FOUND        ______________
        * PRINT ON NAMES.LST FNAME LNAME        _
        * FIND AGE BET 41 50        _
        25 RECS FOUND        _____________
        * PRINT ON NAMES.LST FNAME LNAME        _

   In this example  the  second  PRINT  command  reinitializes  the  file
   NAME.LST, superseding the data first printed.


   Giving a channel number in an ON clause directs the output to  a  file
   already  INITed  to  that  channel;   the  file  is  appended  to, not
   overwritten.  The INIT command associates a file with a channel number
   EXAMINING THE DATA BASE                                      Page 4-56
   Revision 4


   from  1  to  8.   An  error prints if no file has been associated to a
   channel when the ON <channel> clause refers to that channel.

   Example:

        * INIT 3 OUT.DAT
        * PRINT ON 3 FNAME LNAME
        * PRINT ON 3 TOT SALARY

        Both outputs go to the file OUT.DAT.

   Channel 1 is special because it is the default channel  for  both  the
   PRINT  and TYPE commands.  Output is done to channels 2 to 8 only when
   they are referenced by the ON clause  of  a  PRINT  statement.   Files
   associated  with  all  channels  are closed only when the channels are
   released or reassigned, or when a QUIT command leaves 1022.



   4.3.2  TYPE COMMAND

   The TYPE command acts like the PRINT command, except  that  output  is
   sent only to the user's terminal.  The form of the command is:

        TYPE <output list>

   The ON clause is not allowed, since output is always directed  to  the
   terminal.   TYPE  respects  the  conventions set up for channel 1 when
   that channel is associated with the user's terminal.  Such conventions
   are headings, footings, and page lengths.

   When channel 1 is INITed to a file, TYPE uses an independent  path  to
   the  terminal  which does not affect any channels, and does not affect
   page or line counts maintained by  other  channels  connected  to  the
   terminal.  This independent path has default channel conventions.



   4.3.3  SORT Command

   The SORT command arranges into order any  group  of  selected  records
   (previously selected by FIND, SEARCH, SELECT, or MAP) so that commands
   will produce reports or output in that order.  The form of the command
   is:

        SORT [<options>] [BY] <expression> [<sequence-descriptor>]

             [ [BY] <expression> [<sequence-descriptor>] ] ...

   Example:

        SORT BY INPUT_DATE LAST_NAME
   EXAMINING THE DATA BASE                                      Page 4-57
   Revision 4


   The SORT command handles any number of records.  But the  user  should
   not  do sorts larger than necessary due to the relatively large amount
   of time used during sorting.  The user should sort only  the  data  he
   intends  to  print or process, after selecting that subset of the data
   set.

   The SORT command does not physically rearrange  records  in  the  data
   set;   rather it logically orders the selected records so that records
   are subsequently retrieved or processed in that sorted order.

   The word BY in the SORT command is optional.  The command contains  up
   to 20 sorting clauses, in the form:

        <expression>  [ <sequence-descriptor> ]

   The expression is usually a single attribute  name,  but  can  be  any
   expression if the sorting situation merits it.

   Example:  SORT BY SALARY+BONUS LNAME FNAME

        This sorts the records into order by total compensation, which is
        the sum SALARY+BONUS, then by name.

   The <sequence-descriptor> is one of the following:

        ASCENDING
        DESCENDING
        UP
        DOWN

   These keywords specify the sort order  for  the  previous  expression.
   ASCENDING  and  UP  both  mean  values  are  sorted  from low to high;
   DESCENDING and DOWN mean that values are  sorted  from  high  to  low.
   Expressions  are  sorted  ascending,  from low to high values, when no
   <sequence-descriptor> appears.

   The expressions are considered for sorting in the  order  given.   The
   records  are ordered based on the values of the first expression.  For
   equal values of the first expression, they  appear  in  order  on  the
   second  expression.   For  equal  values of the first and second, they
   appear in order on the third expression, and so on.

   Example:

        SORT AGE ASCENDING NAME ASCENDING RANK DESCENDING
        is the same as
        SORT AGE NAME RANK DESCENDING
        or
        SORT BY AGE NAME RANK DOWN


   EXAMINING THE DATA BASE                                      Page 4-58
   Revision 4


   The SORT command has additional options:

   CORE n --  This specifies the SORT buffer size (defaulted to 5K).  "n"
   must be greater than or equal to 3.

   USING <file-structure> -- This specifies a scratch file-structure  for
   the sort routine.

   Example:  SORT USING DSKC CORE 20 AGE SEX NAME

   Each of the above options, if used, appears before any attribute names
   in  the  SORT  list.  Scratch file-structures and more than 5K of sort
   buffer are only useful for very large sorts,  usually  for  more  than
   10,000 records.

   You can control whether the sort buffer is allocated  and  deallocated
   for  each  sort  by  setting  the  system  variable  SYSKEEPBUF.  When
   SYSKEEPBUF is 0, 1022 allocates a buffer for the temporary sort files,
   sorts the data, and then frees the buffer.  When SYSKEEPBUF is 1, 1022
   allocates a buffer, sorts the data, then retains the  buffer  for  the
   next  sort.   This  reduces  the  overhead  of repeatedly allocating a
   buffer at the cost of having more memory allocated between sorts.   If
   you  set  SYSKEEPBUF  to 1 for a series of sorts, reset it to 0 before                                                                   ______
   the last sort of the series to deallocate the buffer.

   A SORT command in local mode sorts the entire selection group, returns
   to local mode, and selects the first record.



   4.3.3.1  SORT Scratch Device

   The system variable SYSSCRDEV specifies the default scratch device for
   commands that use a scratch file structure, like SORT and DUMP SORTED.
   The standard default is DSK.  You may specify any device name of up to
   6 characters.  The colon is not required in SYSSCRDEV.

   Example:

        LET SYSSCRDEV "DSKC"

        This makes the device DSKC: the scratch device.
|  
|  TOPS-20 users can now distribute the temporary  files  used  during  a
|  SORT  over  multiple  structures.   To do this, you define SORT22 as a
|  list of structures (or logical names) with the TOPS-20 DEFINE command,
|  and  then  you can either include the clause USING SORT22 in your SORT
|  or KEY command or set the system variable SYSSCRDEV to SORT22 with the
|  command
|  
|       LET SYSSCRDEV "SORT22"
|  
|  The temporary files used by the sorter will then be  distributed  over
   EXAMINING THE DATA BASE                                      Page 4-59
   Revision 4


|  the list defined by SORT22.
|  
|  By default, the scratch space for sorting will be  allocated  on  each
|  device   listed   in   the  definition  of  SORT22  in  the  directory
|  corresponding to your connected directory.  If  you  wish  to  specify
|  some other directory, you can do so by defining SORT22 as X:  and then
|  defining X:  as the device plus the directory.  For example,
|  
|       DEFINE SORT22:  X:,Y:,Z:
|       DEFINE X:  PS:<JONES>,SP:<TEMP>,SP:<HOLD>
|  
|  The same effect can be achieved  on  TOPS-10  by  running  the  SETSRC
|  program  before  doing  a  SORT  (for which the default is USING DSK).
|  This will cause 1022 to distribute the temporary  files  used  by  the
|  sorter  over  the  structures in the active portion of the disk search
|  list established by SETSRC.



   4.3.4  SORT KEY  Command

   SORT KEY is a special form of the 1022  sort  function  which  quickly
   sorts on a single keyed attribute field.  The form of the command is:

        SORT KEY <keyed-attribute-name>

   The records are always sorted in ascending order,  and  the  CORE  and
   USING  options are not permitted.  Only one sort field is allowed, and
   it must be a KEYED  attribute.   SORT  KEY  uses  sorting  information
   stored  in  the  key  tables for that attribute, giving very efficient
   sorting on one field.  However, the regular SORT  command  is  usually
   faster  if  fewer  than  15%  of the records in the data set are being
   sorted.


   Examples:

        SORT KEY ACCT_NO
        SORT KEY INVOICE_DATE
        SORT KEY SOCSECNUM



   4.3.5  VALUES Command

   The VALUES command displays information about the  value  distribution
   of  a  keyed attribute.  Options display the range of included values,
   the number of records having each value, and the corresponding SYSIDs.
   The form of the command is:

        VALUES [ON <file-descriptor>] <attribute>

               [VALUES] [COUNT] [SYSID] [COLUMN]
   EXAMINING THE DATA BASE                                      Page 4-60
   Revision 4


   Data is displayed for just the currently selected records.   The  data
   appears in ascending order sorted by the values of the attribute.

   To write the information to a disk file, the ON clause may be included
   with  an output file descriptor.  Use of this feature does not involve
   any of the assignable System output channels.

   The following keywords control the content and format of the listing:


        VALUES - Generates  a  list  of  each  different  value  of   the        ___
                 attribute within the selected group of records.

        COUNT  - Prints a count for each value of the  attribute  showing        ___
                 how many records have that value.

        SYSID  - Produces a list of SYSIDs  for  the  selected  group  of        ___
                 records.   The  SYSIDs  identify records in sorted order
                 according to the named attribute.

                 No lengthy sorting is done, since data already generated
                 by  the  keying is used.  Therefore, the output from the
                 SYSID option may be read by a FORTRAN or COBOL  program,
                 and  the  records  retrieved  in  sorted  order  without
                 spending extra computer resources  on  a  SORT  command.
                 However,  this  is  the same efficiency found when using
                 the SORT KEY command.

        COLUMN - Causes the output for each record to be complete on  one        ___
                 line with the following format:

                      [VALUE] [SYSID] [COUNT]

|                where  SYSID  and  COUNT  each  take  up  nine   columns
|                separated  by  a space.  The length of VALUE varies with
|                the attribute type.  The lengths are:
|  
|                     INTEGER         12
|                     REAL            14
|                     DATE            8
|                     DOUBLE INTEGER  24
|                     DOUBLE REAL     24
|                     TEXT            The length specified in the DMD
|                                       file.
|  
|                Numeric values are right-justified.  VALUE  is  followed
                 by a space.

                 COUNT is zero, except for one line at  the  end  of  the
                 lines  for  each  value.  That line has a zero SYSID and
                 the count for the preceding value.

   The above options may be used in any  combination.   If  none  of  the
   EXAMINING THE DATA BASE                                      Page 4-61
   Revision 4


   options  appear  in  the command, then System 1022 provides the VALUES
   and COUNT options by default.  The options may be abbreviated  to  the
   first 3 characters.


   Examples:

   * FIND AGE BETWEEN 20 AND 24
   37 RECS FOUND
   * VALUES AGE

      20 (13)
      21 (4)
      22 (8)
      23 (3)
      24 (9)

      This indicates 13 records with AGE equal to 20, 4 records with  AGE
      equal to 21, etc.


   * FIND AGE BETWEEN 22 AND 23
   11 RECS FOUND
   * VALUES AGE VALUES SYSID

      22      [VALUE]
       12     [SYSIDS]
       29     .
       134    .
       142    .
       148
       170
       174
       203
      23      [VALUE]
       37     [SYSIDS]
       125
       211

      The [...] comments do not appear in output.

   * FIND AGE BETWEEN 30 AND 31
   8 RECS FOUND
   EXAMINING THE DATA BASE                                      Page 4-62
   Revision 4


   * VALUES AGE VALUES SYSID COUNT COLUMN
                30     26      0    [VALUE   SYSID]
                30     71      0      .
                30    114      0      .
                30      0      3    [VALUE   COUNT]
                31     35      0    [VALUE   SYSID]
                31     38      0      .
                31    137      0      .
                31    164      0      .
                31    196      0
                31      0      5    [VALUE   COUNT]



   4.3.6  SPSS Command

   The SPSS command produces files to be analyzed with SPSS  (Statistical
   Package for the Social Sciences).  The SPSS command is described below
   in detail.  Consult the documentation describing SPSS, distributed  by
   SPSS  Inc.,  for  a  complete description of what the System 1022 SPSS
   command accomplishes.  SPSS is a trademark of SPSS Inc., Chicago.



   4.3.6.1  SPSS Input

   The SPSS user builds an SPSS system file and then performs statistical
   analyses  on  it.   The SPSS system file corresponds closely to a 1022
   bundled DMS file.

   The SPSS system file contains  information  about  the  name  of  each
   variable  ("variable"  translates  to  "attribute");   a label for the
   variable (these labels  are  like  the  1022  unabbreviated  attribute
   names);   the values which represent missing data;  and the details of
   the SPSS subfile structure (described  below).   This  information  is
   stored in a binary format which SPSS understands.

   The data to be analyzed is stored case by case in an SPSS system  file
   (in  1022,  "record by record").  An SPSS system file contains heading
   information describing the format of the data in the  cases,  followed
   by the cases themselves.
   EXAMINING THE DATA BASE                                      Page 4-63
   Revision 4


   4.3.6.2  SPSS Subfiles

   SPSS can process many subfiles of a given set of data.  A subfile is a
   subset  of  all  the  cases.  For example, if data is collected on the
   subject "Vacation Choices Among Computer Programmers", then  the  data
   set  contains  information  on all programmers in the study.  A useful
   subfile might be "Male Programmers," or "Programmers Older  than  40".
   In each case, the subfile is a subset of all of the data collected.

   The subfile structure is also described in the heading information  of
   the SPSS system file, and each subfile has a different name, much like
   a data set name.  Any number of subfiles  are  appended  to  a  system
   file, or previous subfiles, for analysis as a separate group.

   "Subfile"  is an  SPSS concept.  Refer to  the SPSS manual for further
   description.



   4.3.6.3  Function Of The SPSS Command

   The 1022 SPSS command produces SPSS system files with the  information
   needed  to  perform  analyses.   Extra information not provided by the
   SPSS command, such as value labels  and  missing  values,  are  easily
   inserted later with the SPSS program.

   The SPSS command produces  a  system  file  containing  the  following
   information for each variable (attribute):

        1.  File Name - The file name for the SPSS system file is set  to
            the  name  specified  in  the  FILE  clause  (see below).  No
            extension is used.  The text description of the file  is  set
            to:  "From System 1022 data set:<data set descriptor>".

        2.  Variable Name - The variable name is  set  to  the  attribute
            abbreviation,  if one exists, or to the first five characters
            of the attribute name if no abbreviation has been provided in
            the DMD file.

        3.  Variable Label - The  variable  label  is  set  to  the  full
            attribute name with underscores replaced by spaces.

        4.  Number of Cases - The number of cases for a subfile is set to
            the  number  of  records in the current selection group.  The
            SPSS command prints an error message if in Local mode  or  if
            no records are selected.

        5.  Missing Values - Missing value information is  provided  only
            for attributes which are protected from being displayed.  The
            command writes a null value (blanks  for  text  data,  0  for
            numeric  data) and sets the missing value for the variable to
            be that null value.  Thus, SPSS  reads  that  value  in  that
            subfile as a missing value for the statistical operations.
   EXAMINING THE DATA BASE                                      Page 4-64
   Revision 4


   Other options in the command select all or  some  attributes;   create
   subfiles;   and create variable names of the form "VAR00, VAR01, ...,"
   which are often used with SPSS.  The command operates without external
   command files or descriptions, making it fast and easy to use.



   4.3.6.4  SPSS Command Format

   The SPSS command has the format:

        SPSS FILE <filename> [SUBFILE <filename>] [option(s)]

   The options available are:

             ATTRIBUTES att-1 att-2 att-3 ... att-n
             NOTEXT
             INFORM
             VARNUM
             CASWGT <expression>
             GO [USING <command-string>]

   The functions of the command and options are:

        1.  If no SUBFILE clause is given, create a new (or supersede  an
            old) SPSS system file with the name given in the FILE clause.
            The subfile name will be the same as the file name.

            The SUBFILE clause creates a subfile with the specified  name
            in  the  pre-existing  SPSS system file specified in the FILE
            clause.

            If the specified system file does not  exist,  create  a  new
            system file with one subfile of that name.

        2.  The ATTRIBUTES clause  creates  an  SPSS  system  file  which
            includes  the  named  attributes as variables, in that order.
            When omitted,  create  the  file  or  subfile  with  all  the
            attributes  in  the  order  they  appear in the data set (see
            Chapter 7, Displaying Data base Characteristics).

        3.  The NOTEXT keyword excludes text  attributes  from  the  SPSS
            system  file.   Display numerics are not excluded.  NOTEXT is
            ignored if an ATTRIBUTES clause appears.

        4.  The INFORM  keyword  displays  information  on  the  terminal
            showing  the  variables  created,  their  names,  and labels.
            Otherwise, no messages print on the terminal.

        5.  The VARNUM keyword assigns the SPSS variable names the values
            VARnn  where  nn  corresponds  to  the sequence number of the
            variable as placed into the system file.  This  replaces  the
            default  SPSS  variable  name,  which  is  the 1022 attribute
   EXAMINING THE DATA BASE                                      Page 4-65
   Revision 4


            abbreviation.  The SPSS variable label  remains  set  to  the
            full 1022 attribute name.

        6.  CASWGT sets the value of the special SPSS  internal  variable
            CASWGT to the value of the expression specified in the CASWGT
            clause.  The CASWGT variable acts as a  weighting  factor  in
            some analyses.


        7.  No action is taken beyond writing the SPSS file when  the  GO
            option  is  omitted.  The user runs SPSS later to analyze the
            data in the SPSS System file.

            The  GO  option  runs  the  SPSS  program  immediately  after
            completing  the  file operations of the command.  System 1022
            runs the SPSS program "SYS:SPSS".

            SPSS is run with the following default SPSS command  when  no
            USING clause appears:

                <name>.OUT=<name>.SPS,<name>/GET

            where <name> is the file name given in the FILE clause of the
            System  1022 command.  The user must prepare the SPSS Control
            File, <name>.SPS, ahead of time with a text  editor,  to  use
            the GO option.

            The user may also  prepare  his  SPSS  Control  File  with  a
            sequence of 1022 PRINT commands.  These PRINT commands can be
            part of a larger procedure in a 1022 command file that places
            value label information, extracted from other 1022 data sets,
            into the SPSS Control File.

            If the USING clause is included, SPSS is run  with  the  SPSS
            command supplied with the USING clause.

   The following example shows the SPSS  command  used  with  the  INFORM
   option.  The command lines starting with "*" are lines the user types.
   In this example, 1022 output is not underlined.


        * O NAMES
        * F SEX M AND AGE BET 20 30
        101 RECS FOUND.
        * SPSS FILE MALES INFORM
        System 1022 SPSS Interface

        File:<JOHN>MALES
        Subfile MALES   with 101 cases

   EXAMINING THE DATA BASE                                      Page 4-66
   Revision 4


        Creating Variables:

        NAME            LABEL
        ----            -----
        FN              FIRST NAME
        LN              LAST NAME
        AGE             AGE
        S               SEX
        SSN             SSN
        INST            SCHOOL
        YA              YEARS ATTENDED
        SH              SEMESTER HOURS
        GPA             GPA
        DOE             DOE
        DOG             DOG
        DOC             DOC














                                 CHAPTER 5

                           UPDATING THE DATA BASE



   5.1  BASIC UPDATE COMMANDS

   The commands in this section are:

   ADD           Adds a new record to the data set.   _

   CHANGE        Changes the values of attributes within record.   _

   DELETE        Removes records from the data set.   ______

   UNDELETE      Reactivates deleted records.   _____



   5.1.1  CHANGE Command

   The CHANGE command changes the values of attributes using  a  list  of
   attributes  and associated expressions which hold the new values.  The
   command is:

        CHANGE <attribute> <expression> [<attribute> <expression>] ...

   CHANGE evaluates  each  expression  and  assigns  the  result  to  the
   preceding  attribute.  The data type of the expression is converted to
   agree with the attribute, if necessary.

   All currently selected records are changed by  one  execution  of  the
   CHANGE command.  Only the current record is changed in local mode.

   Expressions may  be  used  to  supply  values  for  the  changes.   An
   expression  that  contains attributes is evaluated for each record and
   uses the attribute values from that record.  A systematic  change  can
   be made to all records in a group in this way.

   Expressions are evaluated and attributes  are  changed  from  left  to
   right.   An  attribute  which  is  changed  has  its  new  value  when
   referenced farther to the right in another expression.

   A change to a keyed attribute automatically  updates  the  keys.   The
   UPDATING THE DATA BASE                                        Page 5-2
   Revision 4


   record is immediately retrievable using its new values.

   Examples:

        (1)  CHANGE STREET "54 MYRTLE" CITY BOSTON ZIP 02114

        (2)  CHANGE VALUE 12*13.87  INSURANCE VALUE*.003

        (3)  CHANGE SALARY SALARY*1.1, VACDAYS 15

   (1) is a typical change to one record.  STREET, CITY, and ZIP  receive
   the  new  values  "54  MYRTLE",  "BOSTON", and "02114".  The value for
   STREET is enclosed in quotes because it contains a space.   The  value
   for  CITY  contains no spaces and does not need quotes to represent it
   in a CHANGE command.

|  Note that if you are not using UPDATE ON or record-level  locking,  it
|  is  possible  for another user to change a record between the time you
|  select it with the GETREC command and the time  you  give  the  CHANGE
|  command.   When  this happens, your CHANGE command is ignored.  System
|  1022 gives a warning.  The setting of the system  variable  SYSTRAPUP3
|  determines   whether   1022   then  continues  or  terminates  program
|  execution.  To avoid this situation, you can either use UPDATE  ON  or
|  record-level  locking,  or  you  can  print  the  value  of the system
|  variable SYSCHANGED before you give the CHANGE command (see  "Multiple
|  Access of a Data Set" below).

   (2) illustrates expressions.  This command would usually be used on  a
   single  record.   The  expressions are convenient for representing the
   desired values, although the values could have been typed as  numbers.
   This  CHANGE  assigns  the  VALUE for a carton of some product costing
   $13.87 each, and the resulting INSURANCE payment of 0.3% of the  value
   of  the  case.   Assignments  are done left-to-right, giving VALUE the
   proper value for use in the expression for INSURANCE.

   (3) illustrates a CHANGE to a group of records.  It raises  the  value
   of  SALARY  by  10%  and  resets  vacation days to 15.  The expression
   SALARY*1.1 is evaluated for each record in the group just  before  the
   assignment is made to SALARY;  thus the CHANGE is different and proper
   for each selected record.




   5.1.2  DELETE Command

   The DELETE command deletes the  current  group  of  selected  records.
   DELETEd  records  are  still  present  in  the data set, but cannot be
   selected by FIND commands.  The DELETE command  has  no  abbreviation;
   it must be typed in full, because one DELETE can delete an entire data
   set if all of the records are selected.

   Example:
   UPDATING THE DATA BASE                                        Page 5-3
   Revision 4


        * FIND AGE EQ 30        _
        10 RECS FOUND        __ ____ _____
        * DELETE        _
        * FIND AGE 30        _
        NOT FOUND        ___ _____

        This deletes all selected records, here, all persons who  are  30
        years old.

   In Global mode, all selected records are  deleted  and  the  selection
   group is cleared.

   In Local mode, the current record is  deleted  and  replaced  by  null
   values  of  zeroes  or  blanks.   The  next  GETREC retrieves the next
   record.

   A DELETE (or DROP) command does not change the numbering of records in
   a  group  so  long  as  GETREC commands, direct or sequential, proceed
   forward in the group order.  A STARTREC or  FIND  LAST  command  or  a
   direct  GETREC  command to a record earlier in the group than the last
   selected record  causes  the  group  numbering  to  reflect  only  the
   remaining records, the ones not deleted.

   If a DELETE command is given by mistake on a group of already  deleted
   records  (located  with  a DFIND command), its only effect is to clear
   the current selection group.  The records in the group  are  undamaged
   and remain deleted.

   Note the following:

        1. The SYSIDs of deleted records are not reused for new data  set
           records.

        2. The space occupied by deleted  records  is  not  reclaimed  by
           1022.   The  only  way  to  reclaim  this space is to DUMP the
           active records to a new data set and then use  this  new  data
           set (see DUMP Command, Creation Chapter).

        3. Deleted records are counted in the number of  records  allowed
           in  a  data  set.   For  example, if your data set has 200,000
           active records and 50,000 deleted records, you cannot  add  or
|          append more than 12,143 records, unless your site has licensed
|          the Large Data Sets Module.  In this case, you  could  add  or
|          append  up  to  133,750,000  records.  Determine the number of
           active and deleted records with the INFORM STATUS command.

        4. Deleting a record does not update a DATE OF  CHANGE  attribute
           within the record.
|  
|       5. If you are not using UPDATE ON or record-level locking, it  is
|          possible  for another user to change a record between the time
|          you select it with the GETREC command and the  time  you  give
|          the  DELETE  command.  When this happens, 1022 gives a warning
   UPDATING THE DATA BASE                                        Page 5-4
   Revision 4


|          and, if SYSTRAPUP3 is set to 1, an error message.  Your DELETE
|          command  is  then  ignored.   To avoid this situation, you can
|          either use UPDATE ON or record-level locking, or you can print
|          the  value  of  the system variable SYSCHANGED before you give
|          the DELETE command  (see  "Multiple  Access  of  a  Data  Set"
|          below).



   5.1.3  UNDELETE Command

   The UNDELETE command reactivates deleted records selected with  DFIND.
   DFIND acts only on deleted records; it has no effect on active records
   retrieved with FIND.  When used on a group of records  (global  mode),
   all  records  in the group are undeleted and become active again, with
   the result that no records remain selected.  When used in local  mode,
   the  current record is undeleted and removed from the current group of
   deleted records.

   Undeleted records must be selected using FIND in order to process them
   further.

   If UNDELETE is used by mistake on active records,  the  active  status
   remains the same, but the selection group is cleared.

        * DFIND AGE EQ 30     !Find deleted records        _
        20 RECS FOUND        __ ____ _____
        * UNDELETE        _
        * FIND LAST           !The selection group is clear        _
        NOT FOUND        ___ _____
        * DFIND AGE EQ 30     !The records are now active        _
        NOT FOUND        ___ _____




   5.1.4  ADD Command

   The ADD command adds a new record to the data set.  One  form  of  the
   command is a complete list of attribute names (or abbreviations), each
   one followed by a value or expression.  Attributes in the current data
   set may not be used as values.  The syntax is:

        ADD <attribute> <expression> [<attribute> <expression> ] ...

   Example:  ADD NAME ARNOLD JOB PLUMBER AGE 30
   UPDATING THE DATA BASE                                        Page 5-5
   Revision 4


   If some of the attribute names are missing in the  ADD  command,  1022
   prompts for the required missing attribute values.  Thus, the user can
   type:

        ADD

   and 1022 requests the values for each attribute.  The interactive form
   of the ADD command ignores trailing blanks.

   Example:

        *ADD NAME ARNOLD JOB PLUMBER AGE 30

        SUPPLY OTHER ATTRS        __________________

        SEX-- M        _____
        HGT-- 5-10        _____
             .
             .
             .


   The above command adds a new record with values ARNOLD,  PLUMBER,  and
   30.   1022 asks for the omitted values of SEX, HEIGHT, and others.  On
   each interactive line, the user can type a value,  or  type  <RET>  to
   enter a null value, or type NUL to enter null values for all remaining
   attributes in the record.  A null value is blanks for text and  0  for
   numeric  attributes.   If  an  illegal  value  is  entered  during the
   interactive sequence, 1022 gives an error message and allows the  user
   to  type  a legal value.  If NUL or <RET> is used to enter a nul value
   for an attribute with a specified range of greater than zero to  N,  a
   warning is displayed but the command is not aborted.

   Normally  1022  prompts  for  additional  values  by  using  attribute
   abbreviations where they exist.  If the user issues the command:

        LET SYSADDMSG 1

   1022 prompts with the full attribute name.

   System 1022 interprets literally  the  responses  to  the  interactive
   prompts.   Do  not type numeric expressions or attribute names, and do
   not enclose text in quotes; the  input  is  treated  as  a  string  of
   characters.   Spaces  in text strings are permitted without quotes and
   cause no confusion.  Trailing blanks are ignored.

   The keyword NUL can be used in the ADD command to give  the  remaining
   attributes  null  values  (blanks  for  text attributes, 0 for numeric
   attributes).

   Example:  ADD NAME JOHN AGE 42 NUL

   In the above example, the attribute NAME takes  the  value  JOHN,  AGE
   UPDATING THE DATA BASE                                        Page 5-6
   Revision 4


   takes the value 42, and all other attributes take null values.

   The ADD command sets the record just added as  the  current  selection
   group,  ending  the  effect of any previous record selection commands.
   If the ADD is aborted with #Z, the original  selection  group  remains
   unchanged.



   5.1.5  UPTO Command

   The UPTO command transforms the  current  data  set  from  an  earlier
   version format to a later version format.  It improves 1022 efficiency
   to change data sets built under versions earlier  than  116  with  the
   UPTO  command.   The  INFORM STATUS command displays the version under
   which a data set was built.  The syntax is:

        UPTO n

   Where n is the integer version number.

   Example:

        * OPEN FILMS
        * UPTO 116

   Here, the FILMS data set built in version 115 is  transformed  into  a
   116  data  set,  just as if it had been built under version 116.  This
   transformation can be reversed with the BACKTO command.
   UPDATING THE DATA BASE                                        Page 5-7
   Revision 4


   5.1.6  BACKTO Command

   The BACKTO command transforms  the  current  data  set  from  a  later
   version format to an earlier version format.  The syntax is:

        BACKTO n

   Where n is the integer version number.

   The BACKTO command makes data sets built under version 116 or later of
   1022 compatible with earlier versions of 1022.

   Example:

        * OPEN FILMS
        * BACKTO 115

   In this example, the FILMS data set in 116 format is transformed  into
   a 115 data set, just as if it had been built under version 115.



   5.2  PROCEDURES FOR LARGE-SCALE UPDATES

   A single update to  a  data  set  causes  the  following  sequence  of
   actions:

        1. Open the data set file for writing.

        2. Allocate additional disk space if needed.

        3. Update record values.

        4. Change key table entries for keyed attributes.

        5. Close the data set following the update.

   System 1022 need not execute all these actions for  each  update  when
   many  updates are done together.  The update commands are ADD, CHANGE,
   and DELETE.  The  following  commands  reduce  overhead  for  multiple
   updates:



      UPDATE ON      Keeps the data set open for writing.

      UPDATE OFF     Closes the data set following updates.

      UPDATE PREVENT Prevents updates to the data  set.   (ENQ  data
                     sets only).

      UPDATE ALLOW   Turns off UPDATE PREVENT.
   UPDATING THE DATA BASE                                        Page 5-8
   Revision 4


      ALLOCATE       Assigns additional disk space for records to be
                     added to the data set.

      KEY            Builds  a  new  key  table  for  one  or   more
                     attributes.

      UNKEY          Removes a key table from an attribute.

      OPTIMIZE       Reformats key tables.

      SET BUFFER     Assigns additional I/O buffers  (see  the  "SET
                     Command" section of Chapter 7).
|  
|     SET SCRATCH    Allows  the  user  to  specify  the  number  of
|                    buffers  to  be  used  by the scratch file that
|                    1022 routinely  creates  for  the  session  for
|                    building  selection sets (see the "SET Command"
|                    section of Chapter 7).

      APPEND         Performs  an   operation   similar   to   LOAD,
                     appending  records  from  an input data file or
                     data set to an existing data set.

      TRANSACT       Performs  multiple  changes  and  additions  by
                     reading from an input data file or data set.





   5.2.1  UPDATE Command

   The UPDATE command controls update access to  the  current  data  set.
|  (Access  to  individual  records  can  be  controlled  by record-level
|  locking, which is described at the end of this chapter.)   The  UPDATE
   command has the format:

               { [ON]    }
        UPDATE { OFF     }
               { PREVENT }
               { ALLOW   }

   UPDATE ON causes the current data set to be opened  for  writing,  and
   remain  open  until  the  user types UPDATE OFF, types CLOSE, or exits
   from 1022 with QUIT  or  EXIT.   Other  users  of  the  data  set  are
   prevented from doing updates to it.  These users may continue to query
   the data set.  Use the UPDATE ON command whenever  a  long  series  of
   updates is made.  A data set is in update mode when UPDATE ON controls
   access to it.
   UPDATING THE DATA BASE                                       Page 5-8A
   Revision 4


   When UPDATE ON is not used, each change to the data set opens the data
   set  for  writing,  makes  the  change,  and then closes the data set.
   Enclosing a sequence of updates  between  UPDATE  ON  and  UPDATE  OFF
   eliminates the multiple opens and closes.

   A second effect of UPDATE ON further increases efficiency.  Data areas
   are  kept  in machine memory during update mode from one change to the
   next.  Changes to the same areas do not  require  reading  them  again
   from  the disk.  This buffering of data may eliminate many accesses to
   the disk which would otherwise occur.

   The proper use of UPDATE ON is:

        DBSET <data set>
        UPDATE ON
           .
           .
        ADD, CHANGE, DELETE commands (more than one)
           .
           .
        UPDATE OFF

   Never abort from 1022 with Control-C while  update  mode  is  on;  new
   information is not written to disk and the data set file is damaged.

   UPDATE PREVENT prevents update to  the  data  set.   It  prevents  all
   updates,  even  by the user who gives the command.  This is useful for
   reports and programs that require that no changes be made in the  data
   set as they run.  All users may query the data set.  Unlike UPDATE ON,
   UPDATE PREVENT can be applied by many users at  the  same  time.   The
   update-in-progress  flag,  set  by  UPDATE  ON,  is  not set by UPDATE
   PREVENT, so a data set can be "frozen" and copied easily.

   UPDATE PREVENT works only for ENQ data sets  (see  "Queue  for  Update
   Access" on ENQ).

   UPDATE ALLOW turns off an UPDATE PREVENT command.  Updates and  UPDATE
   ON are then allowed.

   Any UPDATE command applies to the  current  data  set  or  collection.
   DBSET to each data set in turn, and issue an UPDATE command to set the
   update mode in many data sets.  A QUIT or EXIT command turns  off  all
   updating as a normal part of leaving 1022.

   If a data set is one member of a multiple data set file,  then  UPDATE
   for  any  member data set applies to the whole file.  Do not, however,
   rely on this mode of operation.  The lockout may  become  specific  to
   the single data set in future versions of 1022.
   UPDATING THE DATA BASE                                       Page 5-8B
   Revision 4


   5.2.2  The ALLOCATE Command

   The ALLOCATE command increases later retrieval  efficiency  when  many
   records are added to the data set.  The format of the command is:

        ALLOCATE <n>        ___

   Unlike the ALLOCATE statement that may used in a TOPS-10 DMD  file  to
   reserve  blocks for the output data set file, the interactive ALLOCATE
   command reserves room in the data set file for <n> additional  records
   and  may  be  used  on  both  TOPS-10  and TOPS-20.  <n> is a positive
   integer.
   UPDATING THE DATA BASE                                        Page 5-9
   Revision 4


   It is not necessary to issue the ALLOCATE  command  in  order  to  add
   records  to  the data set or to plan later additions, and space in the
   data set is in no way  limited  by  the  parameter  specified  in  the
   command:   1022  will automatically make room for added records as the
   need arises.  The advantage of using the ALLOCATE command is  that  it
   can  make  for  a less fragmented data set when many records are to be
   added at once.



   5.2.3  Purpose Of The KEY And UNKEY Commands

   Fast record selection in the FIND command is done  by  using  the  key
   tables  for  KEYED attributes.  These key tables are usually generated
   when the data set is loaded.  Unkeyed attributes do not have these key
   tables,  so  slower sequential search techniques in the SEARCH command
   must be used to select records based on unkeyed attributes.

   The KEY and UNKEY commands generate  and  remove  key  tables  for  an
   attribute,  at any time, regardless of what is specified at load time.
   The KEY command rebuilds key tables that have been damaged by  machine
   crashes, as well as building keys for previously unkeyed attributes.

   The UNKEY command  deletes  an  attribute's  key  table.   An  unkeyed
   attribute requires less overhead in CHANGE and ADD commands.  Thus, it
   is sometimes efficient to UNKEY  an  attribute  before  applying  many
   changes  to  it, if it is not needed for retrieval during the changes.
   KEY the attributes again after changes are complete.   "Many  changes"
   means  updating  more than about 20% of the records in the data set on
   that attribute value.

   A KEY or UNKEY cannot execute correctly  if  the  data  set  is  being
   updated  when  the  command  is  issued.  Do not use either command if
   other users are relying on that key at that time.



   5.2.4  KEY Command

   (See also the "Purpose of the KEY and UNKEY Commands" above.)

   The KEY command has the form:

        KEY [NOMSG] [USING <str>] [BUFFER <n>] <attribute-list>

   Where:

   NOMSG               Suppresses all non-error messages to the terminal.

   USING <str>         Uses the specified disk  structure  as  a  scratch
                       device   for  sorting.   No  ":"  appears  in  the
                       structure name.
   UPDATING THE DATA BASE                                       Page 5-10
   Revision 4


   BUFFER <n>          Specifies the number of I/O  buffers  per  channel
                       for  the key rebuilding operation.  The default is
                       2.  A larger number speeds up  the  execution,  at
                       the cost of running the job with more core.

   <attribute-list>    Is the list of attributes for which new key tables
                       are generated.


   Each entry in the attribute list has the form:

                              { [REUSE] } { <attribute-name> }
        [NULL <n>] [CORE <n>] {         } {                  }
                              { NOREUSE } {   ALL            }

   Each of the optional clauses turns on a  condition  which  remains  in
   effect throughout the attribute list until changed.  The options are:

   NULL <n>  <n> is an integer between 0 and 50.  It is the percentage of
             the  total  key  table space which remains empty to hold new
             values on later  changes  and  additions.   A  large  number
             increases disk space for the key tables but reduces overhead
             on later changes.  The default is 6.  Use larger values only
             when  later changes will be frequent.  Use 0 when no changes
             will occur in this key.

   CORE <n>  <n> is the number of 1K core blocks to use for sorting while
             keying  this  attribute.  The default is 5.  A larger number
             speeds the keying operation, but the job runs in more core.

   REUSE     This specifies that the key  builder  will  reuse  the  disk
             blocks  occupied  by  the  previous key tables (if any).  If
             this  results  in  the  message  "?FILE DAMAGED",  then  the
             command  should  be  given  again  with  the NOREUSE option.
             REUSE is the default.

   NOREUSE   This specifies not to reuse the disk blocks occupied by  the
             old  key  tables.  New disk space is allocated at the end of
             the file.

   <attribute-name> - This is the attribute name or abbreviation.  If the
             keyword  ALL appears in place of the attribute name, then it
             refers to all  keyed  attributes,  or  attributes  that  are
             marked as "KEYED INACTIVE" (see UNKEY command), except those
             attributes which are named earlier  in  the  attribute-list.
             The  word ALL is the last entry in the list when it appears.
             Text attributes of length greater than 80 characters  cannot
             be keyed.


   UPDATING THE DATA BASE                                       Page 5-11
   Revision 4


   Examples:

        KEY LAST_NAME

             This builds a key table for LAST_NAME.

        KEY BUFFER 5 LAST_NAME

             5 buffers are used rather than 2.

        KEY NOMSG ALL

             No informational messages are printed.

        KEY USING DSKB REUSE LASTNAME NOREUSE ALL

             The attribute LAST_NAME is keyed with the REUSE option,
             after which all other keyed attributes are rekeyed with
             the NOREUSE option in effect.  If the word ALL  appears
             in the attribute-list, it is the last entry.

        KEY SEX CORE 15 SOCSECNUM

             A  larger  sorting  buffer  is   used   for   attribute
             SOCSECNUM.   Attribute  SEX  is  keyed with the default
             sort buffer of 5K.

        KEY NULL 30 QTY_ON_HAND

             A higher NULL factor is given for  an  attribute  which
             will change values frequently.



   5.2.5  UNKEY Command

   (See also "The Purpose of the KEY and UNKEY Commands" above.)

   The UNKEY command has the form:

        UNKEY <attribute-list>

   Where:

   <attribute-list>  - Is a list  of  attributes  whose  key  tables  are
                       erased.  Each entry in this list has the form:

                    { [REUSE] }   { <attribute-name> }
                    { NOREUSE }   {                  }
                    { REMOVE  }   { ALL              }

   Each optional keyword turns on a condition  which  remains  in  effect
   throughout the attribute list until set again.
   UPDATING THE DATA BASE                                       Page 5-12
   Revision 4


   The options are:

   REUSE     The disk blocks occupied by the old key tables are marked as
             reusable.   This  is the default setting.  After erasing the
             key tables the attribute becomes KEYED INACTIVE.

   NOREUSE   The disk blocks occupied by the old key tables are marked as
             unreusable.  The attribute becomes KEYED INACTIVE.

   REMOVE    This is the same as NOREUSE, except the attribute  does  not
             become  KEYED  INACTIVE.   It  becomes an unkeyed attribute.
             This does not mean it may not  be  KEYED  again  later.   It
             means that it does not meet the "ALL" condition in a KEY ALL
             command (see the KEY command).

   <attribute-name> - This is the attribute name or abbreviation.  If the
             keyword  ALL appears in place of the attribute-name, then it
             refers to all  keyed  attributes,  except  those  attributes
             named earlier in the attribute-list.

   Examples:

        UNKEY LASTNAME

        UNKEY NOREUSE TOWN,DIVISIONUM,SUBDIVISIONUM

        UNKEY REMOVE AGE REUSE ALL

             Attribute AGE is unkeyed and will not key automatically
             under  the keyword ALL.  All other keyed attributes are
             unkeyed and become KEYED INACTIVE.


   The following example illustrates how the KEY and UNKEY commands  make
   a large update of a data set more efficient:

        UNKEY ALL
         .
         .
        [CHANGE and ADD commands]
         .
         .
        KEY ALL

   Before the updates are executed  all  keyed  attributes  are  unkeyed;
   then  new  key tables are generated for these attributes when updating
   is done.  This eliminates the overhead of changing the key tables  for
   each update.

   Since the rekeying operation following the updates takes CPU and  disk
   resources,  this procedure does not always save time.  Use it only for
   keys where the value will change for more than 20% of the records.
   UPDATING THE DATA BASE                                       Page 5-13
   Revision 4


   5.2.6  OPTIMIZE Command

   The OPTIMIZE command reformats a key table.  This reformat  is  almost
   never  needed;  the  key  tables  do  not degrade in efficiency due to
   updates or additions.  However, two conditions call for its use.

   First, once a value is placed into a key table it is not deleted, even
   when  no  records  have that value.  The OPTIMIZE command removes this
   value, and reclaims space for the key.

   Second, reformatting a key table to  include  more  null  space  makes
   later changes efficient.  This is a good choice when the key cannot be
   deleted during updating.  (See the discussion on null  space  in  "The
   KEY Command" above.)

   The form of the command is:

        OPTIMIZE [NOMSG] <attribute-list>        ___

   The optional  keyword  NOMSG  suppresses  non-error  messages  to  the
   terminal during the reformatting operation.

   Each entry in the attribute-list has the form:

                   { <attribute-name> }
        [NULL <n>] {                  }
                   { ALL              }

   NULL <n>  <n> specifies the percentage of the total  key  table  space
             which  will remain empty to hold new values on later changes
             and additions.  This is the same as in the KEY command.   If
             it is omitted, the default is 6.

   <attribute-name> - This is the attribute name or abbreviation.  If the
             keyword  ALL  appears in place of an attribute name, then it
             refers to all  keyed  attributes,  except  those  attributes
             appearing earlier in the attribute-list.


   The OPTIMIZE command differs from the KEY  command  in  two  important
   respects.   First,  the  OPTIMIZE command cannot rebuild damaged keys;
   it only works on attributes which have sound key tables.  For the same
   reason, the OPTIMIZE command can not key an attribute which is unkeyed
   or KEYED INACTIVE.  Second, OPTIMIZE takes much less time than KEY.


   Examples:

        OPTIMIZE AGE FIRST_NAME
        OPTIMIZE NOMSG SOCSECNUM
        OPTIMIZE NULL 20 ACCT_NO NULL 50 ALL
   UPDATING THE DATA BASE                                       Page 5-14
   Revision 4


   5.2.7  APPEND Command

   The APPEND command is an efficient way to add batches of records to  a
   data set.  The new records are read from a data file or data set.

   The APPEND command is more efficient than the ADD command for adding a
   group  of  records  to  a  data  set.  The ADD command updates the key
   tables after each record is added;  the APPEND command defers updating
   the  key  tables  until all the data records have been appended to the
   data set, and all key changes are done together.

   The new records are described to 1022 in one of the following ways:

        1.  When a data  set  is  the  source  of  data,  the  format  is
            described  by  the  source  data set structure.  The data set
            must be OPEN, with the desired records selected.

        2.  When a data file is the source  of  data  and  no  additional
            information  is  given, the format is described by the master
            data set structure, the same format used to  LOAD  or  CREATE
            the master data set.

        3.  When a data file is the source of data,  a  System  1022  DMD
            file can describe the format.


   In cases 1 and 3 above, the records to append need not have  the  same
   description  or  field ordering as the master data set.  The attribute
   fields  in  the  master  data  set  are  filled  with  data  from  the
   corresponding  fields in the input data having the same full attribute
   name.  For a complete description of this see the  section  "The  DESC
   Clause" below.

   The form of the command is:

               { DATA <file-descriptor-1> [DESC <file-descriptor-2>] }
        APPEND {                                                     }        ___
               { SET <data set-descriptor>                           }

|              [NOMSG] [NODME] [CUSTDMI]  [LRECL <option>]

               [FORMFEED <option>] [CORE <n>] [BUFFER <n>]

   Where:

   <file-descriptor-1>   Is the name  of  the  DMI  file  containing  the
                         records to be appended.

   <data set-descriptor>  Is the name or number  of  the  open  data  set
                         containing the records to be appended.

   <file-descriptor-2>   Is the name of the DMD file giving the structure
                         of the DATA file.
   UPDATING THE DATA BASE                                       Page 5-15
   Revision 4


   BUFFER <n>            <n> is the number of buffers to be used in  I/O.
                         The default is 2.

   CORE <n>              <n> is the number of 1024 word core segments  to
                         use for sorting, if keying is done.  The default
                         is 5.

   NOMSG                 Turns off the system APPEND messages.

|  NODME                 Suppresses the creation of an error (DME)  file.
|                        If  errors  are detected during the execution of
|                        the command, they are written to the terminal.
|  
|  CUSTDMI               Allows the user to append records in nonstandard
|                        format  from  a host language program containing
|                        the DBLODR call.
|  
|  LRECL                 Specifies the logical record size of  the  input
|                        data.
|  
|  FORMFEED <option>     Specifies the treatment of  form  feeds  in  the
|                        data file.

   The APPEND command is a self-contained module;  no prior  ALLOCATE  or
   SET BUFFER command is needed.

   To APPEND from an ISAM data file, CREATE the file as a 1022  data  set
   and APPEND that data set.


   The defaults are:

        DATA     The extension defaults to DMI.
        SET      The extension defaults to DMS.
        BUFFERS  2
        CORE     5
        DESC     The  same  as  the  currently  open  data  set  if   not
                 specified.  The extension defaults to DMD.

   Examples:

        1.  OPEN TEST
            APPEND DATA PARTS DESC BAR

            This example reads the data file PARTS.DMI according  to  the
            format  specified  in  BAR.DMD  and  APPENDs  the  records to
            TEST.DMS.  Attributes in  BAR  which  are  not  in  TEST  are
            ignored.   The  APPENDed  records  have  a null value in each
            attribute of TEST with no corresponding field in BAR.
   UPDATING THE DATA BASE                                       Page 5-16
   Revision 4


        2.  OPEN TEST
            APPEND DATA PARTS

            This is the same as example 1 except PARTS is read  according
            to the same description used to LOAD or CREATE TEST.DMS.


        3.  OPEN TEST NEW
            FIND SYSID LE 10
            DBSET 2
            APPEND SET 1

            This example appends the first 10 records  in  TEST  to  NEW.
            APPEND SET TEST would have the same effect in the example.


        4.  OPEN TEST
            APPEND DATA PARTS BUFFER 8 CORE 12

            This uses 8 buffers per channel for  I/O  and  allocates  12K
            core  for  the  sorting.   Setting buffers and core increases
            efficiency for very large appends.


        5.  OPEN TEST
            APPEND DATA PARTS NOMSG FORMFEED IGNORE

            This prints no system messages and ignores all  formfeeds  in
            PARTS.DMI.


        6.  OPEN TEST
            APPEND DATA PARTS LRECL 10 DESC BAR

            The LRECL specified  overrides  any  LRECL  contained  in  or
            computed  from  BAR.DMD.   LRECL  is ignored if the APPEND is
            done from a data set.

   UPDATING THE DATA BASE                                      Page 5-16A
   Revision 4


   5.2.7.1  The DESC Clause

   Several 1022 commands may include a  DESC  clause.   The  DESC  clause
   controls  the  format of data sets and data files created by 1022, and
   specifies formats for records which are input to 1022.

   The DESC clause names a System 1022 data description file in  commands
   such  as  APPEND,  TRANSACT, LOAD, and CREATE.  In the LOAD and CREATE
   commands, this file describes the input data file  and  the  resulting
   data  set  description.   In  the  APPEND  and  TRANSACT  commands, it
   describes an input data file for processing against a master data set.

   A description file gives a name and data type to the  fields  in  data
   records.  In most cases, 1022 compares this description to an existing
   data set description, the structure of the current  master  data  set.
   The  fields  and  attributes are matched according to their full names
   (abbreviations are ignored) to determine how to apply the  input  data
   against  the attributes of the master data set.  A master attribute is
   filled with data from a matching data field.

   Data fields in the input record are ignored if they  do  not  match  a
   master  attribute.   Attributes in the master record are filled with a
   null value if they do not match a data field.

   UPDATING THE DATA BASE                                      Page 5-16B
   Revision 4



























                     [ This page intentionally left blank ]
   UPDATING THE DATA BASE                                       Page 5-17
   Revision 4


   The following rules tell how a data field is applied to  an  attribute
   in the master data set:

   1. The source data field is  converted  to  the  type  of  the  master
      attribute  before being applied to it.  If this is not possible, an
      error message prints.

   2. Text data is truncated on the right if it is written to  a  smaller
      Text master attribute.  No warnings are printed when this occurs.

   3. There may be a RANGE on an integer attribute in  a  bundled  master
      data set.  If the source data is too large for this range, an error
      message prints and the value zero is used.


   For example, consider the following master data set structure,  and  a
   data file UPD.DAT with its description file UPD.DMD.

   The master data set PEOPLE.DMS has the structure:

        ATTRIBUTE FIRST_NAME TEXT    LENGTH 10
        ATTRIBUTE LAST_NAME  TEXT    LENGTH 10
        ATTRIBUTE AGE        INTEGER LENGTH  2 RANGE 0 80
        ATTRIBUTE NO_CARS    INTEGER LENGTH  1

   The data file UPD.DAT has the description UPD.DMD:

        ATTRIBUTE FIRST_NAME TEXT    LENGTH 12
        ATTRIBUTE LAST_NAME  TEXT    LENGTH 12
        ATTRIBUTE AGE        INTEGER LENGTH  2
        ATTRIBUTE SEQ_NUMBER INTEGER LENGTH  4

   If the following commands are given,

        OPEN PEOPLE
        APPEND DATA UPD.DAT DESC UPD.DMD

   then for each line of data in the data file UPD.DAT, a record is added
   to  the  data  set PEOPLE.  The attributes FIRST_NAME and LAST_NAME in
   PEOPLE are filled from the same named fields in  UPD.DAT.   Since  the
   fields  in  UPD.DAT are longer, they are truncated to 10 characters of
   text to fit the matching attributes in PEOPLE.

   The AGE in UPD.DAT in each record fills the AGE attribute  in  PEOPLE.
   If  a  value  is  too  large to fit the range of 0 to 80 in PEOPLE, an
   error message results  for  that  record,  and  a  value  of  zero  is
   inserted.

   The attribute NO_CARS in PEOPLE has no  associated  field,  so  it  is
   filled  with the null value of 0 in each record.  The field SEQ_NUMBER
   in UPD.DAT does not correspond  to  any  attribute  field,  so  it  is
   ignored on input.
   UPDATING THE DATA BASE                                       Page 5-18
   Revision 4


   5.2.8  TRANSACT Command

   The TRANSACT command performs changes and additions  to  a  data  set,
   using  data  in records supplied by the user.  The changes are made to
   the current data set, called the MASTER  data  set.   The  transaction
   records,  called TRANSACTIONS, are supplied in another data set, or in
   a data file.



   5.2.8.1  Introduction

   Large data sets often require large  amounts  of  updating.   The  new
   information may be accumulated in files as it is received, rather than
   applied to the data set.  Later, the changes are made in a group.

   The changes to be made are contained in the fields of the  transaction
   records.  A transaction is an ordinary record, with fields, and values
   in those fields.  Each value becomes a new value for an  attribute  in
   the master data set, or adds to the value of an attribute.

   The transaction records may have any format described in a  DMD  file,
   or  may  be  in  another data set.  Whatever the format, a transaction
   field applies to the master field with the same full attribute name as
   that of the transaction field (abbreviations are not used).

   The  TRANSACT  command  reads  sequentially  through  the  transaction
   records,  matches the transactions to the master records, and performs
   an action depending on the result of each matching operation.   UPDATE
   is on automatically while the TRANSACT command executes.

   Transactions ordinarily match at least  one  master  record.   Options
   control what is done when more than one are selected, or when none are
   selected.

   Changes are not the only actions which are possible  in  the  TRANSACT
   command.   Master  records may be added, deleted or unchanged based on
   the success or failure of the matching process.

   The transaction record contains two pieces  of  information  that  are
   necessary to change a master record:

     1. The changes to be made.
     2. The identity of the master record(s) to change.

   The changes to be made are the  values  of  the  data  fields  in  the
   transaction.  Those values update matching fields in the master record
   after the master  is  located.   Ordinarily,  every  master  field  is
   changed  which has an associated transaction field.  An option ignores
   all transaction fields which are blank, using only the non-null values
   from the transaction.

   TRANSACT locates master records  for  each  transaction  record.   The
   UPDATING THE DATA BASE                                       Page 5-19
   Revision 4


   LOCATOR field(s) in the transaction record give this information.  The
   locator values are matched against the master records  to  select  the
   master  records  which  will  be  changed.  This is done in one of two
   ways.

     1. The locators are KEYED fields in the master  data  set  and  1022
        uses an automatic FIND command to select the masters.

     2. Both the master and transaction records are sorted into ascending
        order   by   their  locator  values.   Then,  each  is  processed
        sequentially  by  collating   them   on   the   locator   values.
        Transactions  in  groups  are matched to masters in groups by the
        collation.  This does not rely on keyed fields in the master data
        set.



   5.2.8.2  Introductory Example Of Transact

   The following example of a TRANSACT  operation  is  presented  without
   indicating  how to specify this operation.  This will make clearer the
   detailed description to follow.

   The master data  set  is  ACCT.DMS,  containing  the  savings  account
   balance  of  the  customers  of  a  bank.   Each day, the deposits and
   withdrawals of bank customers are processed against  the  accounts  to
   update  them.   The  transactions  are in a data file DAY.DAT, and are
   sorted by account number, as is the master data set.



             ACCT.DMS                      DAY.DAT

   ACCTNO    NAME    BALANCE         ACCTNO    BALANCE    (seq no)
   ------    ----    -------         ------    -------
      101    FRED    1000.00 <----\-----101     300.00       1
      102    MIKE    2000.00       \----101     -50.00       2
      103    MARY    3000.00 <----------103    -200.00       3
                                        105      80.00       4

   The full attribute names in DAY.DAT are chosen to be identical to  the
   full  attribute  names  in  ACCT.DMS.   BALANCE  in  DAY.DAT  is not a
   balance, but the amount which was deposited by the  customer  in  that
   transaction, or withdrawn if the amount is negative.

   The transactions are matched by ACCTNO, which is the locator  for  the
   transactions.   The  description  for DAY.DAT must say that BALANCE in
   DAY.DAT is an ADDITIVE attribute, so that it adds  to,  and  does  not
   replace, the BALANCE attribute in ACCT.DMS.

   The sequence number column does not appear in the transactions, but is
   for  our reference.  The first transaction applies to account 101, and
   adds 300.00 to it.  The second transaction also applies  to  101,  and
   UPDATING THE DATA BASE                                       Page 5-20
   Revision 4


   subtracts 50.00.  This is a case of multiple transactions for the same
   locator, and could trigger special action  in  the  transactions.   In
   this case, we want all transactions to be applied.  In other cases, we
   might choose only the first or last to apply, or even call  this  case
   an error.

   The next transaction locates account 103, so 102 is skipped.

   The last transaction calls for account  105,  which  does  not  exist.
   This  is  an  "unapplied"  transaction  because  it  matches no master
   records.  It is an error in a banking example to  have  a  transaction
   for   a   nonexistent  account,  so  we  can  specify  that  unapplied
   transactions are errors.  In other situations we might  create  a  new
   record in the master data set to hold the unapplied data.



   5.2.8.3  Supplying Transaction Records

   Supplying transaction records is similar to supplying records  to  the
   APPEND  command.   See  both  APPEND  and  "The DESC Clause" above for
   details.

   Transactions records are supplied to TRANSACT in the following ways:

   1. Transactions are supplied in a data file, with the DATA clause.

      A. The file format.

         It is described by the DMD file named in the DESC  clause,  when
            it has a format different from the master data set.

      B. The group of transaction records.

         All records in a data file become transactions.  There is no way
         to select a subset.  They are processed in file order.

   2. Transactions are supplied in a data set, with the SET clause.

      A. The file format.

         It is determined from the internal description of the data  set.
         No DESC clause is needed or allowed.

         An unbundled data set is a data set,  and  needs  no  additional
         DESC clause.

      B. The group of transaction records.

         The selected records of the transaction data set become
   UPDATING THE DATA BASE                                       Page 5-21
   Revision 4


         transactions.  Any command which identifies records may be used,
         including SELECT.  Any imposed sort order is used.



   5.2.8.4  Applying Transaction Fields


   Fields in the transaction records apply only  to  master  fields  with
   identical  full  attribute  names.   Abbreviations do not count in the
   matching.  This is exactly the same as in the APPEND command, above.

   Transaction fields replace the  corresponding  fields  in  the  master
   record,  unless  the transaction description (DMD) describes the field
   as ADDITIVE.



   5.2.8.5  Locating Master Records

   The TRANSACT command locates matching master records on which to apply
   the  transactions.   The LOCATOR fields in the transaction records are
   matched against the same named attributes in the masters.  This can be
   done  directly  with  background FIND commands, or by collating sorted
   transactions against sorted master records.

   1. Transaction locators may be matched directly, by default.  This  is
      called "Direct Mode".

      A. How this is done.

         1- Transaction records are read one at a time.

         2- The values in the locator field(s) are used in  an  automatic
            FIND  command to select master records.  The selected records
            match the transaction record in each locator field.

            Example 1:  LOCATOR ACCT

               The background command is:

                  FIND ACCT <acct-value>

               for each transaction record.

            Example 2:  LOCATOR ACCT SEQUENCE

               The background command is:

                  FIND ACCT <acct-value> AND SEQUENCE <sequence value>

               for each transaction record.
   UPDATING THE DATA BASE                                       Page 5-22
   Revision 4


         3- The located master records are considered in data set  order,
            without additional sorting.

      B. Data set Preparation

         1- Transaction Records.

            a. Locators in transaction records  are  not  special.   They
               need not be keyed.
            b. Sort order is respected in the transaction records, but no
               particular order is necessary.

         2- Master Records.

            a. Locators must be KEYED in master records.
            b. Sort order is ignored in the master records.  If more than
               one is matched, they are retrieved in data set order.

      C. Selection Subsets.

         1- Transaction Records.

            A selection subset in the transaction records  is  respected.
            Only   selected   records   become   transactions,  when  the
            transactions are in a data set.

         2- Master Records.

            Matching of master records is done from among all the  active
            records in the data set.  Previously selected subsets make no
            difference.

   2. Transaction locators may be matched to master locators  in  "SORTED
      Mode".

      A. How this is done.

         1- All transaction records with  the  same  locator  values  are
            considered  together.   They  are  read sequentially from the
            group of transactions.

         2- These locators are  collated  against  the  locators  of  the
            master records.  Master records are read sequentially until a
            matching master is found, or until a master is higher in  the
            locator sort sequence than the transaction record locator.

            Transactions are read and discarded until a match  is  found,
            or  until  the  transaction  is  now  higher  in locator sort
            sequence than the master.

         3- Transactions and masters are matched against  each  other  in
            this way, until one or the other runs out.  Any remaining
   UPDATING THE DATA BASE                                       Page 5-23
   Revision 4


            transactions past the end  of  the  masters  are  treated  as
            UNAPPLIED.

      B. Data set Preparation.

         Both the master and transaction  records  must  be  sorted  into
         order  on the locator fields.  The sort command must specify the
         locators in the same hierarchical sequence,  and  this  sequence
         matches  the locator list in the TRANSACT command.  All locators
         are sorted ascending.

      C. Selection Subsets.

         A sorted TRANSACT command reads only the transaction and  master
         records which are previously selected.

         A sorted TRANSACT is the only way to limit  the  application  of
         transactions to a subset of the master records.



   5.2.8.6  Options On The Match

   1. The Transaction Matches a Master

      When a transaction matches at least one master record we  say  that
      it is APPLIED.  The APPLIED clause controls the command action.

      A. APPLIED APPLY

         "APPLIED APPLY" describes the default action of the  transaction
         processor,  that is, to make changes and additions to the master
         record using the values of the transaction fields.   It  is  not
         necessary  to  include  APPLIED  APPLY  in  the TRANSACT command
         unless users specify a message clause.

      B. APPLIED IGNORE

         The user may not want the transactions  to  match  any  masters.
         This  is true if the intent is to append records which should be
         different from any in the master set.  The clause APPLIED IGNORE
         causes  matching  transactions  to  be  ignored.   Messages  are
         optional if this happens.

         APPLIED IGNORE automatically sets UNAPPLIED APPEND (see  below).
         If  applied  records  are  ignored,  and  unapplied  records are
         ignored also, then nothing at all happens  to  the  master  data
         set, except printing of enabled messages.

      C. APPLIED DELETE

         The TRANSACT command can delete records  from  the  master  data
         set.   APPLIED  DELETE  deletes  the  matching  master  records,
   UPDATING THE DATA BASE                                       Page 5-24
   Revision 4


         subject to the conditions for multiple matches.

         When  the  clause  APPLIED  DELETE  is  used,  the  default  for
         UNAPPLIED is IGNORE.

   2. The Transaction(s) Do Not Match a Master

      When a transaction does not match any master, we  say  that  it  is
      unapplied.  The UNAPPLIED clause controls the command action.

      A. UNAPPLIED IGNORE (default)

         Unapplied transactions are ignored by  default.   However,  when
         APPLIED  IGNORE  is  specified, the default changes to UNAPPLIED
         APPEND because no changes  can  be  made  if  both  applied  and
         unapplied records are ignored.

         The UNAPPLIED IGNORE  clause  causes  unapplied  records  to  be
         ignored regardless of defaults.

      B. UNAPPLIED APPEND

         Unapplied records are appended to the data set as  new  records.
         Matched  fields  take  their values from the transaction record;
         unmatched fields take null values.

         The action that UNAPPLIED APPEND takes for multiple transactions
         is  different for sorted and unsorted mode.  In sorted mode, the
         first record of the duplicate group is appended  to  the  master
         data set.  Then the rest of the records in the group are applied
         to the first record according to their order in the group.  (See
         "DUPLICATES  TRANSACT  ALL"  in Handling Multiple Matches On The
         Locators, this chapter.)

         In  unsorted  mode,  unapplied  multiple  transactions  may   be
         scattered  throughout  the  transaction  records.   Each will be
         treated as unapplied and  each  will  be  appended.   The  keyed
         locators in the master data set are not updated until the end of
         the TRANSACT command, although records with these locators  have
         been appended during the command.

   UPDATING THE DATA BASE                                       Page 5-25
   Revision 4


   5.2.8.7  Handling Multiple Matches On The Locator(s)

   In any TRANSACT it is possible for a transaction to match many  master
   records.   We  must  know  how to apply the values for the transaction
   record(s) against many masters.

   In a SORTED TRANSACT, transactions with the same  locator  values  are
   grouped  together,  so  it  is  possible  to  have  many  transactions
   considered at once for application against one or many masters.

   1. Collate the Masters and Transactions with SYNC.

      The SYNC clause directs that groups  of  masters  and  transactions
      with  the  same locators are matched in parallel.  Matching masters
      and transactions are  paired  one  to  one,  and  each  transaction
      affects only its master partner.

      Unpaired master records are ignored.  Unpaired transaction  records
      are treated as UNAPPLIED.

      The SYNC clause is useful only in SORTED mode.  Only then can there
      be groups of transaction records to pair with master records.

      The SYNC clause is used in place of  the  DUPLICATES  clauses,  and
      overrides them if they are specified also.

   2. Specify What to Do With Multiple Transactions.

      The DUPLICATES TRANSACT clause specifies how multiple  transactions
      with  the  same  locator  values  are  applied against any matching
      masters.  The  following  options  apply  to  each  group  of  such
      transactions.

      A. FIRST    Use only the first transaction, ignore the rest.

      B. LAST     Use only the last transaction, ignore the rest.

      C. ALL      Use all of the transaction  records  in  the  group  in
                  sequence.

      D. IGNORE   There should not be multiple transactions;  ignore  all
                  of  them.   The  user usually directs that a message be
                  printed.

      The sort order of the transaction groups  is  determined  by  their
      order in the transaction data set or data file, respecting any sort
      conditions.  DUPLICATES TRANSACT is useful  only  in  SORTED  mode,
      since only then can transactions be treated in groups.

   3. Specify What to Do With Multiple Masters.

      The  DUPLICATES  MASTER  clause  specifies  which  matching  master
      records  are  affected  by  each transaction record.  The following
   UPDATING THE DATA BASE                                       Page 5-26
   Revision 4


      options apply to each group of matching master records.

      A. FIRST    Apply all transactions only to the first master record.

      B. LAST     Apply all transactions only to the last master record.

      C. ALL      Apply each transaction record in sequence to all of the
                  master  records.   Each  master  record  is affected by
                  every transaction record which matches.

      D. IGNORE   A match to many master records is an error,  so  ignore
                  all  of  the  transaction  records.   The  user usually
                  directs that a message be printed.



   5.2.8.8  Tailoring Transactions

   Ordinarily, all transaction fields are applied to  a  matching  master
   record.

   The user may wish to be selective in some transactions, applying  only
   some  fields  in each transaction record, when only some master fields
   need be updated.

   The information of which transaction fields to  apply,  and  which  to
   ignore,  is  part  of  the  transaction field; the field is applied if
   there is something in the field, and it is ignored when blank.

   This mode of operation is specified by the NOCHANGE BLANKS  clause  of
   the  TRANSACT  command.   This  mode  applies to all transactions, and
   selectively applies only the non-blank fields to the master records.

   The definition of a "blank" field depends on the type  of  transaction
   file, or data set.

   1. An ASCII Data File

      All data fields are in display form, and any may have a blank  (all
      spaces) value.  The value zero "0" is not all blank, and is applied
      in an update.

   2. A SIXBIT Data File

      Numeric Display fields and Text fields are blank if all  characters
      are  SIXBIT  blanks  (nulls).   COMP  or  COMP1  numeric fields are
      treated as having a blank value when zero.

   3. Any System 1022 Data set

      Text attributes have blank values if they are all  blank.   Numeric
      fields that have zero values are considered blank.
   UPDATING THE DATA BASE                                       Page 5-27
   Revision 4


   The format of the TRANSACT command is:

            { DATA <file-descriptor1> DESC <file-descriptor2> }
   TRANSACT {                                                 }   ___
            { SET <data set-descriptor>                       }

        [ SORTED  [ SYNC [MESSAGE] [TTYMSG] ] ]          ____            ___       ___

          LOCATOR <attname>  [ , <attname> ] ...          ___

|       [ NOCHANGE BLANKS ] [ NODME ] [ CUSTDMI ]          ___      ___        _____     _______
|  
                                           {  APPEND  }                                              ___
        [  UNAPPLIED  [MESSAGE]  [TTYMSG]  {          } ]           ___         ____       ___
                                           {  IGNORE  }                                              ___

                                       { IGNORE  }                                         ___
        [ APPLIED [MESSAGE] [TTYMSG]   { APPLY   } ]           ___      ___       ___         ___
                                       { DELETE  }                                         ___

                                                  { FIRST  }                                                    ___
        [ DUPLICATES TRANSACT [MESSAGE] [TTYMSG]  { LAST   } ]          ___        ___       ___       ___        ___
                                                  { ALL    }                                                    ___
                                                  { IGNORE }                                                    ___

                                                { FIRST  }                                                  ___
        [ DUPLICATES MASTER [MESSAGE] [TTYMSG]  { LAST   } ]          ___        ___     ___       ___        ___
                                                { ALL    }                                                  ___
                                                { IGNORE }                                                  ___

        [ LRECL <option> ]  [NOMSG]  [ FORMFEED <option> ]          ___                ___       ____

        [ BUFFER <n> ]  [ CORE <n> ]


   Either the DATA clause, or the SET clause must appear.

   DATA <file-descriptor1>:  This gives the name of the data file holding
        the transaction records.

   DESC <file-descriptor2>:  This gives the name of a DMD file describing
        the  data fields in the data file.  It is only used with the DATA
        clause.

   SET  <data set-descriptor>:  This gives the name, alias, or number  of
        the  open  data set containing the transaction records.  Only the
        records selected in that data set are read as transactions.

   SORTED:  Sorting both the transaction and master records improves  the
        efficiency  of large transaction runs.  Sort both the transaction
        and master records into order on at  least  the  locator  fields.
        Use  additional  fields in the sort to produce a determined order
        when depending on the special matching  provisions  of  TRANSACT.
   UPDATING THE DATA BASE                                       Page 5-28
   Revision 4


        The  SORT  clause does not sort the records; it indicates the way
        to process the transactions.  Sorted mode  is  the  only  way  to
        process  transactions  against  only a subset of the master file;
        just the selected transaction and master records participate when
        in sorted mode.

   SYNC:  Duplicates in the transaction and master files are matched  one
        to one in parallel.  The first duplicate transaction is performed
        on the first duplicate master.  The 2nd duplicate transaction  is
        performed  on  the 2nd duplicate master, etc.  If there are fewer
        duplicate  masters  than  duplicate  transactions  the  remaining
        transactions  are  UNAPPLIED.   SYNC  can  be used only in sorted
        mode.  DUPLICATE TRANSACT/MASTER clauses are  ignored.   Optional
        messages  are generated each time either multiple transactions or
        masters are matched.

   MESSAGE clause:  An optional part of other clauses which writes  error
        messages.   If  neither  MESSAGE nor TTY appears, no messages are
        written.  A message is  available  when  the  conditions  of  the
        surrounding  statement are met and some action results because of
        this.   For  example,  a  message  is  available  in  the  clause
        DUPLICATES  MASTER,  whenever  duplicates  in the master data set
        match a transaction record.

        MESSAGE       Write     on      the      error      log      file
                      (<transaction-file>.DME).   (See  also  Chapter  3,
                      Error Handling).

        TTY           Write on the user's terminal.

        MESSAGE TTY   Write on both the error log file and on the  user's
                      terminal.

   The possible messages for the TRANSACT command are:

        TRINVI - Invalid input
        TRRANG - Out of range
        TRAPIG - APPLIED IGNORE
        TRUNAP - UNAPPLIED
        TRMDUP - DUPLICATES for the locator value in the MASTER file.
        TRTDUP - DUPLICATES for the  locator  value  in  the  TRANSACTION
                 file.
        TRADLT - APPLIED DELETE
        TRAPLY - APPLIED APPLY

   LOCATOR:  TRANSACT locates MASTER records  by  comparing  the  LOCATOR
        fields(s)  in the transaction record with the locator field(s) in
        the MASTER records.

        For unsorted transactions locator attribute(s) must be  keyed  in
        the  master  data set.  They need not be keyed in the transaction
        data set.
   UPDATING THE DATA BASE                                       Page 5-29
   Revision 4


        For SORTED transactions the locator(s) need not be keyed.

   NOCHANGE BLANKS:  A "blank" transaction  field  does  not  change  its
        associated master field.
|  
|  NODME:  Suppresses the creation of an error (DME) file.  If errors are
|       detected during the execution of the command, they are written to
|       the terminal.
|  
|  CUSTDMI:  Allows the user to transact records  in  nonstandard  format
|       from a host language program containing the DBLODR call.

   UNAPPLIED:  A transaction is UNAPPLIED if it matches no master record.
        The  UNAPPLIED  APPEND  and  UNAPPLIED  IGNORE  options  indicate
        whether to append the unapplied record or to ignore it.

   APPLIED IGNORE:  When  applied  transactions  are  ignored,  unapplied
                    transactions  are  appended by default.  An UNAPPLIED
                    clause overrides this default action.

           DELETE:  This option calls for a specialized type of TRANSACT.
                    APPLIED   transactions  delete  the  selected  master
                    records.

   DUPLICATES:  The locator fields may  select  more  than  one  matching
        MASTER record for a transaction record.  In sorted mode there may
        also be duplicates in the TRANSACTION file.

        FIRST       These clauses indicate which of the duplicates
        LAST        to use (DUPLICATES TRANSACT) or be changed
        ALL         (DUPLICATES MASTER).
        IGNORE

   LRECL and FORMFEED:  These describe the input file line  format.   See
        the LOAD command for a description.

   NOMSG:  Suppress all non-error messages to the user's terminal  during
        the TRANSACT command.

|  BUFFER <n>:  <n> is the number of buffers to  be  used  in  I/O.   The
|       default  is  2.  The user may specify any number of buffers up to
|       128.
|  
|  CORE <n>:  <n> is the number  of  1024-word  core  segments  used  for
|       sorting.   The default is 5.  The user may allocate up to 30 such
|       segments with the CORE option of the TRANSACT command.

        Large  buffers  and  core  increase  efficiency  for  very  large
        transaction runs.


   UPDATING THE DATA BASE                                       Page 5-30
   Revision 4


   The defaults are:

        <file-descriptor> - A DMI or DMS extension
             is assumed depending on the keyword DATA or SET.
        DESC - A DMD extension  is assumed.
        UNSORTED 
        APPLIED APPLY
        UNAPPLIED IGNORE
        DUPLICATES MASTER ALL
        DUPLICATES TRANSACTION LAST (in sorted mode)
        BUFFERS - 2
        CORE - 5

   Messages are not written unless the MESSAGE clause appears.

   The transaction processor does  not  preserve  the  current  selection
   group.  After a TRANSACT command, the current selection group contains
   no records.

   ADDITIVE TRANSACTIONS   ________ ____________

   Any numeric attribute in the transaction file  may  be  ADDITIVE.   An
   additive   attribute   is  transacted  by  adding  its  value  to  the
   corresponding attribute in the MASTER file record.   (See  chapter  3,
   Additive Attributes in ATTRIBUTE statements).

   An attribute is additive when the keyword ADDITIVE appears in the  DMD
   file  that  either  creates  the transaction data set or describes the
   transaction data file.

   For example:

   If TRA.DMD is

        ATT CUSTIDNO INTEGER LENGTH 6
        ATT DEPOSIT INTEGER LENGTH 6 ADDITIVE

   then for each CUSTIDNO in TRA.DMI, the corresponding master record has
   the  DEPOSIT  field  changed  to  the sum of the current value and the
   value in the transaction file.


   UPDATING THE DATA BASE                                       Page 5-31
   Revision 4


   Examples of TRANSACT Commands:

   1.
       OPEN TEST
       TRANSACT DATA XTRAN DESC XTRAN LOCATOR LN

       This  transaction  reads  transaction   records   from   XTRAN.DMI
       according  to  XTRAN.DMD  and  uses LN as a locator for records in
       TEST.  If several master records match a transaction record,  then
       the default DUPLICATES MASTER ALL causes each transaction to apply
       to all matching masters.

       Selecting  records  in  TEST  before  doing   this   direct   mode
       transaction  does  not  limit the range of master records that are
       affected.

   2.
       OPEN TEST
       F AGE GT 30
       SORT LN FN
       TRANSACT DATA XTRAN DESC XTRAN SORTED LOCATOR LN FN

       This assumes that XTRAN.DMI is  sorted  by  LN  FN.   If  it  were
       unsorted,  some  records would be skipped as being unapplied.  The
       transaction is performed on the selected group (AGE  GT  30)  with
       the following defaults:

       DUPLICATES MASTER ALL
       DUPLICATES TRANSACT LAST
       UNAPPLIED IGNORE

   3.
       OPEN TEST XTRAN
       DBSET 2
       FIND ALL
       DBSET 1
       TRANSACT SET XTRAN LOCATOR LN -<RET>
          DUPLICATES MASTER MESSAGE IGNORE -<RET>
          UNAPPLIED MESSAGE APPEND

       This performs transactions on the data set TEST by matching on the
       attribute  LN.   The  transaction is ignored, and an error message
       written to the error file, if more than one master record  matches
       on  LN.  A message is written, and the transaction record is added
       to  the  master  data  set,  when  no  master  record  matches   a
       transaction record.
   UPDATING THE DATA BASE                                       Page 5-32
   Revision 4


   4.
       OPEN TEST XTRAN
       DBSET 2
       FIND AGE GT 30
       SORT LN
       DBSET 1
       FIND AGE GT 30
       SORT LN
       TRANSACT SET 2 SORTED LOCATOR LN -<RET>
          DUP MASTER ALL -<RET>
          DUP TRANSACT ALL -<RET>
          UNAPPLIED TTY IGNORE

       This transaction updates TEST  with  the  transaction  records  in
       XTRAN.   Only  the records with AGE greater than 30 participate in
       each data set.  Duplicate transaction records, those with the same
       value  of LN, are all applied against all matching master records.
       Each transaction record modifies every master record.   A  message
       prints  on the user's terminal for any transaction not matching at
       least one master record.



   5.3  DATA BASE DAMAGE

   Data set damage results from:

      1. Incomplete updates

         A. Interruptions by control-C.
         B. Malfunction of the computer operating system

      2. Unusual or unexpected program operation

         A. Bugs in System 1022
         B. Malfunction of the computer operating system



   5.3.1  Incomplete Updates

   An incomplete update damages  the  data  set.   Any  update  operation
   changes  information  in  memory, which is not all written to the data
   set file at the same time.  Much information is intentionally retained
   in  memory  to  speed the changes.  The data set contains a mixture of
   new and old information when the update is interrupted.

   System 1022 maintains a damage flag in each data set.   This  flag  is
   set  at  the beginning of an update and cleared at the end.  When 1022
   opens a data set and finds this flag set, it knows that the update did
   not complete properly and it sets the system variable SYSDAMAGE to one
   of four values.  These values are:
   UPDATING THE DATA BASE                                       Page 5-33
   Revision 4


        VALUE            MEANING        _____            _______

          -1      The selected data set is damaged.

           0      The selected data set is not damaged and is  not  being
                  updated.

           1      The selected data set is being updated by another user.

           2      The data set is either damaged or  being  updated,  but
                  1022 cannot determine which.


   A damage condition may be cancelled with the  command  IGNORE  DAMAGE.
   This  restores  SYSDAMAGE to 0 but does not correct any damage to data
   or to the data set structures.  AUDIT FIX may correct  the  damage  if
   audit trails are in use.

   When SYSDAMAGE equals 2, the current job will not be  able  to  update
   the  selected  data  set.   The  data  set is protected, either by the
   monitor file protection or by restriction in 1022 to READ-ONLY access.
   System  1022  discovers  the  state  of a possibly damaged data set by
   attempting to place it in update  status.   It  cannot  determine  the
   exact state when update status is denied because of protections.

   System 1022 warns interactive users and host language  programs  about
   data  set damage in different ways.  For interactive users, 1022 types
   a warning message when the data set is opened giving the date and time
   of the incomplete update.  This and other information can be displayed
   at any time with the INFORM DAMAGE command.   Host  language  programs
   are  not  warned of damage when the data set is opened.  They discover
   damage by examining SYSDAMAGE with DBSYSV.  Both types of  users  will
   get  error  messages  if a command detects damaged data set structures
   during execution.  (SYSDAMAGE replaces SYSFILDAM, which is  maintained
   for compatibility with current user applications).


   If a TOPS-20 system crashes while a data set  is  being  updated,  the
   data  set can be damaged without the damage flag reflecting the damage
   and with  Audit  Trails  incapable  of  providing  full  recovery.   A
   page-writing  function  controlled  by  the system variable SYSWRITE20
   prevents this kind of data set damage.

   TOPS-20 retains pages from a file in a cache whenever it  performs  an
   update.   TOPS-20  moves pages from its cache to the file about once a
   minute.  If the system crashes before pages been moved from the cache,
   the file will not reflect the full update.

   When SYSWRITE20 is 1, System 1022 forces TOPS-20 to write all data  to
   disk  when  any  update is completed.  This takes more processing time
   but provides greater protection for the data.   The  standard  default
   value for SYSWRITE20 is 1.
   UPDATING THE DATA BASE                                       Page 5-34
   Revision 4


   When SYSWRITE20 is 0, System 1022 does not force TOPS-20 to write  the
   changed  pages  to  disk  immediately.   This  was  the  standard 1022
   operation before version 114E(127).  Some  pages  can  remain  in  the
   cache  after  an  update  is  completed and so can be lost in a system
   crash.  Setting SYSWRITE20 to 0 saves processing time at the  risk  of
   lost data.


   Data set damage can affect data in records,  the  keyed  retrieval  of
   records  with the FIND command, and other data set structures that are
   not as visible.  The damage in the data set is  limited  to  what  has
   already  occurred.   Damage does not cause the data set to continue to
   damage itself in further operations.  However, the user could  process
   the   data   incorrectly   in  the  future  when  relying  on  damaged
   information.

   A user may repair a damaged data set by rebuilding those  parts  which
   are  affected,  or by producing an entirely new data set, depending on
   the needs  of  the  application.   Simple  repairs  are  suitable  for
   interactive  applications  where  a further problem is easily noticed.
   Complete rebuilding is  desirable  in  automatic  systems  with  heavy
   updating.  The following describes what can be damaged.


   Damage to data records means that some but not all new data  has  been
   placed  in the records.  Garbage values will not appear in the records
   from this damage, but a field could be split between an old and a  new
   value.   The  user  must  identify  the  partially updated records and
   manually complete them.

   The user need not search the  entire  data  set  to  locate  partially
   updated records.  Damage in data records is limited to the last record
   updated (if UPDATE is OFF), or to any records updated since UPDATE was
   last turned ON.  The user should examine these records to verify their
   correctness.  CHANGE commands can be used interactively to correct the
   values.

   It is important to check the records which have been  affected.   None
   of  the  procedures  that reformat a data set affect the values in the
   records, and any mistakes in data will transfer to future  data  sets.
   Recovering  with audit trails removes both structural and data damage;
   it does more than reformat.  Damage to  KEY  tables  means  that  FIND
   commands  using those keys are unreliable.  Damaged KEY tables produce
   a variety of symptoms.  Damage may be structural, preventing  any  use
   of  the  key, or damage may cause the wrong records to be retrieved in
   response to a request.  Damage might appear only for particular values
   of  a  key, and could be delayed to appear only after further updating
   of the key.  1022 sets the variable SYSFDMATT to the attribute  number
   of  a key which fails with structural damage, as an aid to the user in
   recognizing which of a number of participating keys is damaged.

   Use the KEY command to rebuild any key  which  might  be  damaged,  to
   ensure  that the key will work properly.  A key can be damaged only if
   UPDATING THE DATA BASE                                       Page 5-35
   Revision 4


   the keyed attribute was being updated at the time of the interruption.
   The  user  need  not  rekey those attributes that were used solely for
   retrieval.  First, attempt to rebuild the damaged keys with the  REUSE
   option  of  the  KEY  command.   1022  will attempt to reuse the space
   previously allocated to the key.   If  this  operation  fails  due  to
   structural  damage  in  the  key,  the NOREUSE option always works, by
   allocating additional space for the new key table.

   The user will want to turn off  the  data  set  damage  message  after
   correcting  the  data set.  The data set owner types the IGNORE DAMAGE
   command to turn off  printing  of  the  warning.   The  INFORM  DAMAGE
   command continues to report the first and last times that the data set
   was damaged.  If the data set is interrupted again in an  update,  the
   damage message is reactivated.

   Updating a data set may produce user-inflicted  problems  if  not  all
   damaged keys are corrected.  Update procedures which retrieve on those
   keys may change  the  wrong  records.   The  user  cannot  rely  on  a
   structural  damage  message  to  warn that there are bad values in the
   keys.  This does not mean that all the keys must be rebuilt  for  each
   damage  situation.   It does mean that special care should be taken to
   rebuild any keys which were were being updated,  and which are used to
|  direct  other  updates.  The $KEY SCAN, $KEY CHECKSUM, and $KEY VERIFY
|  commands may be used to identify key table damage.  These commands are
|  described in Chapter 7.

   Damage to several key tables often makes rebuilding  the  data  set  a
   better  choice  than  fixing  the  current one.  The user first should
   examine possibly damaged records to correct them.  Then, the FIND  ALL
   and  DUMP commands will create a new data set and will eliminate space
   used for deleted  records  and  unused  key  tables.   This  procedure
   insures all data set structures are correct.


   The Audit Trail features of  System  1022  provide  an  efficient  and
   automatic  way to recover from any data set damage.  If an audit trail
   is on at the time of damage, a simple command can restore the data set
   to  its  undamaged  condition  before the current update started.  The
   update can then be run again.  The choice to use  audit  trail  backup
   must  be  made  before starting the update procedure.  The audit trail
   uses extra computer  resources,  and  may  be  undesirable  for  small
   applications where damage can be fixed manually.



   5.3.2  System 1022 Or Operating System Bugs

   The cause and  effect  of  damage  from  System  1022  bugs  and  from
   operating  system  bugs  are  much less predictable than what has been
   discussed.  Fortunately, these bugs are rare.

   A bug might cause an update to proceed incorrectly with  no  immediate
   indication  of  damage.   The  damage  later  appears  as  bad data in
   UPDATING THE DATA BASE                                       Page 5-36
   Revision 4


   records, miskeyed records, retrieval error messages, or error messages
   in  1022 commands that access or change records.  Because no procedure
   has been interrupted, the update damage flag will be off.

   The user should suspect structural data set damage whenever the  above
   errors appear and the data set damage flag is off.  Further retrievals
   in such a data set cause no harm,  but  further  updates  might  cause
   harm.  Even bad record values should not be changed within the damaged
   data set.  The user should rebuild the data set with FIND ALL and DUMP
   as  described  above  and then examine the new data set for consistent
   data.   All  the  data  should  be  examined,  since  damage  is   not
   necessarily limited to the records recently updated.

   Save the original damaged data set for inspection  by  Software  House
   personnel so that they may investigate the underlying problem.




   5.4  MULTIPLE ACCESS OF A DATA SET

   Many users can simultaneously access and update records  in  a  System
   1022 data set.  The following sections describe the characteristics of
   this access, any conflicts which may arise, and  features  to  control
   possible conflicts at the expense of using more computer resources.


   There is no change in 1022 operation when many users open a  data  set
   for  retrieval  and  printing.   Each  user proceeds without regard to
   these users.

   A user who is updating a data set may affect other users of that  data
   set.   We  consider  three possible update situations, where retrieval
   users are assumed to be present as well.

        1. A single user executes separate update requests.

        2. A single user locks the data set into UPDATE mode to  do  many
           updates.

        3. Many users  execute  separate  update  requests  in  the  same
           interval of time.

   Cases 1 and 2 above are similar.  The updating  user  may  affect  the
   retrieval  users, but cannot be affected by them.  The only difference
   between these cases is the length of time that the data set is  in  an
   updating  sequence.   In Case 1, the updating sequences are short, and
   terminate within seconds.  In Case 2,  the  data  set  may  remain  in
   update for the entire time interval we might consider.

   Retrieval users may  be  affected  whenever  another  user  is  in  an
   updating sequence.  A user may receive warning messages when opening a
   data set, and may see what  appear  to  be  data  errors  in  recently
   UPDATING THE DATA BASE                                       Page 5-37
   Revision 4


   updated records.

   When a user OPENs a data set at the time another user is in an  update
   sequence, the following message prints:

   Possible FILE DAMAGE (or UPDATE in progress) as of <time> ON <date>


   The date and time tell when the last update  sequence  started.   1022
   has detected that the last update is not finished.  This may be due to
   an earlier computer crash which interrupted the update (See "Data Base
   Damage"  above).   During  updating  by another user, the message only
   warns that others are updating and does not indicate any damage.  This
   message  does not always print;  the user may have OPENed the data set
   between the update sequences of a Case 1 or Case 3 user.

   The user may see data errors if he retrieves recently updated records.
   Old  data  values  are  retrieved, or a mixture of new and old values.
   This happens because of 3 conditions:

        A. An update sequence is only partially completed.

        B. Individual updates are completed for a Case 2 user,  but  have
           not  yet  been  written to the data set file.  In UPDATE mode,
           efficiency is gained by writing out only what is necessary for
           the updating job.

        C. The  retrieval  user  may  see  old   information   previously
           retrieved   and   resident   in   a  job's  temporary  memory.
           Efficiency is gained by only reading information from the disk
           when it is not already available in computer memory.

   We summarize that any update sequence in  progress  leaves  some  data
   records inconsistent with other jobs.  Outside of UPDATE mode, at most
   a single record can be inconsistent.  Inside  UPDATE  mode  or  during
   TRANSACT  or  APPEND, many records may be inconsistent.  Even when the
   data set is consistent, another job which has not  recently  read  the
   data from the disk may report old values.

   The above conflicts arise from the  techniques  used  to  produce  the
   greatest  update  and  retrieval  efficiency.   The following features
   guarantee consistency to the user who needs  it,  by  giving  up  some
   efficiency.   The user decides whether this extra level of consistency
   is worth the price in efficiency.  In many cases, the  user  does  not
   need to retrieve currently updated records;  or slight inconsistencies
   do not matter.

   Use UPDATE mode to guarantee  that  a  retrieval  and/or  a  following
   update  are  consistent.  When UPDATE mode is turned on, only your job
   can access the data set to update  it.   Any  retrieved  value  cannot
   change  when  this  mode  is in effect.  After the desired changes are
   made, turn UPDATE mode off.   This  is  useful  in  automatic  program
   environments  where  the  amount  of time any one job spends in UPDATE
   UPDATING THE DATA BASE                                       Page 5-38
   Revision 4


   mode is small.  When one job is in UPDATE mode, it prevents other jobs
   from proceeding with updates, or starting UPDATE mode.

   In  interactive,  multiple-user  situations,  UPDATE   mode   is   too
   cumbersome,  and  would lock out other users for long periods of time.
   The system variable SYSRESET informs 1022 that it  must  make  current
   information  immediately  available  to  other users.  When it has the
   starting value 0, 1022 takes no special action.

   If a single job remains in UPDATE mode for long periods of time, it is
   useful to issue the command, "LET SYSRESET EQ 1." This informs the job
   that  other  retrieval  users  may  want   any   changed   information
   immediately.   It  causes  the job to write any changes immediately to
   the data set file.  This is less efficient than ordinary UPDATE  mode,
   but more efficient than not using UPDATE mode at all.

   The user jobs which expect to receive the most recent information  set
   SYSRESET to 2 with the command "LET SYSRESET EQ 2." This tells 1022 to
   reconstruct its internal data structures from the  data  set  on  each
   FIND  or  MAP  command.   System  1022  loses  the efficiency of using
   information which has already been read, but produces  timely  answers
   about  the  information  in  the  data  set.   We summarize the use of
   SYSRESET in table 5-1.

                   TABLE 5-1. SUMMARY OF SYSRESET VALUES


        SITUATION                        SYSRESET VALUE FOR EACH JOB        _________                        ________ _____ ___ ____ ___

                                         Update Job     Query Job(s)
        ------------------------------------------------------------

        No updating in progress          0 (default)    0 (default)

        A single job updates, where      0 (default)    0 (default)
        efficiency is worth more 
        than the slight gain in
        current information to
        query users.

        A single job updates in short    0 (default)    2
        bursts, and repeatedly turns
        off, or does not use, UPDATE
        mode.

        A single job updates in UPDATE   1              2
        mode.

        Many jobs update.                2              2



   We have considered the effects of update and retrieval for Cases 1 and
   UPDATING THE DATA BASE                                       Page 5-39
   Revision 4


   2,  where  there  is  only  one  updating job.  All of this discussion
   applies to Case 3.  In Case 3, many updating jobs contend  for  access
   to the data set and require a system to prevent conflict.

   Conflict is eliminated by allowing one job at a  time  to  update  the
   data  set.  The job which gains update access to the data set file, at
   any particular moment, is the one enabled to update the data set.  The
   other  jobs  find  that they cannot get this access for that interval.
   When the updating job finishes, the data set becomes available for the
   next job that requests update access.

   To enable many jobs to update simultaneously, no one  job  can  update
   the  data  set  for  a long time.  Usually this means that no job uses
   UPDATE mode, but  rather  executes  update  commands  as  they  occur.
   Sometimes,  each  job can be designed to start and stop UPDATE mode in
   short bursts, so that each job can  be  sure  of  its  retrievals  and
   updates,  and  also relinquish update access to other jobs.  A job may
   find that it must wait for another job to finish when it tries to gain
   update access to a data set.



   5.4.1  Waiting For Update Access

   System 1022 has two systems for scheduling  update  access  when  more
   than one user needs access to a data set:

        1.  The retry system repeatedly tries until the user gains access
            or until it has tried a specified number of times.

        2.  The queue system  (ENQ)  enters  each  access  request  in  a
            first-in/first-out queue and gives each user access in turn.


   You can specify which access method to use when you build a data  set.
   The  default choice between the retry and queue systems is established
   by the system variable SYSENQDEF.  All data  sets  built  (with  LOAD,
   CREATE,  or  DUMP)  when  SYSENQDEF  is 0 use the retry system, unless
   otherwise specified.  All data sets built when SYSENQDEF is 1 use  the
   queue  system,  unless  otherwise  specified.   You  can override this
   system default for an individual data  set  with  the  ENQ  and  NOENQ
   clauses  of  the  DMD  file, the MODIFY command, and the OPEN command.
   (See those commands and below.)   It is possible to determine  whether
   the  current data set is presently in retry or in ENQ mode by printing
   the system variable SYSDSENQ.  When SYSDSENQ has a  value  of  0,  the
   data  set uses the retry system (NOENQ).  When SYSDSENQ has a value of
   1, which is the default value, the data set uses ENQ update access.
   UPDATING THE DATA BASE                                       Page 5-40
   Revision 4


   5.4.1.1  Retry For Update Access

   The retry system simply repeats the request for access.   When  a  job
   fails  to  gain update access because another job is updating the data
   set, 1022 waits and tries again after a short time.

   The time between tries for update access is the current value  in  the
   system  variable  SYSTRETRY expressed in milliseconds.  A common value
   is 200 (0.2 seconds).  If many jobs are trying for  update  access  to
   the  same  data  set,  a longer time between tries reduces contention.
   Several seconds between tries may be efficient when ten or  more  jobs
   update  simultaneously.   The  user  can set SYSTRETRY to any positive
   integer value.

   The number of times a job tries for update access before reporting  an
   error  message  is  limited.   This  limit is the current value in the
   system variable SYSNRETRY, which can be set by the user.

   Set SYSNRETRY to a value which gives all updating jobs enough tries to
   obtain  update  access.   This  depends  on the number of simultaneous
   jobs, the length of time that any job updates the data  set,  and  the
   time  between tries (SYSTRETRY).  A common value is 10, which allows a
   simple update enough time.  Values of 100 are also common, and 300  is
   not  unknown.   The  only  disadvantage  of large values is that a job
   which is denied update access will wait  longer  before  reporting  an
   error.   When  the  number of tries is exceeded, 1022 prints a message
   like the following:

        1022 ENTER error (3) File being Modified File: <NAMES.DMS>
        File still busy after SYSNRETRY (=10) retries.
        ? (UP1) Can't OPEN data set for writing




   5.4.1.2  ENQ -- Queue For Update Access

   System 1022 uses the monitor ENQUEUE/DEQUEUE facility to queue  access
   requests  for  specified  data  sets.  When a job fails to gain update
   access because another job is updating the data  set,  1022  enters  a
   request  in  a  first-in/first-out queue.  Each request is serviced in
   turn without repeated tries for access.

   Requests remain in the queue until they gain  access  or  a  specified
   time  has  elapsed.  The maximum wait in the queue is specified by the
   system variable SYSTENQ (in milliseconds).  When the wait exceeds  the
   time  specified  by  SYSTENQ,  1022  gives an error message, as in the
   retry access system.

   The access queues are in effect only for specified data sets.  An  ENQ
   data set is specified in the following ways:
   UPDATING THE DATA BASE                                       Page 5-41
   Revision 4


        1.  By the description file ENQ clause when the data set is built
            (see "ENQ in the DMD file" in the Creation chapter).

        2.  By system default when the data set is built  (see  SYSENQDEF
            above).

        3.  By the MODIFY command ENQ clause (see MODIFY in  the  Special
            Commands chapter).

        4.  By the OPEN command ENQ clause (see OPEN in  the  Examination
            chapter).

   Data sets that do not  use  queued  access  use  the  retry-for-access
   system.

   Users must have a system-assigned  ENQ/DEQ  quota  to  use  the  queue
   system.

   If one person uses the  ENQ  system  to  access  a  data  set,  anyone
   accessing that data set at the same time must use the ENQ system.  All
   data sets in a multiple-set file must use the same system:  all  retry
   or all ENQ.



   5.4.1.2.1  SYSDEQFAST

   The system variable SYSDEQFAST controls writing to a  disk  file  when
   the current ENQ data set is updated.

   When SYSDEQFAST is 0, 1022 writes changes to disk before  update  mode
   is  turned  off.  This assures data protection at the cost of slightly
   greater overhead.

   When SYSDEQFAST is 1, 1022 does not force the  monitor  to  write  its
   buffer  to  disk  immediately when update mode is turned off.  This is
   faster, but the data set can be damaged during a system crash  without
   the user being aware of the damage.

   You may reasonably let SYSDEQFAST equal 1 for greater efficiency  when
   the data set is protected by an audit trail.  Assignment of a value to
   SYSDEQFAST applies only to the current data set.



   5.4.1.2.2  Interrupts With ENQ

   The most efficient use of queued access  uses  the  monitor's  Program
   Software  Interrupt (PSI) facility.  When PSI is used, 1022 queues for
   access, then sleeps as it waits.  The PSI system  interrupts  1022  as
   soon as access is possible.

   System 1022 provides two types queued access requests which do not use
   UPDATING THE DATA BASE                                       Page 5-42
   Revision 4


   PSI.  The setting of the system variable SYSENQTYPE selects one of the
   three types.  The table below describes these options.


                           TABLE 5-2. SYSENQTYPE


   SYSENQTYPE  mode   Description

   1           PSI    Use PSI to detect access availability.   Sleep  for
                      SYSTENQ milliseconds, or until interrupted.

   0           RETRY  ENQ every SYSTRETRY milliseconds, for  a  total  of
                      SYSNRETRY  attempts.   Mimics retry system but more
                      efficient.

   -1          BLOCK  ENQ then block the job until  access  is  possible.
                      There  is  no  time  limit and no way to cancel the
                      request.   Uses  the  least  system  resources  but
                      offers least control to the program.



   When SYSENQTYPE is 1, 1022 uses PSI.  System 1022 sleeps in the  queue
   until  it  gains  access  or  until  the time specified by SYSTENQ has
   passed.

   When SYSENQTYPE is 0, 1022 does not use PSI.   Instead  it  repeatedly
   tries for access with the ENQ call;  it tries as often as specified by
   SYSTRETRY and as many time as specified by SYSNRETRY.  This mimics the
   retry system but is more efficient.

   When SYSENQTYPE is -1, 1022 does not use  PSI.   The  job  is  blocked
   until  the  file becomes available.  There is no time limit and no way
   to cancel the request for the file;  it can wait forever.   This  uses
   the  least  system  resources  and  offers  the  least  control to the
   program.  This is the same as the usual COBOL use of ENQ/DEQ.

   Some non-standard TOPS-10 systems do not  allow  the  use  of  PSI  or
   require  a PSI table in page 0.  The system variable SYSNOPSI controls
   the use of PSI for these systems.  It may be set by the user or is set
   by  1022  when  1022  first  discovers  that PSI is unavailable.  When
   SYSNOPSI is 0, 1022 tries to use PSI.  When  SYSNOPSI  is  1,  PSI  is
   unavailable and 1022 does not try to use it.

   Some programs use the PSI system  for  Control-C  trapping  and  other
   functions.   Programmers  should  be  aware of the interaction between
   uses of the PSI system.  On TOPS-10 systems, 1022's  use  of  the  PSI
   system  replaces  the  program's.   On TOPS-20, 1022's PSI is combined
   that of the program.

   Each time a PSI ENQ is done, 1022 enable a  PSI  interrupt  condition,
   unless  it  has  kept  the  PSI  system from a previous ENQ call.  The
   UPDATING THE DATA BASE                                       Page 5-43
   Revision 4


   system  variable  SYSKEEPPSI  controls  whether  the  PSI  system   is
   preserved across ENQ calls.  Saving the PSI system avoids the overhead
   of re-enabling it, but it may interfere with the program's other  uses
   of  PSIs.   The general rule is that SYSKEEPPSI should be 0 on TOPS-10
   and 1 on TOPS-20.  Exceptions include TOPS-10 programs  which  do  not
   use  PSIs  themselves,  and  TOPS-20  programs for which available PSI
   channels may be scarce.

   Table 5-3 describes  the  effects  of  SYSKEEPPSI  under  TOPS-10  and
   TOPS-20.


                           TABLE 5-3. SYSKEEPPSI


   SYSKEEPPSI  System     Description

   1           TOPS-10    1022's  PSI  system  replaces   the   program's
                          permanently.   1022  continues  to use this PSI
                          system on successive ENQ calls.

   0           TOPS-10    1022's PSI system replaces  the  program's  for
                          the duration of the ENQ request.  The program's
                          PSI  system  is   restored,   and   1022   must
                          re-establish its PSI on each ENQ call.

   1           TOPS-20    1022's PSI condition is added to the program's,
                          and  remains  in  effect  across successive ENQ
                          calls.

   0           TOPS-20    1022's PSI system is added to the program's but
                          is  removed  after the ENQ request is satisfied
                          or dismissed.  1022 must re-establish  its  PSI
                          on each ENQ call.


   When SYSKEEPPSI is 1, 1022 enables its PSI interrupts and retains  its
   PSI interrupt setting after the file becomes available.  This requires
   less overhead.  On TOPS-10 systems,  the  1022  setting  replaces  the
   prior  PSI setting.  On TOPS-20 systems, the prior PSI setting and the                                                                  ___
   1022 setting are retained.  You can usually set  SYSKEEPPSI  to  1  on
   TOPS-20 systems, unless you need to reclaim the one channel (of thirty
   six available) used by the 1022 PSI setting.

   When SYSKEEPPSI is 0, 1022 saves the current PSI setting, enables  its
   own PSI interrupts, then restores the job's previous PSI setting after
   the file becomes available.  Saving and  restoring  the  pre-1022  PSI
   setting  requires  some overhead.  On TOPS-10 systems, you usually set
   SYSKEEPPSI to 0 if you need to restore the prior PSI setting after the
   file becomes available.

   The following table  summarizes  the  simultaneous  update  variables.
   Asterisks indicate the 1022 standard default.
   UPDATING THE DATA BASE                                       Page 5-44
   Revision 4


                  TABLE 5-4. Simultaneous Update Variables


     VARIABLE   VALUE             EFFECT     ________   _____             ______

   SYSDEQFAST     0   Writes changes to disk before DEQ *
   SYSDEQFAST     1   May write changes to disk after DEQ

   SYSENQDEF      0   By default data sets are built NOENQ *
   SYSENQDEF      1   By default data sets are built ENQ

   SYSTRETRY      n   Time between access tries (Retry system)

   SYSNRETRY      n   Number of access tries (Retry system)

   SYSTENQ        n   Maximum wait time (ENQ system)

   SYSENQTYPE     1   ENQ uses PSI; Sleeps up to SYSTENQ milliseconds *
   SYSENQTYPE     0   ENQ does not use PSI; Retries SYSNRETRY times
                        at SYSTRETRY intervals
   SYSENQTYPE    -1   ENQ does not use PSI; Blocked job, wait forever

   SYSKEEPPSI     1   Changes to 1022 PSI setting *
   SYSKEEPPSI     0   Saves and restores job's PSI setting

   SYSNOPSI       0   PSI available *
   SYSNOPSI       1   PSI unavailable



   5.4.2  Consistency In Updates

   Below are some of the characteristics of updating a data set when more
   than one job updates in the same time interval.

   The selection conditions which choose a group of records do not remain
   in  effect  after  they  have  acted.   A selected group of records is
   remembered by SYSID only;  the attribute values which  caused  records
   to  be  selected  may  be updated by another job after selection.  For
   example, the command FIND SALARY 10000 establishes a group of  records
   by  examining  a key value.  However, when a record is later retrieved
   with GETREC or another process, you may find that the SALARY has  been
   changed  by  another  job.  The record still remains in your selection
   group.  In the same way, a record which is added or changed to qualify
   for the group does not join the group unless the FIND command with the
   original condition is reissued.

   Even the SELECT command does not guarantee a data value.   The  SELECT
   conditions  are applied as the next record is retrieved and validated.
   Still, other jobs may change the data on which  the  SELECT  operated.
   The affected record is not removed from the selection group.

   You must be the only updater of the data set, from the time of  record
   UPDATING THE DATA BASE                                       Page 5-45
   Revision 4


   selection  until  the  time of update, to be sure that the records you
   examine match the criteria  you  have  placed  on  them.   This  is  a
   restriction  of  simultaneous  update,  and  not  just of System 1022.
   Impose this condition by using UPDATE ON from the  time  of  selection
   until updating is completed.

   If the application prohibits placing UPDATE ON for  long  times,  then
   arrange  the  separate  job streams so that they do not interfere with
   one another.  Or, check  important  data  in  each  record  as  it  is
   retrieved,  after  setting  UPDATE ON.  You can skip a record which no
   longer qualifies for updating, and  go  back  at  the  end  to  select
   qualifying records which have recently changed.



   5.4.3  System Protection For Interactive Simultaneous Updates

   System 1022 warns the user if the record he wishes to CHANGE or DELETE
   has  been  altered  since he read its values.  This protection applies
   only to the last record selected by the GETREC command.  The CHANGE or
   DELETE  command  is  ignored,  and  1022  gives  a warning or an error
   message.  The system variable SYSTRAPUP3 controls the kind of message.
   When  SYSTRAPUP3  is  0, 1022 issues the following warning (unless the
   UPDE. label is specified in the host language program):

        <CHANGE or DELETE> ignored. Record altered after GETREC.
        SYSID=<n> Data set <data set-name> IN <filename>
        %Continuing


   When SYSTRAPUP3 is 1 or the  UPDE. label  is  specified  in  the  host
   language  program,  1022  handles the condition as an error and issues
   the UP3 error message.  (See the Host Language  Interface  Manual  for                                    ____ ________  _________  ______
   the use of the UPDE. label).

   This prevents the user from updating a  record  based  on  information
   which has changed since he inspected the record.

   For example, User-1 selects Record #10.  While  User-1  is  displaying
   attributes  and  typing  a  CHANGE  command,  User-2 executes a CHANGE
   command on this record.  User-1 continues to see the old values, since
   he read the record when those values were current.

   When User-1 issues a CHANGE or DELETE, the warning  or  error  message
   appears.   User-1 may print out the record again and determine whether
   or not to apply the original  update,  or  perhaps  make  a  different
   update.  The record is still selected and has the most current values;
   no new GETREC is required.

   1022 determines whether or not  the  current  record  has  changed  by
   comparing  User-1's  image  of  the selected record against the newest
   record in the data set.  CHANGE and DELETE set UPDATE ON during  their
   action,  so  no other user can update the record until User-1's CHANGE
   UPDATING THE DATA BASE                                       Page 5-46
   Revision 4


   or DELETE is completed or ignored.  If the record  images  match,  the
   update is performed;  if not, the message is displayed, and the update
   is not performed.

   The message applies only to outside changes made to the current record
   since  it  was  retrieved.   No  protection  applies to a record after
   investigating other records in the  same  data  set.   The  user  must
   verify  the values of the record again, after retrieving it again, and
   before changing it.  In multiple data set operations, the most  recent
   record for each data set is remembered.

|  There are essentially two ways to avoid contention for records  during
|  updates.   One  is  to  set  UPDATE ON before updating a data set when
|  other users also update common records.  No other user can update  any
|  records  in  the  data  set  until  the  first  user  sets UPDATE OFF.
|  However, UPDATE ON is impractical  in  most  simultaneous  interactive
|  update   applications.    Therefore,   a  second  strategy  should  be
|  considered.  This involves the use of record-level locking,  which  is
|  described in the following sections.
|  
|  
|  
|  
|  5.4.4  Record-Level Locking
|  
|  You can lock individual records, and you can  define  your  own  locks
|  with the userlock feature.
|  
|  The record-level locking commands control access to individual records
|  when you are in single record (GETREC) mode.  They prevent other users
|  from getting update access to your current record while  you  have  it
|  locked.
|  
|  The principal benefit of record-level locking  is  that  it  restricts
|  access  for  only  one  record  at  a  time.   This  reduces long-term
|  contention among users  of  the  same  data  set  or  among  users  of
|  different  data  sets  in  the same file.  UPDATE locks the whole file
|  that contains the data set.  Record-level locking guarantees  that  no
|  other  users  can change your current record while you have it locked.
|  Also, if you give a CHANGE, DELETE, or UNDELETE command for the record
|  you have locked, 1022 issues an implicit UPDATE ON and UPDATE OFF.
|  
|  The new userlock features create a user-defined lock that  coordinates
|  access  to  the  data set among cooperating users.  You can coordinate
|  access using your own criteria and without simply locking other  users
|  out of the data set.
   UPDATING THE DATA BASE                                       Page 5-47
   Revision 4


|  5.4.4.1  Record-level Locking
|  
|  The record-level locking commands are the LOCK command and the similar
|  $LOCK  clause  of  the GETREC command.  Both are used in single record
|  mode, and both ensure that no other  users  can  update  your  current
|  record.  Other users may have full access, including update access, to
|  the other records in the data set.  They may read your current  record
|  when you have it locked, but you are the only user who can update that
|  current record while the lock is on.  For example:
|  
|  *FIND ALL 
|  97 RECS FOUND. 
|  *GETREC $LOCK 
|  *... 
|  *GETREC $LOCK 
|  
|  or 
    
|  
|  *FIND ALL 
|  97 RECS FOUND. 
|  *GETREC 
|  *LOCK ON RECORD 
|  *... 
|  *LOCK OFF RECORD 
|  
|  These commands are especially useful in ensuring that  a  record  does
|  not  change after you select it and before you update it, print it, or
|  use it in other operations.  And these commands lock only  one  record
|  at  a  time  so that most of the data set is still available for other
|  users.
|  
|  For efficiency reasons, the GETREC $LOCK command is always  preferable
|  to  the  LOCK  ON  RECORD  command.  See "Locking Records with LOCK ON
|  RECORD" below.
|  
|  
|  
|  5.4.4.1.1  Enabling Record-level Locking For A Data Set
|  
|  To use record-level locking, a data set must be  an  ENQ  and  RECLOCK
|  data set.  You can include these keywords in the description file when
|  you create the data set, or you can use the MODIFY command to make the
|  data  set  ENQ and RECLOCK.  A MODIFY $ACCESS ENQ or NOENQ changes the
|  ENQ status of the data set the next time the data set is opened.   But
|  MODIFY  $ACCESS RECLOCK or NORECLOCK changes the RECLOCK status of the
|  data set immediately.  A data set must be an ENQ data set  before  you
|  can  make it a RECLOCK data set.  An OPEN ENQ command for the data set
|  is not sufficient to make a NOENQ data set work  with  RECLOCK.   Most
|  users  will  create  ENQ  data  sets and use MODIFY to turn on and off
|  RECLOCK.
|  
|  A RECLOCK data set has the following characteristics:
   UPDATING THE DATA BASE                                       Page 5-48
   Revision 4


|        o  It allows record-level locking.
|  
|        o  It does not allow global updates using  the  CHANGE,  DELETE,
|           UNDELETE, or TRANSACT commands.
|  
|        o  It requires that a record be locked to do single record  mode
|           updates with CHANGE, DELETE, or UNDELETE commands.
|  
|  
|  A NORECLOCK data set does not  allow  record-level  locking  and  does
|  allow global updates.
|  
|  In many cases you will want to create RECLOCK data sets and ordinarily
|  use them for changes in single record mode.  Then for occasional batch
|  jobs that make global updates to  the  data  set,  you  can  turn  off
|  record-level  locking with a MODIFY $ACCESS NORECLOCK command.  At the
|  end of the procedure, you can restore the data  set  to  its  ordinary
|  condition with a MODIFY $ACCESS RECLOCK command.
|  
|  You must have exclusive access to the data  set  to  give  the  MODIFY
|  $ACCESS  RECLOCK or NORECLOCK commands.  You cannot have the UPDATE ON
|  command in effect when you give these MODIFY commands.
|  
|  ENQ must be enabled for the data set before  you  can  enable  RECLOCK
|  with  MODIFY.   You  can tell if a data set is RECLOCK with the INFORM
|  STRUCTURE command or by printing the system variable SYSRECLOCK.  When
|  SYSRECLOCK  is  0,  the  data  set  is  not  a RECLOCK data set.  When
|  SYSRECLOCK is 1, the data set is RECLOCK.
|  
|  
|  
|  5.4.4.1.2  Locking Records With GETREC $LOCK
|  
|  You lock a record with the GETREC $LOCK command or the LOCK ON  RECORD
|  command.   Though  their effects are similar, the GETREC $LOCK command
|  is more efficient and is recommended for most cases.   Record  locking
|  with  the  GETREC  command  locks  the  record at the time you get the
|  record.  The format for the command is:
|  
|  GETREC [ { LEAVE } ] [$LOCK] [<expression>] 
|         [ { label } ]
|  
|  The sequence of options is significant.  LEAVE or a label is  optional
|  but,  if  used, must be given first.  Similarly, the $LOCK option must
|  be next.  The expression that evaluates to a record number must be the
|  last.
|  
|  When you give the GETREC $LOCK command, you can perform any operations
|  on  the  record.   Other users can query the record but not update it.
|  Other users who attempt to  update  a  record  that  you  have  locked
|  receive an error message.  Other users who request a lock for the same
|  record will have their request placed in  a  monitor  ENQ  queue.   If
|  their  request  is  not  granted  in  SYSTENQ (or SYSNRETRY*SYSTRETRY)
   UPDATING THE DATA BASE                                       Page 5-49
   Revision 4


|  milliseconds, they are given a  timeout  error.   If  you  unlock  the
|  record  while  they  are  waiting in the ENQ queue, their request will
|  succeed.  The record remains locked until you unlock it by  performing
|  one of the following actions:
|  
|  
|        o  Closing the data set
|  
|        o  Returning to global mode (with the  STARTREC  command  or  by
|           forming a new selection set)
|  
|        o  Dropping the record from the selection  set  with  the  DROP,
|           DELETE, or UNDELETE command
|  
|        o  Getting another record with a GETREC command
|  
|        o  Explicitly unlocking  the  record  with  a  LOCK  OFF  RECORD
|           command
|  
|  
|  Using GETREC  $LOCK  prevents  attribute  values  from  being  changed
|  between  the time you get and lock the record.  This is different from
|  using LOCK ON RECORD  (see  below).   However,  attribute  values  can
|  change  between  the  time you form the selection set and the time you
|  get and lock an individual record.  To make sure the original value is
|  the  current value, you can use PL1022 code like that in the following
|  example:
|  
|  LET SYSIFTYPE 1. 
|  FIND AGE LT 40. 
|  WHILE 0 EQ 0 DO 
|     GETREC LEAVE $LOCK. 
|     IF AGE LT 40 THEN 
|        ;original value is still current value, so
|        ;perform operations on record 
|      ELSE
|        ;original value of AGE has changed, so
|        DROP. 
|     ENDIF. 
|  ENDWHILE. 
|  
|  
|  
|  
|  5.4.4.1.3  Locking Records With LOCK ON RECORD
|  
|  The new LOCK command creates userlocks on the data set (see below)  or
|  locks on individual records much like GETREC $LOCK.  The format of the
|  command is:
|  
|             { RECORD          }                 ___
|       { ON  { USERLOCK string }     }                ____
|  LOCK {                             }
   UPDATING THE DATA BASE                                       Page 5-50
   Revision 4


|       { OFF { RECORD              } }                 ___
|             { USERLOCK { string } }                ____
|                        { ALL    } 
|  
|  LOCK ON RECORD differs from GETREC $LOCK in that it is less efficient,
|  requiring  that  a  record be read one extra time, and in that it does
|  not ensure that a record is unchanged between the  time  you  get  the
|  record  and  lock  it.   After you give the GETREC command selecting a
|  record in local mode,  another  user  could  change  attribute  values
|  before  the  LOCK ON RECORD command locks the record.  You can use the
|  system variable  SYSCHANGED  to  test  the  record  for  changes.   If
|  SYSCHANGED  is 0, the record has not changed since the GETREC command.
|  If SYSCHANGED is 1, the record has  changed.   The  procedure  in  the
|  following example shows such testing:
|  
|  LET SYSIFTYPE 1. 
|  FIND AGE LT 40. 
|  WHILE 0 EQ 0 DO 
|     GETREC. 
|        PRINT AGE.
|     LOCK ON RECORD. 
|     IF SYSCHANGED EQ O THEN 
|           ;perform operations on record 
|      ELSE 
|        PRINT AGE.
|           ;perform operations on record or drop
|     ENDIF. 
|  ENDWHILE. 
|  
|  The IF statement tests for any change between the GETREC and the  LOCK
|  ON  command.   It  does  not test for changes made between the initial
|  FIND and the GETREC command.  To check for those changes, you need  to
|  also test as in the GETREC $LOCK example above.
|  
|  You can unlock the record implicitly, as with GETREC $LOCK, by forming
|  a  new selection set, dropping the record from the selection set (with
|  the DROP, DELETE, or UNDELETE commands), or getting the  next  record.
|  Or you can unlock the record with an explicit LOCK OFF RECORD command.
|  
|  
|  
|  5.4.4.2  User-defined Locks On A Data Set
|  
|  The user-defined lock,  created  with  a  LOCK  ON  USERLOCK  command,
|  coordinates  access  to a data set among users.  The userlock does not
|  actually restrict access to the data set.  Instead it  allows  you  to
|  define a lock that users agree to request before performing a specific
|  1022 operation on data.  You can define a lock that  only  applies  to
|  the  parts  of  a  data  set  you need.  For example, you can restrict
|  access to a specific attribute while allowing  users  free  access  to
|  other data in the data set.
|  
|  To define userlocks for a data set, the data set must be an  ENQ  data
   UPDATING THE DATA BASE                                       Page 5-51
   Revision 4


|  set  (created ENQ or modified ENQ) or opened as ENQ.  It does not need
|  to be a RECLOCK data set.
|  
|  When you give the LOCK ON USERLOCK command, the "lock" you specify  is
|  associated  by  your convention with the particular operation you want
|  to lock.  The "lock" is a quoted string of up to 25  characters;   all
|  printable  characters except spaces are allowed.  Users agree to check
|  for a lock before performing the controlled operation.   The  LOCK  ON
|  USERLOCK  command  is  your  request for access.  You specify the lock
|  associated with the operation.  If your  request  succeeds,  you  have
|  permission  to  perform the operation.  If it fails, wait until later,
|  try the same LOCK command again, and if it succeeds, proceed with  the
|  operation.   The  following example demonstrates the LOCK command with
|  the USERLOCK option:
|  
|  *LOCK ON USERLOCK "FRANCE_RECS" 
|  
|  1022 displays an error message if your request is not successful.   If
|  another  user  already  has  this  userlock  on, your request will not
|  succeed.  If no message displays, then you have permission to  proceed
|  with the operation.
|  
|  Userlocks are most useful when a  data  set  is  changed  or  accessed
|  exclusively  through  programs.   Although  interactive  users can use
|  userlocks, they must remember to request the locks  before  performing
|  the controlled operations.
|  
|  If a program succeeds in getting a userlock, it can access  the  data.
|  But  if  a program fails in getting the userlock, it should not access
|  the data.  When a LOCK command fails in a  program,  1022  returns  an
|  error  message.   Remember  that a userlock does not actually lock the
|  data set.  Its usefulness depends on coordinated requests.
|  
|  Consider  the  following  example:   One  program,  MAPDIR,  uses  the
|  DIRECTOR_ID  attribute  to  map  from  FILMS  to  DIRECT,  and another
|  program, CHANGEDID, changes the value of the DIRECTOR_ID attribute  in
|  these  data  sets.   You  can  define  a userlock "DID_ATTR" that both
|  programs must request.  If a user is running  MAPDIR,  then  no  other
|  user  can  run CHANGEDID.  And if a user is running CHANGEDID, then no
|  other user can run MAPDIR until CHANGEDID finishes.  Any other program
|  that  does  not  use  the  DIRECTOR_ID  attribute can change any other
|  attribute without interfering with these programs.
|  
|  A second example shows the use of userlocks to avoid a  deadly-embrace
|  situation.   An example of a deadly-embrace situation is when John has
|  record A and Mary has record B.  Without releasing these records, John
|  requests  B  and  Mary  requests A.  Neither is willing to give up the
|  first record to the other user, so neither user can proceed.
|  
|  In the following example of a funds-transfer procedure, userlocks  are
|  used  to  avoid  a  deadly-embrace  situation.  To transfer money from
|  account A to account B, the ACCOUNTS data set is  opened  twice,  with
|  aliases  ACCT1  and  ACCT2.  A different record is found in each.  The
   UPDATING THE DATA BASE                                       Page 5-52
   Revision 4


|  procedure uses a LOCK ON USERLOCK command to lock the data  set  while
|  it locks the two records with GETREC $LOCK commands.
|  
|  Other  users  could  lock  other  single  records  without  causing  a
|  deadly-embrace  situation.  By the userlock convention established for
|  this procedure, no one would lock multiple records without  using  the
|  userlock.  The userlock is turned off after the individual records are
|  locked.  And the individual records  are  unlocked  with  a  LOCK  OFF
|  RECORD if no transfer is made due to insufficient funds.
|  
|                    . . .  
|                    OPEN ACCOUNTS AS ACCT1 ACCOUNTS AS ACCT2.  
|                    . . .  
|                    DBSET ACCT1.  
|                    FIND ACCOUNT_NUMBER EQ ACCT_FROM.
|                    IF SYSNREC NE 1 THEN
|                       ;0 or more than one source accounts
|                       PRINT "Source acct #" ACCT_FROM
|                          "not found...transfer aborted".
|                           GOTO NTFND.
|                      ENDIF.
|                    DBSET ACCT2.
|                    FIND ACCOUNT_NUMBER EQ ACCT_TO.
|                    IF SYSNREC NE 1 THEN
|                       ;0 or more than one destination accounts
|                       PRINT "Destination acct #" ACCT_TO
|                          "not found...transfer aborted".
|                          GOTO NTFND.
|                      ENDIF.
|                    LOCK ON USERLOCK "FUNDS-TRANSFER".
|                    GETREC $LOCK.
|                    DBSET ACCT1.
|                    GETREC $LOCK.
|                    LOCK OFF USERLOCK "FUNDS-TRANSFER".
|                    LET NEWBAL EQ (BALANCE - TRANSFER_AMOUNT).
|                    IF NEWBAL LT 0 THEN
|                       PRINT "Transfer will overdraw acct #" ACCT_FROM
|                          "...transfer aborted".
|                          GOTO NOXFER.
|                      ENDIF.
|                    CHANGE BALANCE NEWBAL.
|                    DBSET ACCT2.
|                    CHANGE BALANCE (BALANCE + TRANSFER_AMOUNT).
|  NOXFER: DBSET ACCT2.
|                    LOCK OFF RECORD.
|                    DBSET ACCT1.
|                    LOCK OFF RECORD.
|  NTFND:            . . . 
|  
|  A userlock stays on until you turn it off with LOCK  OFF  USERLOCK  or
|  close  the  data  set.   You can either turn off a single userlock, by
|  specifying a particular "lock," or you can turn off all the  userlocks
|  in a data set, by using the ALL clause.  For example:
   UPDATING THE DATA BASE                                       Page 5-53
   Revision 4


|  *LOCK OFF USERLOCK "FRANCE_RECS" 
|  
|  or 
|  
|  *LOCK OFF USERLOCK ALL 
|  
|  
|  
|  
|  5.4.4.2.1  Userlocks With Collections
|  
|  If you turn on a userlock while set  to  a  collection,  the  lock  is
|  applied  to  all of the data sets in the collection.  The lock remains
|  on for each data set even after a CLEAR  COLLECT  command.   You  must
|  explicitly  turn  off  the userlock or turn it off by closing the data
|  set.
|  
|  However, there is one exception.  When a data set is opened more  than
|  once  in  a collection and a userlock is turned on for the collection,
|  only the first opening of the data set will still have the userlock on
|  after a CLEAR COLLECT command.
|  
|  While in a collection, a LOCK OFF USERLOCK ALL command unlocks all the
|  userlocks  on  all  the  data sets in the collection.  Even a userlock
|  turned on for a data set before the collection  was  formed  with  the
|  COLLECT command will be turned off by LOCK OFF USERLOCK ALL.
|  
|  See the Host Language Reference Manual for information on how to write           ____ ________ _________ ______
|  updating routines that make use of data set and record-level locking.
   UPDATING THE DATA BASE                                       Page 5-54
   Revision 4















                                 CHAPTER 6

                               PRINT FORMATS



   The user can specify a FORMAT to control printing  in  the  PRINT  and
   TYPE  commands.   The  following  describes how to construct a FORMAT.
   The specifications are similar to format specifications in  COBOL  and
   FORTRAN.



   6.1  FORMAT STRUCTURE

   A format is a collection of format specifications which are  delimited
   by the keywords FORMAT (or FMT) and the word END:

        { FORMAT }
        {        }  <body>  END
        { FMT    }

   The <body> contains individual format specifications, possibly grouped
   by parentheses.  Within any parenthetical group, each specification is
   separated from the next by at least 1 space.  Commas also may be  used
   as separators.

   Example:  PRINT 12345 1234567

                FORMAT "INPUT" I5 3X "OUTPUT" I7 END

             This prints as

             INPUT12345   OUTPUT1234567


   The data output specifications (I F E G P M A) can be preceded  by  an
   integer n which causes the formatter to use that specification n times
   consecutively.  For example, the following two format  statements  are
   equivalent:

        FORMAT I5 I5 I5 I5 END
        FORMAT 4I5 END

   PRINT FORMATS                                                 Page 6-2
   Revision 4


   6.2  NUMERIC FORMATS

   All numeric output specifications follow the same  pattern.   Each  is
   made  of  at  most  7 parts in four groups, but the ones most commonly
   used are much simpler.  The following describes  how  to  choose  from
   these  parts  to  make  a  legal  specification.   The meaning of each
   specification is described later in detail for each  type  of  numeric
   editing.   The  construction of a specification is described below and
   illustrated by the following diagram:

        I   B S $   n  .m   S
              + *     ..m   +
        --!-------!-------!---
        1   2 3 4   5   6   7

   The parts of a specification are numbered from 1 to 7 below the  line.
   A  vertical  list designates a choice of one of the items in the list.
   The specification is formed by combining the parts  in  order  without
   spaces between them.  The parts fall into 4 natural groups as follows:

   Parts     Description   _____     ___________

   1         The first part is the type of numeric editing  done  by  the
             specification.  I means Integer editing, one of the possible
             choices.

   2 3 4     The next group of characters choose special actions for zero
             data,  whether  to  print  a  numeric sign of some type, and
             whether to precede the number by  a  dollar  sign  or  check
             protection  asterisk.   This groups chooses how to introduce
             the number.  The order of the characters in  this  group  is
             arbitrary;  the result prints in the order in the diagram.

   5 6       These parts assign the number of positions for printing  the
             number.   The  two  parts  specify how the number will print
             around a "decimal point" which prints or is only implied.

   7         The last part specifies a trailing sign when desired.

   Construct a numeric specification by matching the requirements of  the
   output to the menu of parts which may be chosen.  Omit the parts which
   do not apply to what is needed.  The  parts  are  described  generally
   below;   some  of  them have more particular meanings depending on the
   type of numeric editing done.

   General description of the parts in a numeric format:

   1. Numeric  specification.   I  means  Integer   and   is   used   for
      illustration.   1022 supplies a default format if this part is used
      alone in the specification.

   2. Blank on Zero switch.  It does not add any print positions  to  the
      output  field.  The entire field prints as blanks if the data would
   PRINT FORMATS                                                 Page 6-3
   Revision 4


      have printed as zero.  This also blanks any positions  which  would
      have  contained  special  characters, signs, or decimal points.  In
      some cases the data prints as zero although it is not exactly zero,
      and it is blanked.

   3. Preceding numeric sign.  The S prints a blank for positive numbers,
      and  a minus sign "-" for negative numbers.  The + prints a "+" for
      positive numbers, and a "-" for negative ones.  The sign prints  in
      front  of  the  digits  in  the number, before any check protect or
      dollar sign character (See 4).   This  adds  one  position  to  the
      output field.

      No sign prints, even for negative numbers, if this is omitted.

   4. Dollar sign or  check  protect  character.   The  chosen  character
      floats in front of the digits in the displayed number.  Spaces fill
      in front of the dollar sign.  An asterisk preceded by spaces prints
      in  front of the number when * is chosen.  One position is added to
      the output field to hold the character.

   5. Length of the first part of the numeric field.  It  reserved  space
      for  printing blanks and digits.  Any characters specified in parts
      3 and 4 directly precede the digits  that  print.   n  is  required
      unless  part  1 is used alone in the specification.  It may be 0 if
      part 6 is included.

   6. This field is the part of the printing number which follows a  real
      or  implied  decimal  point,  or  which  prints only digits and not
      spaces.   The  choice  with  doubled  period  reverses  the  normal
      printing of the decimal point in some forms of numeric editing;  it
      prints the decimal point if it is  normally  not  printed,  or  the
      reverse.

   7. Trailing sign.  It is similar to the preceding numeric sign in part
      3, but prints after the number.  One position is added to the field
      length  to  hold  the  sign.   This  prints  independently  of  any
      preceding  sign; both the preceding and trailing sign may appear in
      the same specification.

   The following table shows some of the constructions made by the  above
   rules,  and the length of the output field which they describe.  The I
   format is used for  illustration.   See  the  following  sections  for
   detailed information on each numeric format type.


   PRINT FORMATS                                                 Page 6-4
   Revision 4


                             Numeric
      Specification  Length  Length  Comments
      -------------  ------  ------- --------

          I           N/A     N/A    Displays  the  number  in  a  System
                                     defined field.

          I5           5       5     Print the integer in 5 positions.

          IS5          6       5     Print a preceding space or minus.

          I$5          6       5     Print a preceding dollar sign.

          I*5          6       5     Print a preceding asterisk.

          I+5.2        8       7     Print a 7 digit integer;   the  last
                                     two  positions always print a digit.
                                     A  preceding  plus  or  minus   sign
                                     prints.




   6.2.1  I - Integer Format

   The letter I performs Integer editing.  It takes arguments in the form
   of the numeric specification described above.

   The characters $ * S + specify  leading  or  trailing  numeric  signs,
   dollar  signs, or check protect characters, as described before.  Each
   included character increases the field length by one position.   Other
   arguments have the following meanings:

      Choice    Meaning
      ------    -------

      I         I standing alone prints in a width chosen by  1022.   See
                "Omitting the Specification" below.

      I5        This prints the number in  the  next  5  positions,  with
                leading  spaces  if  the number is less than 5 digits.  A
                zero value prints  a  single  0  character  with  leading
                spaces.  No sign prints, even for negative numbers.

      IS$5      The dollar sign and numeric sign print directly in  front
                of the digits of the number.  A short number is filled to
                5 positions with leading spaces.

      IBS$5     The B argument causes the 7 positions  of  the  field  to
                print  as  7  spaces if the data would print as 0.  The B
                does not add a position to the output field.  Without the
                B,  zero  data  prints  as  "bbbbb$0" where b's stand for
                blanks.  Whatever the composition of  the  specification,
   PRINT FORMATS                                                 Page 6-5
   Revision 4


                the entire field prints as blanks for zero data when B is
                included.

      I5.3      The number after the period specifies how many  positions
                of  the total field of 8 characters always print a digit,
                never a blank.  The first 5 positions print blanks if not
                filled with a digit.

      I0.8      This has the same field width as the last  specification,
                8  positions.  All 8 print a digit, producing leading 0's
                instead of blanks.

      I$5..2    Doubling the period separator makes a  period  appear  in
                that  position  on the output.  This specification prints
                an integer as a dollar  amount  with  a  dollar  sign,  5
                positions for dollars, a decimal point, and two positions
                for pennies.  The last two positions always print digits.


   Notes:

   1. You may print Real data under I.  I retains only the  integer  part
      of the data without rounding.

   2. Asterisks print in all numeric positions if the data is  too  large
      to print in the allowed space.

   Examples:

             DATA                SPECIFICATION       RESULT

             5                   I5                  bbbb5
             0                   I5                  bbbb0

             5                   I3.2                bbb05
             0                   I3.2                bbb00

             -5.999              I3.2                bbb05
             -5.999              IS3.2               bbb-05

             5                   I3..2               bbb.05
             5                   I3..0               bb5.
             538                 I$3..2              bb$5.38
             0                   IB$3..2             bbbbbbb
             7432                I2                  **

   PRINT FORMATS                                                 Page 6-6
   Revision 4


   6.2.2  O - Octal Format

   The letter O performs OCTAL editing.   The  OCTAL  specifications  are
   exactly  the  same  as  the I specifications above.  The numeric value
   prints in base 8.



   6.2.3  F - Floating Point Format

   The letter F edits  by  floating  point  rules.   Dollar  sign,  check
   protect,  and numeric signs have the same meaning as described before.
   Other argument choices follow.

      Choice    Meaning
      ------    -------

      F         F standing alone uses a System defined format to  display
                the   number  in  general  F  form.   See  "Omitting  the
                Specification" below.

      F5.2      This prints the number in a total field of  8  positions.
                The  integer  part of the data prints in 5 positions with
                leading blanks, then a decimal point,  then  the  decimal
                fraction  prints in 2 positions.  The fraction is rounded
                to yield the  best  approximation  in  that  space.   The
                fraction positions always print digits, never spaces.

      FS5.2     This prints the number in a field of  9  positions.   The
                extra  position,  not present in the last example, is for
                the numeric sign.   No  sign  prints  for  negative  data
                unless a sign position is specified.

      F5        The integer part of the data prints in 5  positions  with
                leading spaces and no decimal point.  The integer part is
                rounded according to the fractional part of the data.

      F5.0      The integer part of the data prints in 5  positions  with
                leading spaces and a following decimal point.  Again, the
                number is rounded.

      F5..2     This prints like F5.2, except that the decimal point does
                not print.  The output field is 7 positions.

      F0.5      This prints a decimal point followed by  5  positions  of
                the decimal fraction.

      FB$5.2    Nonzero data prints  with  a  preceding  floating  dollar
                sign,  5  digit  integer part, decimal point, and 2 digit
                fraction.  Zero data prints as all spaces.  The  data  is
                "zero" if normal printing would print all zeroes.

   PRINT FORMATS                                                 Page 6-7
   Revision 4


   Notes:

   1. You may print integer data under F; the fractional part  is  filled
      in as 0.

   2. Asterisks fill the numeric positions when the integer part  is  too
      large to print in the space allowed in an F specification.

   Example:  DATA      SPECIFICATION       RESULT

             5.334     F3.3                bb5.334
             -5.334    FS3.3               bb-5.334
             -5.334    F3..3               bb5334
             0         F3.3                bbb.000

             5.12      F$3.2               bb$5.12
             1000      F$3.2               $***.**
             512.      F$3..2              $51200



   6.2.4  E - Exponential Format

   The letter E edits in Scientific  or  Exponential  form.   The  number
   prints  as a floating value with an exponent field denoting a power of
   10.  The true value is the  printed  number  with  the  decimal  point
   shifted left or right by the positive or negative power of 10.

   The E format is flexible enough to print numbers  in  a  normal  range
   with  0  exponents  so  that  they may be interpreted easily.  Numbers
   outside that range revert to the most accurate representation possible
   in the space allowed.

   The basic E format prints a number in the form:

        +.nnnnnnnE+mm

        For example:   -.34567E+05  (the value -34,567)

   The construction of the E format allows the characters $ *  +  S  with
   their normal meanings.  The meanings of the other arguments follow:


      Choice    Meaning
      ------    -------

      E         E standing alone uses a System defined format to  display
                the   number  in  general  E  form.   See  "Omitting  the
                Specification" below.

      E0.7      This prints the number in a field of  0+1+7+4  positions,
                in  classic scientific notation.  This means in 0 leading
                positions, a decimal point, 7 fractional positions, and 4
   PRINT FORMATS                                                 Page 6-8
   Revision 4


                E-field  positions.   It  prints  no  numeric  sign.  The
                E-field sign always appears, either + or -.

      E+0.7     This is the same specification, with the  addition  of  a
                leading sign which prints just before the decimal point.

      E0.7+     This prints the numeric sign just after the 7  digits  of
                the fraction, and before the E-field.

      EB0.7+    The Blank switch works with E specifications.

      E+5.2     The E format attempts to print the data in F form when an
                "integer" part (5) appears in the specification.

                The data prints as an F format number, with an E-field of
                E+00,  when the integer part of the data fits the integer
                part of the specification and the data is greater than or
                equal to 0.1 .

                Otherwise, the leading and trailing fields  are  combined
                and  used  to  print  the  number  in  classic scientific
                notation with no digits preceding the decimal point.   In
                this  case, the field prints as if the specification were
                E+0.7.

                Numbers within range are  easy  to  read,  while  numbers
                outside  the range are represented in as many significant
                digits as possible.


   Notes:

   1. You may print integer data under the E format;  it  prints  with  a
      zero fractional part.

   2. It is impossible for a number  to  exceed  the  capacity  of  an  E
      format; overflow *'s never appear.

   PRINT FORMATS                                                 Page 6-9
   Revision 4


      Example:

             DATA      SPECIFICATION       RESULT

             .5678     E3.4                bbb.5678E+00
                       E0.7                .5678000E+00

             12.5678   E3.4S               b12.5678bE+00
                       E0.7S               .1256780bE+02

             1234.5678 E3.4+               .1234568+E+04
                       E0.7+               .1234568+E+04

             1234.5678 E$0.7S              $.1234568bE+04
                       E$4.3S              $1234.568bE+00

             12.5678   E$4.3S              bb$12.568bE+00



   6.2.5  Omitting The Specification

   The I, F, or E specifications with no arguments treat the output in  a
   special way.

   Under I, 1022 prints the integer with a leading S-type  sign  and  the
   least  number  of  positions  required  to contain it.  The result "0"
   prints for zero data.

   Under F, 1022 prints the number in a  field  of  10  positions,  which
   allows  for  a  sign, decimal point, and 8 significant digits.  If the
   number does not fit this range or if at  least  4  significant  digits
   will not print, then the number prints in the format ES0.4.

   Under E, 1022 prints the number with the specification ES0.6.

   These specifications produce  acceptable  results  for  the  user  who
   wishes   to   define   a  format  quickly  and  get  results.   The  G
   specification described below also has this purpose.



   6.2.6  Scale Factors

   The user may scale data by factors of 10 in the output.  An example is
   where  dollar  amounts  are  calculated,  but the result is desired in
   thousands or millions.  The user does this by  preceding  any  numeric
   specification  (I,  E, F, G, P) with the specification "Mn" where n is
   an integer.  This is the same as shifting the  decimal  point  of  the
   data  n  positions to the right.  The M specification is not separated
   from the numeric specification it acts on.  Both integer and real data
   may be scaled.
   PRINT FORMATS                                                Page 6-10
   Revision 4


   Example:  DATA      SPECIFICATION       RESULT

             1.5       I5                   bbbb1
                       M1I5                 bbb15
             160       M-1I5                bbb16
             1.789     M2F3.2               178.90
                       E0.5                 .17890E+01
                       M3E0.5               .17890E+04



   6.3  D - DATE OUTPUT FORMATS

   The user prints a date by specifying one of the following forms.   The
   number  following  the D does not represent the field size, but rather
   the conversion type.   To  display  dates  in  a  nonstandard  format,
   consult  the  possibilities  for  a  PICTURE  format  used  with  a  D
   specification.   The  setting  of  the  system   variable   SYSDATEFMT
   determines  whether  dates  are  printed  in upper case or mixed case.
   When  SYSDATEFMT  is  1,  dates  are  printed  in  upper  case  (e.g.,
   WEDNESDAY),  and  when SYSDATEFMT is 0, they are printed in mixed case
   (e.g., Wednesday).

   Assume we print the date JANUARY 2, 1980, which is a Wednesday.

             D1        prints      JANUARYbb2,b1980bb
             D2        prints      JAN-02-1980
             D3        prints      b1/02/1980
             D4        prints      19800102
             D5        prints      WEDNESDAY

   D1 prints in 18 columns filled out to 18 positions with blanks.   This
   accommodates the different length names of the months.  D2, D3, and D4
   print in  11,  10,  and  8  columns,  respectively.   D5  prints  left
   justified in 9 columns.  Printing a date under "I" format prints it as
   if it were in D4 format.  Printing a date under "G" format  prints  it
   as if it were in D3 format.



   6.4  TEXT FORMATS

   6.4.1  A - ASCII Specification For Text

   The letter A formats text data.  The forms are:

      Choice    Meaning
      ------    -------

      A         Without arguments, A prints the  text  data  without  any
                trailing  blanks.   The  output field is variable length,
                depending on the contents of the data.   Display  numbers
                print exactly as they appear in the data set.
   PRINT FORMATS                                                Page 6-11
   Revision 4


      A8        A single argument specifies  the  width  of  the  printed
                field.   The  first 8 characters of the data are printed.
                Short data is filled out on the  right  to  8  characters
                with blanks.

      A8.6      A second argument is the skip count.   6  characters  are
                skipped before the next 8 characters are printed.

   Example:

      The  text  data  is  12  characters  long,  containing   the   text
      "ANTHONYbbbbb".

         A    prints   ANTHONY
         A5   prints   ANTHO
         A12  prints   ANTHONYbbbbb
         A15  prints   ANTHONYbbbbbbbb
         A5.3 prints   HONYb



   6.4.2  S - Scrolling Specification

   Scrolling takes long lines of text data or many fields  of  that  data
   and  prints  the  data within a limited field on the output page.  The
   information is scrolled onto successive lines until  it  runs  out  or
   until  a  maximum  line limit is reached.  The data is placed onto new
   lines by breaking it between words  at  spaces.   Up  to  20  scrolled
   fields  may  be  specified on any one output format line.  No scrolled
   field may extend beyond column 400.

   The S specification has the form:

        S<width>[.<line limit>[.<data length>[.<skip count>]]]

   Where:

   <width>        Specifies the number of columns to use for the scrolled
                  field,  starting  at the current position in the output
                  line.

   <line limit>   Is optional, and specifies the maximum number of  lines
                  allowed  to  scroll the data for this field.  Data that
                  does not fit is discarded.  If this argument is 1  then
                  no extra lines are scrolled.  The default value is 10.

   <data length>  Is optional, and specifies the number of characters  of
                  the  data  item  to use.  This is the same as the first
                  argument to the A specification.

   <skip count>   Is optional, and specifies the number of characters  of
                  the  data to skip before applying the data length.  The
                  skipped characters are ignored.  This is  the  same  as
   PRINT FORMATS                                                Page 6-12
   Revision 4


                  the second argument to the A specification.

   Example:  Consider the following  PRINT  statement  and  the  possible
   scroll specifications:

        PRINT 'BOY DOG CAT PET' FMT '**' <scroll-spec> '**' END

        <scroll-spec>          Output

        S10                    **BOY DOG   **
                                 CAT PET

        S10.1                  **BOY DOG   **

        S10.10.5               **BOY D     **

        S10.10.5.2             **Y DOG     **




   6.4.2.1  Appending To A Scrolled Field

   The S specification handles the transfer  of  one  data  item  to  the
   output  field.   Additional items may be scrolled into this same field
   by using the SA (Append) option.  The SA specification is:

        SA[<data length>[.<skip length>]]

   The <data length> and  <skip  length>  are  the  same  as  for  the  S
   specification  and  apply  to  the  data  item  being  appended.   The
   characters from the data item are appended to the  previous  scrolling
   specification.   The  SA specification immediately follows a scrolling
   specification.   The  width  and  line  limit  from  the  preceding  S
   specification  still apply.  The result is the same as if the new data
   were a part of the original data.

   Example:  Consider the following PRINT statement

        PRINT 'BOY DOG' 'CAT PET' FMT '**' <scroll-spec> '**' END.

        <scroll-spec>          Output

        S11 SA                 **BOY DOGCAT **
                                 PET

        S5 SA5                 **BOY  **
                                 DOGCA
                                 T P

        Note that the data above is scrolled as if it were a single
        field:  'BOY DOGCAT PET'.
   PRINT FORMATS                                                Page 6-13
   Revision 4


   6.4.2.2  Special Scrolling Options

   The following modes control multiple fields and  separators  within  a
   single  field.   A  mode applies only to the specification in which it
   appears;  it must be present in  each  specification  to  have  effect
   there.   Specify a mode by putting the mode letter just after the S or
   SA and before the numeric arguments, if any.

|  Mode letter       Meaning

   none              Standard string mode.  Trailing spaces in  the  data
                     item  count as characters.  Embedded linefeeds, <CR>
                     <LF> combinations, and formfeeds cause the scrolling
                     to  go  to  the next scroll line.  Embedded tabs are
                     converted to three spaces.  All  separators  (space,
                     tab,  linefeed)  are discarded when going to another
                     scrolling line.  An  SA  specification  is  directly
                     appended to the previous data.

   T                 Delete trailing spaces.   Trailing  spaces  in  this
                     field are discarded.  Tab characters count as spaces
                     and are discarded.  Linefeeds and formfeeds are  not
                     discarded;  they  cause  previous spaces to count as
                     well.  An all space field is completely discarded in
                     T  mode,  but acts as a separator in standard string
                     mode.

   L                 List  mode.   Like  T  above,  trailing  spaces  are
                     ignored.   When this field is appended under SA to a
                     previous field, one space is added as a separator if
                     the  previous  field did not end with a space.  This
                     properly separates and scrolls a list of data  items
                     provided in separate SA specifications.

   S                 Scroll mode.  Trailing spaces are not  deleted,  but
                     all  strings of separators are collapsed to a single
                     space, including formfeeds and linefeeds.  This mode
                     is most similar to text processors which fill but do
                     not justify the data.

   The various modes may be  used  separately  in  sequence  for  special
   effect,  because  each  mode applies only to the data item transmitted
   under that specification.

   Usually linefeeds, formfeeds, and tabs are not included in text  data,
   but  the  above  descriptions  indicate how these cases are handled if
   they occur.
   PRINT FORMATS                                                Page 6-14
   Revision 4


   Example:  Consider the following PRINT statements:

        PRINT  'BOY  ' 'DOG  ' 'CAT  ' 'PET  ' FMT '**' <scroll-spec>
             '**' END

             <scroll-spec>          Output

             S13 3(SA)              **BOY  DOG  CAT**
                                      PET

             ST13 3(SA)             **BOYDOG  CAT  **
                                      PET

             ST13 3(SAT)            **BOYDOGCATPET **

             SL13 3(SAL)            **BOY DOG CAT  **
                                      PET


        PRINT 'B  O  Y' '   D  O  G' 'CA' 'T' FMT '**' <scroll-spec>
             '**' END

             <scroll-spec>          Output

             SL13 3(SAL)            **B  O  Y    D **
                                      O  G CA T

             SS13 3(SAS)            **B O Y D O GCA**
                                      T



   6.4.3  G - General Purpose Format

   The G specification is an all-purpose format which  prints  any  data.
   1022  itself uses this specification as a default if the user does not
   specify a FORMAT.

   Text data printed with Gn is equivalent to output under An.  G without
   an  argument  prints  a text field in full, including trailing blanks.
   The text prints in the same number of positions as it contains.

   The G format defaults to I for integer data and F for real data.

   The G specification can have an integer argument, like G10.  1022 puts
   the  output  into  10  columns under the resulting format.  A G format
   without an argument prints like an I  or  F  specification  having  no
   arguments.
   PRINT FORMATS                                                Page 6-15
   Revision 4


   For example, if we print with the format G6 we obtain:

             DATA      RESULT

             456       bbb456
             -456      bb-456
             -12456    -12456
             45.43     b45.43
             454.3     b454.3
             0         bbbbb0
             0.0       b.0000
             1.0       b1.000

   A date item printed under G format uses D3 as a default.



   6.5  LITERALS

   6.5.1  NH - Hollerith Specification

   The nH specification is exactly like the one in FORTRAN.  The n counts
   how  many  characters  and  spaces  after  the  H  are  to  be printed
   literally.  This does not work for the pound sign  (#),  the  at  sign
   (@),  Carriage Return, Line Feed, or TAB unless they are quoted with ^
   (up-arrow).

             SPECIFICATION RESULT

             5HNAMEbi       NAMEb
             1H$           $
             5HbbbXX       bbbXX
             1H^<LF>        <LF>  (the character itself)




   6.5.2  Quoted Literals

   Single or double quotes  print  constant  strings  without  needing  a
   count.   The first quote mark, single or double, controls the literal.
   Most non-printing characters may be included;  any  character  can  be
   included by quoting it with ^.

   SPECIFICATION       RESULT

   'NOW IS THE TIME'   NOWbISbTHEbTIME
   1H' 'THEN' 1H'      'THEN'
   "'THEN'"            'THEN'
   "<CTL-A>"           <CTL-A>  (the character itself)
   "^<LF>"             <LF>  (the character itself)
   "^^"                ^
   PRINT FORMATS                                                Page 6-16
   Revision 4


   6.6  P - PICTURE EDITING

   P specifies a small editing routine for  any  numeric  or  text  data.
   This  specification  is  similar to a COBOL picture.  Unlike COBOL, it
   does not specify the way the data is stored;  it affects only printing
   the data.

   A P specification specifies what is done for each character of output.
   It contains a control letter for each position.

   Any sequence  of  identical  control  letters  is  referred  to  as  a
   SUBFIELD.   In  the  word  999ZZZBBB we speak of the 9 subfield, the Z
   subfield, and the B subfield.

   The PICTURE specification control characters are:

        9    Exact character
        Z    Leading 0 suppress
        $    Floating dollar sign
        *    Check protect field
        +    Sign specifier:  +  if positive, - if negative
        S    Sign specifier:  blank if positive, - if negative

        V    Decimal alignment, nonprinting
        .    Decimal alignment, printing

        B    Insert a blank
        ,    Comma, prints if significant, otherwise is a space
        X    Do not print the character in this position
        Qx   Literal x
        Nx   Print x if a negative value
        Wx   Switch x

   Other characters (and repeated occurrences of . and V) are included in
   the  output  as  they  appear,  including  characters  such as / and -
   and : .  However, all alphabetic characters are  reserved  for  future
   use as Picture switches.  Use the Q (literal) switch in the PICTURE to
   insert alphabetic literals in pictures.



   6.6.1  Numeric Control Group

   Control characters in the first group (9 Z $ * + S) reserve  positions
   for the printed number.  If a subfield of $, +, or S has only a single
   character, then that position is  reserved  for  that  symbol.   If  a
   subfield  of  $,  +,  or S  has  n characters in it, then n-1 of those
   positions are filled with a digit of the  number  and  one  holds  the
   specified symbol.

   9 Character   _ _________

   A subfield of 9 places  a  digit  of  the  number  in  each  position.
   PRINT FORMATS                                                Page 6-17
   Revision 4


   Leading zeroes of the number print as 0.

              DATA                SPECIFICATION       RESULT

              1                   P999                001

   A subfield of 9's processes text as An does.

              DATA                SPECIFICATION       RESULT

              ABCDE               P999                ABC

   Z Character   _ _________

   A subfield of Z places a digit of the  number  in  each  position.   A
   leading 0 digit before the decimal point prints as a space.

              1                   PZZZ                bb1

   The  9  and  Z  characters  are  used  together  to  control  printing
   insignificant digits of a number.

              DATA                SPECIFICATION       RESULT

              0                   PZZZ99              bbb00
              0                   PZZZZZ              bbbbb
              0                   P99ZZZ              00bbb
              1                   P99ZZZ              00bb1

   A subfield of Z's process text as An does.


   $ Character   _ _________

   A single $ as a subfield prints a $ in that position.

              DATA                SPECIFICATION       RESULT

              0                   P$ZZZ99             $bbb00
              5                   PZZZ$99             bbb$05
              789                 PZZZ$99             bbb789

   A subfield of many dollar signs acts like a subfield of Z and a dollar
   sign  prints  in  front  of  the  first  significant digit.  Should no
   significant digits occur in  the  subfield,  then  the  last  position
   prints a dollar sign.
   PRINT FORMATS                                                Page 6-18
   Revision 4


              DATA                SPECIFICATION       RESULT

              0                   P$$$$               bbb$
              1                   P$$$$               bb$1
              0                   P$$$ZZ99            bb$bb00
              12345               P$$$ZZ99            b$12345


   + and S Characters   _ ___ _ __________

   The + and S sign specifiers are similar to $.

   A single + or S prints the indicated sign in that position.  Many in a
   subfield print the sign in front of the first significant digit, or if
   there are no  significant  digits,  then  the  last  position  of  the
   subfield prints the sign.  Unused leading positions print spaces.

   Each + or S following significant characters prints a sign,  and  does
   not  print  any  digits  of  the  number.  A + or S must appear in the
   specification to print a sign;  otherwise only the absolute  value  of
   the number is printed.

              DATA                SPECIFICATION       RESULT

              0                   P+++++              bbbb+
              -5                  P+++++              bbb-5
              -5                  P++ZZZ              b-bb5
              5                   PSSZ99              bbb05
              -5                  PSSZ99              b-b05

              5                   P++Z99              b+b05
              12                  PZZ+++              12+++


   * Character   _ _________

   The *, check protect control character, is similar to the Z character,
   with  the difference that leading insignificant digits are replaced by
   a  *  to  prevent  changing  the  printed  number   through   physical
   alteration.  If all positions used by the * are significant, then no *
   prints.

              DATA                SPECIFICATION       RESULT

              0                   P*****              *****
              55                  P*****              ***55
              0                   P***Z9              ***b0
              33                  P$***9              $**33
              33                  P$**                $33
   PRINT FORMATS                                                Page 6-19
   Revision 4


   6.6.2  Decimal Point Alignment Group

   The decimal alignment control characters align the  decimal  point  in
   the  data  to  a fixed position within the PICTURE specification.  All
   digits following the decimal position are significant for the purposes
   of the other control characters.


   V Character   _ _________

   The first occurrence of a V in the PICTURE  specification  aligns  the
   decimal point in that position without printing a decimal point.

              DATA                SPECIFICATION       RESULT

              53                  PZZZVZZZ            b53000
              53.78               PZZZVZZZ            b53780
              53.78               P$ZZVZZZ            $53780


   . (Period) Character   _ ________ _________

   A period (.) included in the PICTURE specification acts like V  except
   that the decimal position prints a period in the output.

              DATA                SPECIFICATION       RESULT

              53.78               PZZZ.ZZZ            b53.780
              53.78               P$$$.ZZ             $53.78
              53.78               P$****.**           $**53.78



   6.6.3  Special Editing Group

   The control  characters  in  this  group  carry  out  special  editing
   functions.   Implicit  in  this  group  are  all nonalphabetic special
   characters, except the up-arrow, which  are  not  control  characters.
   The  alphabetic  characters  are reserved for future control features.
   Special characters in a PICTURE  specification  are  included  in  the
   output.

              DATA                SPECIFICATION       RESULT

              123456789           P999-99-9999        123-45-6789
              123056              P99/99/99           12/30/56


   PRINT FORMATS                                                Page 6-20
   Revision 4


   B Character   _ _________

   The B character inserts a space in its position.  The inclusion of  an
   actual space in the PICTURE specification would end the specification.

              DATA                SPECIFICATION       RESULT

              6172223333          P999B999B9999       617b222b3333



   , (Comma) Character   _ _______ _________

   The comma character represents large numbers in standard  format  with
   commas.   If  a significant character has been processed at the time a
   comma is encountered,  the  comma  prints  as  a  comma  (,).   If  no
   significant  characters  have  been  processed,  the comma prints as a
   space.  Thus all numbers align properly, but no leading commas  print.
   If the user has specified * for check protect purposes, then the comma
   (,) changes to a * if no significant characters have been processed.

              DATA                SPECIFICATION       RESULT

              1234567.88          P$Z,ZZZ,ZZZ.ZZ      $1,234,567.88
                   67.88          P$Z,ZZZ,ZZZ.ZZ      $bbbbbbb67.88

                   67.88          P$*,***,***.**      $*******67.88
                 4567.88          P$*,***,***.**      $****4,567.88

                   67.88          P$9,999,999.99      $0,000,067.88


   X Character   _ _________

   The X suppresses a character from the output.  Use this to select part
   of a number for printing, or in text editing.  Example:

              DATA                SPECIFICATION       RESULT

              126345              P99X999             12345
              100000              P9XXXXX             1
              ABCDEF              P99XX99             ABEF



   Q Literal Flag   _ _______ ____

   The Q introduces the next character or  space  in  the  Picture  as  a
   literal  character.   Use  Q  to  include  any non-numerical character
   (except # which must be quoted with ^) in the output.   The  group  Qx
   counts as 1 character in the length of the picture.

   PRINT FORMATS                                                Page 6-21
   Revision 4


              DATA                SPECIFICATION       RESULT

              123456              PQA999QB999QC       A123B456C
              200                 PQ$999               $200



   N Print If Negative Value   _ _____ __ ________ _____

   The N switch prints the next character if the data  is  negative.   It
   prints  a  blank if the data is positive or 0.  The group Nx counts as
   two characters in the length of the Picture.

   Example:

              DATA                SPECIFICATION       RESULT

               50.33              PN($$$.$$N)         b$50.33b
              -50.33              PN($$$.$$N)         ($50.33)


   W Switches   _ ________

   The W character introduces switches which change the operation of  the
   Picture.

        WB   Blank On Zero

   This switch prints picture positions as blanks if the numeric data  is
   zero.   This  means that all positions, including any included literal
   data, print as blanks, in the same number of columns as other nonblank
   data.   This preserves the columnar form of reports where this feature
   is used.  This switch counts as no characters in  the  length  of  the
   Picture.

   Example:

              DATA                SPECIFICATION       RESULT

              .1                  P+ZZ.Z              +bb.1
              .01                 P+ZZ.Z              +bb.0
              0                   P+ZZ.Z              +bb.0

              .1                  PWB+ZZ.Z            +bb.1
              .0l                 PWB+ZZ.Z            bbbbb
              0                   PWB+ZZ.Z            bbbbb

   PRINT FORMATS                                                Page 6-22
   Revision 4


        WP   Parentheses Around Negative Values

   This switch replaces a leading minus sign with an open parenthesis and
   automatically  prints  a  close  parenthesis  after  the last position
   specified in the print format.   With  positive  numbers,  a  trailing
   space  is  printed.  This switch differs from the N switch in allowing
   the open parenthesis to float and must be used in conjunction with the
   sign character + or S.

   Example:

              DATA                SPECIFICATION       RESULT

              -50.95              PSSSS.99             -50.95
               50.95              PSSSS.99              50.95
              -50.95              PS$$$.99            -$50.95
               50.95              PS$$$.99             $50.95
              -50.95              P+$$$.99            -$50.95
               50.95              P+$$$.99            +$50.95

              -50.95              PWPSSSS.99           (50.95)
               50.95              PWPSSSS.99            50.95
              -50.95              PWPS$$$.99          ($50.95)
               50.95              PWPS$$$.99           $50.95
              -50.95              PWP+$$$.99          ($50.95)
               50.95              PWP+$$$.99          +$50.95



   Special Editing Examples   ________________________

        1. Printing the user's own date.

        21784      under   P99/99/^'99 becomes   02/17/'84

        2. Printing part of an ID number.

        21300645   under   P999XXXXX   becomes   213



   6.6.4  Combinations With Other Formats

   1. You may scale data using the M specification and print it with  the
   P specification; follow the M specification with the P specification.

   Example:

        We wish to take money in tenths of a cent and print  out  dollars
        with a decimal and commas.

        DATA       SPECIFICATION       RESULT

        1234567    M-3P$ZZ,ZZZ.ZZ      $b1,234.57
   PRINT FORMATS                                               Page 6-22A
   Revision 4


   2.  You may start with a standard date  specification  and  print  the
   result  differently.  For example, if we print the date MARCH 18, 1979
   under different formats we get:

             FORMAT              RESULT

             D3                  b3/18/1979
             D3P99X-99X-XX99     b3-18-79
             D3P99XXXX-XX99      b3-79



   6.6.5  Picture Contractions

   As a convenience in typing picture specifications, the user  need  not
   type  long  strings  of  identical  characters.   The user repeats any
   control character by typing C(n), where C is the control character and
   n is the number of times it appears.

        P999999999     is typed       P9(10)
        PZZZZZ*****    is typed       PZ(5)*(5)
   PRINT FORMATS                                               Page 6-22B
   Revision 4



   PRINT FORMATS                                                Page 6-23
   Revision 4


   6.6.6  Limitations On The Picture

   Type a PICTURE Specification as a  continuous  string  of  characters,
   terminated   with   a  space.   A  limit  of  50  characters  (implied
   characters) may be specified in any one PICTURE specification.

   When you combine  other  formats  with  the  P  specification,  the  P
   specification is last.

        D3P99X-99X-99    Is correct
        P99X-99X-99-D3   Is incorrect, if intended to mean the same
        P9(50)           Is correct
        P9(51)           Is too big for a PICTURE specification






   6.7  POSITIONAL SPECIFICATIONS

   Positional specifications specify where the formatter places items  on
   the  line  (carriage  control) and how many blanks to generate between
   printed lines (paper motion).



   6.7.1  X - Blanks

   The nX specification generates n spaces in the output.

   For example:          "ABC" 3X "DEF" prints ABCbbbDEF

   For convenience, this specification may immediately precede any  other
   specification without a separating space.  For example, the formats 3X
   I5 and 3XI5 are equivalent.



   6.7.2  T And NT - Horizontal Tabs

   The letter T standing alone inserts a TAB character into  the  output.
   The  effect  of this character on printing depends on the device it is
   printed on, and on the tab conventions set up for the device.  Usually
   a TAB causes the output to skip to the next column in the group 1 9 17
   25 33 etc.  (every 8th column starting with column 1.)

   The nT specification, like 30T, causes the next output  specifications
   to  write  from column n on the output line.  The parameter n can have
   any value on the line between 1 and 400, meaning  that  the  user  can
   skip  ahead  over  unprinted  positions,  or  back  up  and  overwrite
   positions which were written or skipped earlier in printing  the  same
   line.
   PRINT FORMATS                                                Page 6-24
   Revision 4


   1022 can do this because each line is assembled in memory before being
   output to a file or device.  The nT specification changes the internal
   position to be used next for placing characters.

   System 1022 keeps the first 400 characters of the output  line  inside
   its  memory.   Lines  longer than 400 characters can still be written;
   when the forming line exceeds that length, the  first  400  characters
   are  written  to make space for the next 400 characters.  So, there is
   no limit on the total length of an output line, and formats write  any
   number  of characters before ending, or starting a new line.  However,
   the nT specification works only when the original 400  characters  are
   in memory.

   Use nT for formatting within the first 400  characters  on  an  output
   line.  Do not use it after position 401 is written for any line.

   Example:

   1. PRINT "A" "B" "C" FORMAT A T A T T A END.

      Prints:  A <tab>   B <tab><tab>     C <RET>
      Column:  1         9                25

   2. PRINT "ABC" "DEF" FORMAT "0123456789" 1T A 11T A END.

      Prints:  ABC3456789DEF <RET>
      Column:  1         11



   6.7.3  Slash Character (/) - New Lines

   The slash (/) outputs the present line and starts a  new  line.   This
   line is in addition to any automatic lines generated at the end of the
   format statement (see below).  The slash does  not  follow  any  other
   specification  without  an  intervening  space,  but  it  can directly
   precede any specification.

   Example:

      PRINT "A" "B" "C" FMT A / A / A END.

      prints:   A<RET>
                B<RET>
                C<RET>
   PRINT FORMATS                                                Page 6-25
   Revision 4


   6.7.4  Paper Motion Control (C)

   The  C  specifications  are  a  family  which   control   line-to-line
   positioning  using carriage returns, linefeeds, and formfeeds, between
   lines.  All actions of the C format specifications are done  logically
   according  to  the  body  size of the output page.  Line numbers given
   below assume a body size of 60 printing lines.

   The automatic <RET> at the end of a format  is  suppressed  when  a  C
   specification is the last specification.

   When many lines are  skipped  logically,  the  character  sequence  is
   <CR><LF><LF>...<LF>,  n linefeeds are used to skip n lines.  The codes
   and functions are:

   C1   Go to the next top-of-form regardless of present position.

   C2   Go to top-of-form if not already at that position.  Do not create
        blank pages.

   C3   Go to the next half-page, the next line 1 or 31.

   C4   Go to the next one-third page, the next line 1, 21, or 41.

   C5   Go to the next one-sixth page, the next line 1, 11, 21,  31,  41,
        or 51.

   C6   Go to the next triplet line, the next 1, 4, 7, 10, etc.

   C7   Go to the next double line , the next 1, 3, 5, 7, 9, etc.

   C8   Go to the next line regardless of page  position.   This  crosses
        over  the  perforations of a line printer page.  C8 generates the
        printer control character with octal code 23  (Control-S).   Your
        printer  or  terminal must specially recognize this code in order
        for C8 to function.  This function is useful for printing  across
        the   perforations   on   a   printer  with  automatic  new  page
        positioning.

   C9   Generate a carriage return only (no  linefeed).   The  next  line
        will overprint this one.

   C20  Use only when output is directed to the  user's  terminal.   Stop
        the  output, ring 2 BELL's, and wait for <RET> to be typed before
        continuing.  This allows the user to align forms if necessary.
   PRINT FORMATS                                                Page 6-26
   Revision 4


   6.7.5  $ - Operations Control

   The dollar sign specification is  a  switch  to  the  formatter  which
   chooses different modes of operation.

   $    This specification,  standing  alone,  suppresses  the  automatic
        <RET>  normally  printed at the end of any format.  The switch is
        turned off  when  the  next  automatic  line  is  generated,  and
        suppressed, in the format.  An automatic line is generated at the
        end of a format, or whenever the format loops  in  an  indefinite
        repeat  of  a  parenthetical group (see below).  This switch does
        not affect new lines specified by the user.

   $1   This  suppresses  the  follow  scan  operation  of   the   FORMAT
        statement.  See "Ending a Format" below.

   $2   This restores the follow scan operation of the FORMAT.

   $3   Suppress automatic heading and footing output until $4 is seen in
        a  format.   This  is  used  primarily in "ON START" and "ON END"
        statements in reports to suppress the heading and footing for the
        cover  page  and end pages of a report.  Or, by starting a format
        with $3, and ending with $4, the user can suppress  headings  and
        footings during the printing of any format.

   $4   Restore heading and footing output.



   6.8  REPEATED GROUPS WITHIN FORMATS

   The formatter repeats specifications grouped together by  parentheses.
   The  user  can  collect  specifications  into a formatting group which
   handles part of a line repeatedly, or whole lines repeatedly.

   To print a line number, followed by 4 dollar amounts use this format:

        FORMAT I5  4(2X  I$4..2) END

   This produces a line like:

        23    $54.23  $1234.67   $456.78    $33.22

   The user can do whole line groups  by  including  a  carriage  control
   within the repeated group.

        FORMAT    40(I5  4(2X I$4..2) /) $ END

   This format supplies specifications for 40 lines;  each line prints in
   the format of the previous example.  It might be difficult to supply a
   print statement  with  that  many  arguments  to  satisfy  the  format
   statement, but it is an example of what can be done.
   PRINT FORMATS                                                Page 6-27
   Revision 4


   The user could specify an all-purpose general  format  for  placing  7
   data  items  per line, each taking up 10 spaces and separated from one
   another by 1 space, with the format:

        FORMAT 7( G10 1X ) END

   If a number precedes a parenthetical group, the  formatter  scans  the
   group  that  number of times before continuing the scan of the format.
   Parenthetical repeating groups may be placed inside one another to  10
   nested levels.

   In the second format example, the $ just before the END of the  format
   suppresses  the  automatic  <RET> that would normally end that format.
   We have already supplied the ending <RET> with the slash in the  outer
   repeating group.

   The user may omit the number from in front of a  parenthetical  group.
   The  formatter repeats that group indefinitely until the print list is
   exhausted.  In this case,  whenever  the  formatter  hits  the  ending
   parenthesis,  it  generates an automatic line unless suppressed by a $
   before the ending parenthesis.



   6.9  ENDING A FORMAT

   If the print list of attributes and variables  is  too  long  for  the
   FORMAT specification, it starts another scan from the beginning of the
   FORMAT;  it is impossible for the FORMAT to end before the  data  list
   runs out.  The format outputs a <RET> when it repeats this way.

   When the data list is exhausted, the FORMAT ends with a "follow scan",
   which  continues  to  interpret  the  format  list  until  it  hits  a
   specification requiring more data, where it stops for  lack  of  data.
   The  user can stop this follow scan with the specification $1, or turn
   it on, to its starting value, with $2.

   After the follow scan, the FORMAT generates a <RET> to  end  the  line
   unless suppressed by the $ specification.

   Examples:

        Assume that the two values, 23 and 34,  are  transmitted  to  the
        example formats.


        FORMAT "VAL1" I3 1X "VAL2" I3 1X "VAL3" I3 END

             produces

        VAL1 23 VAL2 34 VAL3<RET>
   PRINT FORMATS                                                Page 6-28
   Revision 4


        FORMAT $ "VAL1" I3 1X "VAL2" I3 1X "VAL3" I3 END

             produces

        VAL1 23 VAL2 34 VAL3        (no <RET> follows)

        FORMAT $1 "VAL1" I3 1X "VAL2" I3 1X "VAL3" I3 END

             produces

        VAL1 23 VAL2 34<RET>     (no follow scan)

   Avoid typing the exact string "END" in the middle of any FORMAT unless
   it is part of another character string, such as in XEND or "END".  The
   input scanner will think that this text  is  the  end  of  the  FORMAT
   statement, and an error will result.

   Do not divide individual  format  specifications  across  the  end  of
   lines,  unless you suppress the input of the <RET> with a "-".  <RET>s
   between specifications are the same as spaces and can be used  freely.
   In the interactive mode, 1022 continues FORMAT statements from line to
   line automatically, as it is a common error to enter a  <RET>  without
   entering the word END at the end of the FORMAT.
   PRINT FORMATS                                                Page 6-29
   Revision 4


   6.10  SUMMARY OF OUTPUT FORMAT TYPES


   Numeric Output Formats

        I    Integer
        F    Floating point
        E    Exponential
        O    Octal
        P    Picture
        G    General

   Text Output Formats

        A    ASCII
        P    Picture
        G    General
        S    Scrolling

   Date Output Formats

        D1   Full Date                 MARCHb18,b1972bbbb
        D2   Hyphenated Date           MAR-18-1972
        D3   Slashed Date (MM/DD/YYYY) b3/18/1972
        D4   ANSI Standard Date        19720318
        D5   Day of Week               SATURDAYb
        A    ANSI Standard Date        19720318
        G    General--uses D3 format   b3/18/1972

   Literals

        H    Hollerith
        " "  Quoted Literals
        ' '  Quoted Literals

   Positional

        X    Blanks
        T    Horizontal tabs
        nT   Absolute tab
        /    New Lines
        C    Carriage Control

   Switches

        $    Suppress <RET> at the end of line (at the end of the FORMAT)
        $1   Turn off follow scan
        $2   Restore follow scan
        $3   Suppress headings and footings for reports
        $4   Restore headings and footings
   PRINT FORMATS                                                Page 6-30
   Revision 4















                                 CHAPTER 7

                       SPECIAL COMMANDS AND FEATURES



   The commands described in this chapter are used for special  purposes,
   such  as  displaying  information  about  current  data structures and
   system settings or temporarily leaving the 1022 environment to perform
   various monitor-level functions.  These commands are:


   INFORM         Displays data set characteristics.   _
|  
|  KEY $CHECKSUM  Shows whether key tables have been damaged.   ___ _________
|  
|  KEY $SCAN      Displays statistical information about  key  table   ___ _____
|                 fragmentation and space usage.
|  
|  KEY $VERIFY    Displays information about key table damage.   ___ _______
|  
   TECO           Accesses a TECO text editor and preserves the 1022   __
                  environment.

   SOS            On TOPS-15, SOS accesses  the  SOS  editor  within   ___
                  1022  while  preserving  the 1022 environment.  On
                  TOPS-20, SOS accesses the text editor  defined  as
                  EDITOR:    on   EXEC  while  preserving  the  1022
                  environment.

   EDIT           On TOPS-15, EDIT  accesses  the  SOS  text  editor   ____
                  within  1022  and  preserves the 1022 environment.
                  On TOPS-20, EDIT accesses the text editor  defined
                  as  EDITOR:   on  EXEC  while  preserving the 1022
                  environment.

   MODIFY         Changes data set characteristics.   ___

   SET            Specifies 1022 characteristics.   ___

   RUN            Exits from 1022 and runs another program.   _

   TMPFILE        Places a string into TMPCORE.   ___

   PUSH           Suspends  System  1022  operations  and  goes   to   ____
   SPECIAL COMMANDS AND FEATURES                                 Page 7-2
   Revision 4


                  TOPS-20    EXEC   level,   preserving   the   1022
                  environment.

   FILE           Manipulates disk files.   ___

   USERCALL       Passes information from interactive 1022 to  MACRO   ________
                  routines.  TOPS-20 systems only.





   7.1  INFORM COMMAND

   The INFORM  command  displays  information  about  the  structure  and
   condition  of a data set.  The output formats make it easy to use this
   information in command files for later system commands.  The syntax of
   the command is:

                                 { ADMIT [ <user-id> ]                 }
                                 { ATTRIBUTE <attribute-name> [LENGTH] }
                                 { AUDIT                               }
                                 { BASE                                }
                                           { [ NAME ] }
                                 { COLLECT {          }                }
                                           { NUMBER   }
                                 { DAMAGE                              }
                                 { DATA                                }
|                                { DMX                                 } 
                                 { FILES                               }
                                        { [ NAME ] }
   INFORM [ON <file-descriptor>] { JOIN {          }                   }
                                        { NUMBER   }
                                 { NAMES                               }
                                 { SET                                 }
                                 { STATUS                              }
|                                            { [ TABLE  ] }
|                                { STRUCTURE { [ LENGTH ] }            }
                                             { [  DATA  ] }
                                 { VERSION                             }

   The ON <file-descriptor> clause is optional.  By default  the  command
   displays  its information to the terminal.  The ON clause displays the
   information to the named device and file.  Use of the ON  clause  here
   does not involve any of the assignable system output channels used for
   PRINT files.  This ON clause produces the file and closes  it  in  one
   operation.

   Exactly one option can be given in any INFORM command.
   SPECIAL COMMANDS AND FEATURES                                 Page 7-3
   Revision 4


   7.1.1  Option:  ADMIT [ <user-id> ]

   This prints the ADMIT information of  the  data  set.   The  <user-id>
   specification  is optional.  If it is omitted, all ADMIT provisions in
   the security structure of the data set are printed.  If a  user-id  is
   given, only the ADMIT information applying to that user-id is printed.
   On TOPS-10, a user-id is a project, programmer number, either or  both
   components  of which may be a wildcard (*).  On TOPS-20, a user-id may
   be either a project, programmer number, either or both  components  of
   which  may  be  a  wildcard,  or else a device plus a directory string
   which may end in a wildcard.  The device is optional.  When an  INFORM
   ADMIT command is given on TOPS-10, user-id information is printed just
   as it appeared in the original ADMIT commands.  When an  INFORM  ADMIT
   command  is  given  on  TOPS-20,  ADMIT  commands specifying directory
   strings are printed with the directory string preceded by the  device,
   while  ADMIT  commands  specifying  project,  programmer  numbers  are
   printed with the corresponding directory strings and no  device.   The
   INFORM  ADMIT command is restricted to use by the System Administrator
   or data set owner (see Chapter 11).

     * INFORM ADMIT     _
     ADMIT CLASS READONLY PASSWORD YYY  .
     ADMIT CLASS UPDATE PASSWORD ZZZ  .



   7.1.2  Option:  ATTRIBUTE <attribute-name> [LENGTH]

|  This prints the information about the specified attribute that appears
|  in  the data set's description (DMD) file.  In addition, as of version
|  117A, the message
|  
|            !PRE-117
|  
|  appears at the end of the line if the  attribute  is  keyed  or  keyed
|  inactive  and  the  data  set  is  in  pre-version  117A  format.  The
   attribute abbreviation can be substituted for the attribute name.  The
   LENGTH  option,  which  may  be  abbreviated LEN, prints the attribute
   length rather than column position.
|  
|  For example, assume that FIRST_NAME is an attribute in  a  pre-version
|  117A data set.
|  
|    * INFORM ATTRIBUTE FIRST_NAME     _
|    ATTRIBUTE FIRST_NAME ABBREV FN TEXT KEYED COLUMN 1 10 !PRE-117
|    * INFORM ATTRIBUTE FIRST_NAME LENGTH     _
|    ATTRIBUTE FIRST_NAME ABBREV FN TEXT KEYED LENGTH 10 !PRE-117
|  
|  At sites that have acquired the Large Data  Sets  Module,  the  INFORM
|  ATTRIBUTE  command further returns the name of the auxiliary file that
|  stores the key table of a keyed or keyed inactive attribute when  such
|  a file has been specified in the description file.
   SPECIAL COMMANDS AND FEATURES                                 Page 7-4
   Revision 4


|  For example, assume that the key table for the attribute LAST_NAME  is
|  stored in the auxiliary file AUX1.DMM.
|  
|    * INFORM ATTRIBUTE LAST_NAME     _
|    ATTRIBUTE LAST_NAME ABBREV LN TEXT KEYED KEYFILE AUX1.DMM COL 11 25
|    * INFORM ATTRIBUTE LAST_NAME LENGTH     _
|    ATTRIBUTE LAST_NAME ABBREV LN TEXT KEYED KEYFILE AUX1.DMM LENGTH 15



   7.1.3  Option:  AUDIT

   This prints the status of the audit trail for the current data set.

     * INFORM AUDIT     _
     AUDIT START FILE <DOC.MANUAL>WORDS.DML .
     AUDIT RECOVERY MODE MANUAL ALLOW QUERIES .



   7.1.4  Option:  BASE

   This prints the full data set-descriptors of all open data sets.

        * INFORM BASE        _
        TEST in <FRED>TEST.DMS ! is set #1
        WORDS in <FRED>WORDS.DMS ! is set #2



   7.1.5  Option:  COLLECT [ NAME ]

   This prints all the current collection names  and  their  constitutent
   data  sets.   For data set names, INFORM COLLECT displays the data set
   alias, if it exists, or the internal data set name.  Internal data set
   names may not be unique.  If data sets do not have aliases, use INFORM
   COLLECT NUMBER for unique identification.  This is important when  the
   output file is used later as a command file.

        * INFORM COLLECT        _
        COLLECT JANSAL FEBSAL MARSAL as FIRSTQ ADD MARSAL.
        COLLECT APRSAL MAYSAL JUNSAL as SECQ ADD JUNSAL.
        * INFORM COLLECT NAME        _
        COLLECT JANSAL FEBSAL MARSAL as FIRSTQ ADD MARSAL.
        COLLECT APRSAL MAYSAL JUNSAL as SECQ ADD JUNSAL.
   SPECIAL COMMANDS AND FEATURES                                 Page 7-5
   Revision 4


   7.1.6  Option:  COLLECT NUMBER

   This prints all the current collection names  and  their  constitutent
   data  set  numbers.  For number it displays the number 1022 assigns to
   each data set as it is opened.  The same number is displayed by INFORM
   SET and INFORM BASE.

        * INFORM COLLECT NUMBER        _
        COLLECT 1 2 3 AS FIRSTQ ADD 3.
        COLLECT 4 5 6 AS SECQ ADD 6.



   7.1.7  Option:  DAMAGE

   This prints the damage information (See Chapter 5,  Data  set  Damage)
   for  each  OPEN  data  set.  No message prints for data sets which are
   undamaged.  The message lists the data set name, number, and user-ids,
   and  the  date  and  time,  when the data set was first damaged.  This
   message is not removed by the IGNORE DAMAGE  command.   An  additional
   line  reports  the  time  of the most recent damage if the data set is
   damaged again after using the IGNORE DAMAGE command.

        * OPEN TEST        _
        Possible FILE DAMAGE (or UPDATE in progress) as of
        16:12.40 ON 5/4/79
        * INFORM DAMAGE        _
        TEST in <user>TEST.DMS     ! is set #1
        LAST DAMAGE by <user> on 5/4/79 at 16:12.40
        FIRST DAMAGE by <user> on 5/1/79 at 14:30.58



   7.1.8  Option:  DATA

   This prints the data file descriptor of  the  current  unbundled  data
   set.

        * INFORM DATA        _
        PS:<FRED>TEST.DMI  !  is the unbundled data file
|  
|  
|  
|  7.1.9  Option:  DMX
|  
|  The  INFORM  DMX  command  returns  information  about  the   run-time
|  environment  that must exist for the execution of a precompiled PL1022
|  or report program, or for the recompilation of that program  with  the
|  COMPILE command.  The syntax is:
|  
|  INFORM [ON <file-descriptor-1>] DMX <file-descriptor-2>
|  
|  where <file-descriptor-2> is the name of the  precompiled  (DMX)  file
   SPECIAL COMMANDS AND FEATURES                                 Page 7-6
   Revision 4


|  about whose run-time environment you wish to know.  If no extension is
|  specified, DMX is assumed.  If you specify the ON  <file-descriptor-1>
|  clause,  the information is written to the named file.  Otherwise, the
|  information is displayed at the terminal.
|  
|  The information returned  by  the  INFORM  DMX  command  includes  the
|  following:
|  
|        *  The full name of the specified DMX file  (device,  directory,
|           file  name, extension), including an error message if the DMX
|           file has been damaged and contains any structural errors
|  
|        *  The numbers of the major and minor  versions  of  1022  under
|           which the file was compiled
|  
|        *  A warning that the version of System  1022  under  which  the
|           file was compiled is incompatible with the present version if
|           that is so
|  
|        *  The full name of the source  file  (device,  directory,  file
|           name, extension)
|  
|        *  A descriptive list (including data  type,  subscript  bounds,
|           and  text length) of all user-defined variables referenced in
|           the program
|  
|        *  A descriptive list of all data sets,  collections,  and  join
|           relations referenced explicitly or implicitly in the program.
|  
|            -  The information given for a referenced data set  includes
|               the  internal  and external name, the alias (if any), the
|               data set number, and the manner in which the data set  is
|               referenced  by  the program (by internal name, file name,
|               alias, or number).  If the data set must be  the  current
|               data set at PERFORM or recompile time, this fact is noted
|               as well.
|  
|            -  The  information  given  for  a   referenced   collection
|               includes  the  collection  name  and  the  internal name,
|               external name, the alias  (if  any),  and  the  data  set
|               number of the collection's primary data set.
|  
|            -  The information given  for  a  referenced  join  relation
|               includes  the  internal name or alias of each joined data
|               set, the collection name of each joined  collection,  the
|               attributes  by  which  the  data  sets  are  joined,  the
|               specification UNI if the join is unilateral, and the name
|               or  identifying number of the join relation.  If the join
|               relation has been disabled, this fact is noted as well.
|  
|  
|  The following example illustrates the use of the  DMX  option  of  the
|  INFORM  command.  A university administration maintains two data sets,
   SPECIAL COMMANDS AND FEATURES                                 Page 7-7
   Revision 4


|  STDNTS.DMS and WRKRS.DMS.  STDNTS contains  the  grade  point  average
|  (GPA)  of  every  currently  enrolled student.  WRKRS contains the job
|  number  (JOBNUM)  of  each  student  employed   by   the   university.
|  Periodically,  the  administration  writes  information from these two
|  data sets to a spreadsheet using the PL1022 program STWKRS.DMX.   This
|  file was compiled after the following commands had been given, whether
|  interactively or through the execution of a command file:
|  
|           OPEN STDNTS WRKRS
|  
|           JOIN STDNTS WRKRS VIA STUDENT_ID
|  
|               .
|  
|               .
|  
|               .
|  
|           DBSET WRKRS
|  
|           FIND ALL
|  
|           SORT LAST_NAME FIRST_NAME
|  
|           DEFINE I,J
|  
|           LET SYSIFTYPE 1
|  
|           INIT 123 2 STWKRS.WKS
|  
|  STWKRS.DMX is as follows:
|  
|           !This program produces a worksheet tallying the
|  
|           !number of student employees and identifying
|  
|           !those whose GPA has dropped below 3.0
|  
|           PL START.
|  
|           REPEAT
|  
|           GETREC LEAVE.
|  
|           LET I I+1.
|  
|           IF 1.GPA LT 3.0 THEN
|  
|           PRINT ON 2 LN FN ID 1.GPA JOBNUM.
|  
|           LET J J+1.
   SPECIAL COMMANDS AND FEATURES                                 Page 7-8
   Revision 4


|           ENDIF.
|  
|           UNTIL 1 EQ 2.
|  
|           PRINT ON 2 I J FMT "Total Workers " I / "Total Warnings  "  I
|           END.
|  
|           PL END.
|  
|           RELEASE 2.
|  
|  If an INFORM DMX were issued for STWKRS under, say, version  117B(33),
|  the following information might be returned:
|  
|  File:   PS:<ADMIN>STWKRS.DMX  Compiled  under  System  1022  116B(107)
|  <SKEW>
|  Source:  PS:<ADMIN>STWKRS.DMC
|  
|  Predefined variables:
|  
|  INTEGER I
|  INTEGER J
|  
|  2 datasets or collections were referenced in the source code:
|  
|  Dataset WRKRS in WRKRS.DMS was d/s # 2
|  Must be the current dataset
|  Referenced by Dataset number, Internal name
|  
|  Dataset STDNTS in STDNTS.DMS was dataset # 1
|  Referenced by Dataset number, Internal name
|  
|  Join STDNTS to WRKRS via STUDENT_ID to STUDENT_ID as 10000
|  
|  
|  In the preceding example,  the  <SKEW>  message  appears  because  the
|  version  of  1022 under which STWKRS was compiled is incompatible with
|  the  one  under  which  the  INFORM  DMX  command  has   been   given.
|  Recompiling the file under the current version of 1022 eliminates this
|  problem.
|  
|  The two variables (I and J) that the user defined at compile time  and
|  that are referenced by the program are listed.  The fact that the user
|  set the value of the system variable SYSIFTYPE to 1  at  compile  time
|  (instead  of  leaving it set to 0, the default) is not revealed by the
|  INFORM DMX command because system variable settings are not checked at
|  perform time, though they are at compile time.
|  
|  WRKRS is identified as data set # 2, that is, as  the  second  of  the
|  data  sets  opened at compile time.  The INFORM DMX command notes that
|  WRKRS must be the current data set at  perform  time  because  it  was
|  explicitly  made  so  with  a DBSET command at compile time.  WRKRS is
|  referenced by the program twice,  both  times  implicitly.   WRKRS  is
   SPECIAL COMMANDS AND FEATURES                                 Page 7-9
   Revision 4


|  implicitly referenced by data set number at the PL START label.  It is
|  also implicitly referenced by internal name when the join relation  to
|  which it belongs is invoked in the PRINT command.
|  
|  STDNTS is identified as data set # 1, that is, as  the  first  of  the
|  data  sets  opened at compile time.  STDNTS is referenced twice by the
|  program, once explicitly and once implicitly.   STDNTS  is  explicitly
|  referenced  by data set number in the PRINT command.  It is implicitly
|  referenced by internal name when the join relation to which it belongs
|  is invoked.
|  
|  The join relation referenced by the program is described as well,  the
|  number  10000  being the identifying number assigned by System 1022 to
|  the join because no join name was specified by the user.



   7.1.10  Option:  FILES

   This lists all 1022 I/O channels (TOPS-10) or JFNs  (TOPS-20)  in  use
   and  the  file  specification associated with each.  These are not the
   print channels assigned by the INIT command, but are  associated  with
   the  operating  system.   If  the  channel  or  JFN  is  reserved by a
   background 1022 function, the message "(reserved)" appears.

|       * INFORM FILES        _
|       JFN 3   PS:<JONES>MYFILE.DMS
|       JFN 4   PS:<JONES>X180002107029.TMP
|       JFN 8   PS:<1022>1022.ERR
|       JFN 9   PS:<JONES>TEMP.OUT (PRINT channel 2)
|  
|  Where:
|  
|          PS:<JONES>MYFILE.DMS is a file belonging to the  TOPS-20  user
|          whose user-id is JONES.
|  
|          PS:<JONES>X180002107029.TMP is  the  scratch  file  that  1022
|          automatically  creates  for  the  session  for use in building
|          selection sets.
|  
|          PS:<1022>1022.ERR is the error message file that is opened  if
|          the user makes a command error during the session.
|  
|          PS:<JONES>TEMP.OUT is a file that has been  created  with  the
|          INIT command.
|  
|  When the INFORM FILES command is issued at a site with the Large  Data
|  Sets  Module,  the auxiliary files of all open multifile data sets are
|  also listed:
|  
|       * INFORM FILES        _
|       JFN 4   PS:<SMITH>BIGFIL.DMS
|       JFN 5   PS:<SMITH>AUX1.DMM
   SPECIAL COMMANDS AND FEATURES                                Page 7-10
   Revision 4


|       JFN 6   PS:<SMITH>AUX2.DMM
|       JFN 7   PS:<SMITH>X100018060023.TMP



   7.1.11  Option:  JOIN [ NAME ]

   This lists all the currently defined joins (see  "Joined  Data  Sets,"
   Examination  Chapter).   It  gives  the  join name.  It marks disabled
   joins.

        * INFORM JOIN        _
        JOIN FILMS TO DIRECT VIA DIRECTOR_ID TO DIRECTOR_ID. ! AS 10000
        JOIN EMPLOY TO SPOUSE VIA SURNAME TO SURNAME AS SNAM   .
        JOIN EMPLOY TO SCHOOL VIA EMPID TO SID UNI NOMSG. ! AS 10002
        JOIN EMPLOY TO CHILD VIA EMPID TO EMPID. ! AS 10003, disabled




   7.1.12  Option:  JOIN NUMBER

   This lists all the currently defined joins (see  "Joined  Data  Sets,"
   Examination  Chapter).   It  gives  the  data set numbers and the join
   name.  It marks disabled joins.

        * INFORM JOIN NUMBER        _
        JOIN 1 TO 2 VIA DIRECTOR_ID TO DIRECTOR_ID. ! AS 10000
        JOIN 3 TO 4 VIA SURNAME TO SURNAME AS SNAM   .
        JOIN 3 TO 5 VIA EMPID TO SID UNI NOMSG. ! AS 10002
        JOIN 3 TO 6 VIA EMPID TO EMPID. ! AS 10003, disabled




   7.1.13  Option:  NAMES

   This prints the full attribute names in the data set.

        * INFORM NAMES        _
        LASTNAME
        IDNO
        ENTRYDATE
        REMARKS
   2 Option:  SET This prints the full data set name of the current  data
   set.

        * INFORM SET        _
        TEST in <FRED>TEST.DMS ! is set #1
   SPECIAL COMMANDS AND FEATURES                                Page 7-11
   Revision 4


   7.1.14  Option:  STATUS

   This prints the status of the current data set.  The report includes:

        The name of the data file for unbundled data sets.
        The mode (if unbundled).
        The blocking factor and data mode
              of the data file (if unbundled).
        Version of 1022 created under.
|       The message "Default update mode is ENQ" when access to the data 
|             set has been restricted to ENQ, either with the CREATE
|             or MODIFY command.
|       The message "Dataset is RECLOCK" when access to the data set has
|             been further restricted to record-locking mode.
|       The specification "Dataset opened readonly" if that is so.
        UPDATE status (ON or blank).
        Compatibility information.
        Total number of records:
              Number active
              Number deleted
|       The message "data set damaged" if damage has occurred.
|       The number of records allocated to the data set.
        Date and time of last update
        User-id of last update
        The number of disk reads since startup (Rd0)
              for all open data sets.
        The number of requests of a disk block (Rd1) 
              for all open data sets.
        The number of disk writes since startup (Wd0) 
              for all open data sets.




   7.1.15  Option:  STRUCTURE

   This generates a list of all  attributes  in  the  data  set  and  the
|  structure  information that appears in a DMD file.  If the data set is
|  in pre-version 117A format, the comment
|  
|            !PRE-117
|  
|  follows the description of each keyed  or  keyed  inactive  attribute.
|  The  information  is written in DMD file format, so the file generated
|  may be used in turn to load a data set.
|  
|     * INFORM STRUCTURE      _
|     RECMODE ASCII DELIMIT ,
|     ATTRIBUTE LASTNAME ABBREV NAME TEXT KEYED COL 1 15 !PRE-117
|     ATTRIBUTE ID INTEGER OF IDENTIFICATION KEYED RANGE 0 500 COL 16 18
|         !PRE-117
|     ATTRIBUTE ENTRYDATE ABBREV DOE DATE OF ENTRY COL 19 26
|     ATTRIBUTE REMARKS TEXT COL 27 76
   SPECIAL COMMANDS AND FEATURES                                Page 7-12
   Revision 4


|  When the INFORM STRUCTURE command is issued at a site with the Large
|  Data
|  Sets Module, additional information is returned concerning the data
|  set's
|  auxiliary files, explicit block, page, or record limits, and the
|  location of
|  key tables as specified in the DMD file:
|  
|     * INFORM STRUCTURE      _
|     DMSFILE MYFILE.DMS RECORDS 100000 PAGES 10000
|     AUXFILE AUX1.DMM
|     AUXFILE AUX2.DMM RECORDS 100000
|     ATTRIBUTE LASTNAME ABBREV LN TEXT KEYED KEYFILE AUX1.DMM COL 1 15
|     ATTRIBUTE FIRSTNAME ABBREV FN TEXT COL 16 26
|     ATTRIBUTE PHONENUMBER ABBREV NUM TYPE INTEGER COL 27 33
|  
|  
|  
|  7.1.16  Option:  STRUCTURE DATA
|  
|  The INFORM STRUCTURE DATA command  returns  the  same  information  in
|  tabular  form  as  INFORM  STRUCTURE TABLE (see below) except that the
|  labels and legend are omitted.  The syntax is:
|  
|       INFORM [ ON <file-descriptor> ] STRUCTURE DATA
|  
|  For example, an INFORM STRUCTURE DATA command on the  BLOOD  data  set
|  returns the following:
|  
|    FN    FIRST_NAME                T    7     1    10
|  * LN    LAST_NAME                 T    7    11    15      
|  *       AGE                       I    B    26     2      1:99
|  * BG    BLOOD_GROUP               T    7    28     2      
|  * RH    RH_FACTOR                 T    7    30     1      
|  *       SEX                       T    7    31     1      
|          COUNT                     I    B    32     6 A T  
|    TD    TEST_DATE                 D ER B    38     8      
|  
|  The chief advantage of the INFORM STRUCTURE DATA command  is  that  it
|  allows  you  to  use  the ON <file-descriptor> clause to create a data
|  file, which can be loaded into a data dictionary  with  a  description
|  file like the following:
|  
|  ATTRIBUTE KEY_STATUS TEXT COL 1 1
|  ATTRIBUTE ABBREV TEXT COL 3 7
|  ATTRIBUTE ATTR_NAME TEXT COL 9 33
|  ATTRIBUTE DATA_TYPE TEXT COL 35 36
|  ATTRIBUTE SPEC_TYPE TEXT COL 37 37
|  ATTRIBUTE RESET_SPEC TEXT COL 38 38
|  ATTRIBUTE DATA_MODE TEXT COL 40 40
|  ATTRIBUTE COL_START INTEGER COL 41 46
|  ATTRIBUTE LEN_SPEC INTEGER COL 47 52
|  ATTRIBUTE ADD_SPEC TEXT COL 54 54
   SPECIAL COMMANDS AND FEATURES                                Page 7-13
   Revision 4


|  ATTRIBUTE ERROR_SPEC TEXT COL 56 57
|  ATTRIBUTE RANGE_SPEC TEXT COL 59 70
|  



   7.1.17  Option:  STRUCTURE LENGTH

   This generates the same list that INFORM STRUCTURE generates, with two
   exceptions:  the COL field is shown as a LENGTH field and FILLER lines
   appear if they exist.

      * INFORM STRUCTURE LENGTH      _
      ATTRIBUTE LASTNAME ABBREV NAME TEXT KEYED LENGTH 14 !PRE-117
      FILLER 1
      ATTRIBUTE ID INTEGER OF IDENTIFICATION KEYED RANGE 0 500 LENGTH 2
      !PRE-117
      FILLER 1
      ATTRIBUTE ENTRYDATE ABBREV DOE DATE OF ENTRY LENGTH 8
      FILLER 1
      ATTRIBUTE REMARKS TEXT LENGTH 50
|  
|  
|  
|  7.1.18  Option:  STRUCTURE TABLE
|  
|  The INFORM STRUCTURE TABLE command returns a variety of information in
|  tabular form about the attributes of a data set.  The syntax is:
|  
|       INFORM [ ON <file-descriptor> ] STRUCTURE TABLE
|  
|  The informational table that this command returns  displays  the  name
|  and  abbreviation  of  each  attribute  in the data set as well as its
|  keyed status, its data type, the data mode in  which  its  values  are
|  represented, its length and column fields, and its ERROR specification
|  (if any).  In addition, if an attribute is one of  the  special  types
|  (Date  of  Entry,  Date of Change, or Integer of Identification), this
|  fact is displayed.  If such an attribute has been specified as  RESET,
|  this information is also given.  Finally, if a computational attribute
|  has been specified as ADDITIVE, this information appears in the table.
|  
|  For example, the following is the description file BLOOD.DMD:
|  
|  
|  RECMODE ASCII DELIMIT ,
|  ATTRIBUTE FIRST_NAME ABBREV FN TEXT COL 1 10
|  ATTRIBUTE LAST_NAME ABBREV LN TEXT KEYED COL 11 25
|  ATTRIBUTE AGE INTEGER KEYED RANGE 1 99 COL 26 27
|  ATTRIBUTE BLOOD_GROUP ABBREV BG TEXT KEYED COL 28 29
|  ATTRIBUTE RH_FACTOR ABBREV RH TEXT KEYED COL 30 30
|  ATTRIBUTE SEX TEXT KEYED COL 31 31
|  ATTRIBUTE COUNT INTEGER ADDITIVE ERROR TYPE COL 32 37
|  ATTRIBUTE TEST_DATE ABBREV TD DATE OF ENTRY RESET COL 38 45
   SPECIAL COMMANDS AND FEATURES                                Page 7-14
   Revision 4


|  
|  
|  The command INFORM STRUCTURE TABLE on  BLOOD  produces  the  following
|  table:
|  
|  
|  K Abbr  Name                      T SR M   Col   Len A E  Range
|  =========================================================================
|    FN    FIRST_NAME                T    7     1    10      
|  * LN    LAST_NAME                 T    7    11    15      
|  *       AGE                       I    B    26     2      1:99
|  * BG    BLOOD_GROUP               T    7    28     2      
|  * RH    RH_FACTOR                 T    7    30     1      
|  *       SEX                       T    7    31     1      
|          COUNT                     I    B    32     6 A T  
|    TD    TEST_DATE                 D ER B    38     8      
|  
|  
|  
|   K is keying: "*" = keyed, "=" = keyed-inactive.
|                      (for keys before version 117, "+" = active,
|                        "-" = inactive)
|   T is data type: T = text, I = integer, R = real, D = date, 
|                       I2 = dbl integer.
|   S is special attr: E = date of entry, C = date of change, 
|                       I = integer of id.
|   R is RESET: R = yes.
|   M is data mode: B = binary, 7 = ASCII, 6 = SIXBIT.
|   A is ADDITIVE: A = yes.
|   E is ERROR atom: T = TYPE, R = RECOVER, TR = both.
|  
|  For additional legend information, type HELP INFORM STRUCTURE TABLE KEY.
|  
|  
|  The 1022 HELP message for INFORM STRUCTURE TABLE KEY is as follows:
|  
|  K  Refers to key status: * shows that the attribute is keyed in version 
|      117 format; = shows that the attribute is keyed in 117 format and is 
|      keyed inactive; + shows that the attribute is keyed in pre-117 
|      format; - shows that the attribute is keyed in pre-117 format and is 
|      keyed inactive.
|  T  Refers to the data type. Type T is Text, I is integer, R is Real, D is
|      Date, and I2 is Double Integer.
|  S  Refers to attributes that are treated specially. E is Date of Entry, C 
|      is Date of Change, and I is Integer of Identification.
|  R  Refers to the RESET specification used in LOAD  for Date of Entry, Date 
|      of Change, and Integer of Identification. R shows that RESET is 
|      specified.
|  M  Refers to the mode in which the attribute's values are represented. B
|      shows that the representation is Binary, 7 that it is 7-bit ASCII,
|      and 6 that it is SIXBIT.
|  A  Refers to the ADDITIVE specification used in TRANSACT for computational
|      attributes. A shows that the attribute is ADDITIVE.
   SPECIAL COMMANDS AND FEATURES                                Page 7-15
   Revision 4


|  E  Refers to the ERROR specification for an attribute. T shows that ERROR 
|      TYPE has been specified for the attribute, R shows that ERROR RECOVER 
|      has been specified, and TR shows that ERROR TYPE and ERROR RECOVER 
|      have both been specified.
|  



   7.1.19  Option:  VERSION


   This lists the following version-dependent information:


        BANNER      Version banner (e.g., "System 1022B (114B(37))".
        SEGMENT     The filename of the  current high segment.
        PATCHES     A list of all patches installed.
        DATE        System Generation Date.
|  
|  
|  
|  7.2  KEY $CHECKSUM, KEY $SCAN, AND KEY $VERIFY
|  
|  The KEY $SCAN command returns statistical information  concerning  the
|  average space used per key table block for an attribute and the extent
|  to which key tables have become fragmented.  The KEY $CHECKSUM and KEY
|  $VERIFY  commands  allow the user to determine whether key tables have
|  been damaged.  KEY $CHECKSUM simply  shows  whether  or  not  the  key
|  tables  for  specified attributes are damaged.  KEY $VERIFY also shows
|  this information and, in addition, explains what  the  damage  is,  if
|  any.
|  
|  Suppose, for example, that your data set contains the keyed  attribute
|  LAST_NAME.   If the key table for that attribute has been damaged, the
|  command
|  
|       KEY $CHECKSUM LAST_NAME
|  
|  will produce the message
|  
|       LAST_NAME
|       ? checksums differ
|  
|  while the command
|  
|       KEY $VERIFY LAST_NAME
|  
|  will produce a message such as
|  
|       LAST_NAME
|       SMITH
|       7 from dataset
   SPECIAL COMMANDS AND FEATURES                                Page 7-16
   Revision 4


|       SMITHE
|       7 from key table
|  
|  This  message  shows  the  disagreement  between  the  value  for  the
|  attribute  as it appears in the record and the value for the attribute
|  as it appears in the key table.  The SYSID for the damaged record  and
|  the associated key table value is also given.
|  
|  KEY $CHECKSUM operates more quickly than KEY $VERIFY and is  therefore
|  preferred as a means of checking the key tables for damage.  If damage
|  is discovered, then KEY $VERIFY may be used to pinpoint it.
|  
|  When damage such as that in the  above  example  is  encountered,  the
|  CHANGE command may be used to repair it by making the attribute values
|  in the data set and the key tables agree.   (Prior  to  version  117A,
|  when the CHANGE command was issued on an attribute whose values in the
|  data set and in the key table disagreed, an error message  was  issued
|  and the update was terminated.)
|  
|  For example, suppose that you have issued the KEY  $CHECKSUM  and  KEY
|  $VERIFY  commands  as  above.  To establish a single correct value for
|  the attribute LAST_NAME in the data set and in the  key  table,  issue
|  the following commands:
|  
|       FIND SYSID 7
|  
|       CHANGE LAST_NAME SMITHE
|  
|  This will produce error messages informing you of the original damage,
|  but  will  perform the update.  The value of the attribute in the data
|  set changes so that it agrees with the value in the key table.  If the
|  desired  value  is  SMITH  and  not  SMITHE, then issue the additional
|  command
|  
|       CHANGE LAST_NAME SMITH
|  
|  which will change the value of the attribute in both the data set  and
|  the key table to SMITH.
|  
|  To make sure that  the  update  has  been  accomplished,  reissue  the
|  command
|  
|       KEY $CHECKSUM LAST_NAME
|  
|  which now returns the message
|  
|       LAST_NAME verified
   SPECIAL COMMANDS AND FEATURES                                Page 7-17
   Revision 4


   7.3  CONTROL-E


   TOPS-20 users running 1022 can get  immediate  information  about  the
   status  of  System  1022 by typing control-E, which functions like the
   EXEC's control-T.  Control-E  does  not  interrupt  the  operation  of
   System 1022.

   On TOPS-10 systems, 1022 does not respond to control-E.

   Control-E lists the following information:

        LABEL     MEANING
        -----     -------

        Rd        The number of disk reads since startup.

        Wt        The number of disk writes since startup.

        Rd1       The number of requests for a disk block.

        D/S       The  current  data  set  number.   If  SELECT   command
                  conditions  apply  in the data set, then an asterisk is
                  printed next to the number.

        Block     The block number last accessed in the DMS file  of  the
                  current data set.

        SYSID     The SYSID (record number) if in GETREC mode.

        RCNO      The value of SYSRECNO for the  current  record,  if  in
                  GETREC mode.  This is the sequence number of the record
                  in its selection group.

        Low       The low segment size in K.

   TOPS-20 does not count physical reads or writes for a user's job.  The
   "Rd" and "Wt" figures are the number of read or write requests made by
   System 1022 file I/O routines, and not the physical reads or writes as
   obtained on TOPS-10 systems.  A single request to read or write a disk
   block may cause the Monitor to execute additional reads while  looking
   through  the file structure.  Thus, Rd/Wt will be less than the number
   of physical reads/writes executed by the  job.   The  effect  of  disk
   buffering  is observed by comparing the "Rd" and "Rd1" values.  RD1 is
   the number of requests for a disk block.  Some requests are  satisfied
   by a block already read and still in core buffers.  So, RD1 is greater
   than RD; the difference is buffering efficiency.
   SPECIAL COMMANDS AND FEATURES                                Page 7-18
   Revision 4


   7.4  USING TECO FROM WITHIN THE SYSTEM

   The TECO command calls in a TECO text editor or  on  text  attributes.
   System  1022  uses TECO version 23(A).  The user can write and execute
   automatic routines that perform editing operations on text attributes.
   The command takes 4 forms.

   1.  TECO

   Just typing TECO calls in the text editor.  To  avoid  confusion  with
   the  1022  command  prompt  (*), the TECO prompting character has been
   changed to colon (:).

   The user may then edit disk files by typing EB,  EW,  and  other  TECO
   commands.   After  exiting  from  TECO, the user is returned to System
   1022 command mode.  Upon return, the data set environment is the  same
   as  it  was when the TECO command was typed.  In particular, data sets
   need not be reopened and selection groups need not be recreated.  This
   preservation of context is particularly useful when invoking TECO many
   times to perfect a command file or report program.

   A new command, EQ (Edit Quit), exists in the System  1022  version  of
   TECO.   This command exits immediately from TECO and returns to System
   1022, without changing anything, or writing the text buffer.

   If the user gets into an infinite loop within TECO, abort the loop
   with two Control-C's (^C^C) and continue by using the Monitor  REENTER
   command.


   2.  TECO [FILE] <file-descriptor>

   This form of the command edits a disk file.   It  is  similar  to  the
   monitor  TECO  command.   It  invokes  the  editor  and  does EB and Y
   commands if the file exists.  If the file does not exist, 1022 types

        [new file]

   and performs an EW command to create the file.  The reserved word FILE
   may be typed for clarity.

   Example:  TECO TEST.DMC
             TECO FILE TEST.DMC


   3.  TECO ATTRIBUTE <attribute>

   This form of  the  command  edits  a  System  1022  record  attribute.
   Exactly  one record must be currently selected, or the user must be in
   local mode after a GETREC command.  The  editor  reads  the  specified
   TEXT  attribute,  which  may  be ASCII or SIXBIT, from the record, and
   places it into the TECO text buffer.  Then, the user  edits  the  text
   attribute.  The word ATTRIBUTE may be abbreviated to ATT.
   SPECIAL COMMANDS AND FEATURES                                Page 7-19
   Revision 4


   The EC command in System 1022 TECO updates the data set with an edited
   attribute  value.   EC exits TECO and performs a CHANGE command on the
   attribute, replacing it with the edited value in the TECO text buffer.
   If the user does not wish to change the value of the attribute, the EQ
   command exits from TECO without any action.  In the following example,
   <ESC> stands for the ESCAPE character in TECO.


        * FIND SYSID 200        _
        FOUND        _____
        * TYPE DIVISION        _
        BUREAU OF FORESTRIES AND PARKS        ______ __ __________ ___ _____
        * TECO ATT DIVISION        _
        :FSFORESTRIES<ESC>FORESTRY<ESC>0LT<ESC><ESC>        _
        BUREAU OF FORESTRY AND PARKS        ______ __ ________ ___ _____
        :EC<ESC><ESC>        _
        *  TYPE DIVISION        _
        BUREAU OF FORESTRY AND PARKS        ______ __ ________ ___ _____


   4.  TECO  USING

   The USING clause can be appended to any of the three forms of the TECO
   command described above.  Its form is:

        USING <command-string> END

   It specifies a set of TECO commands to be  executed  automatically  on
   entering TECO.  The commands are terminated with two <ESC>s.

   Example:

        TECO ATT ABSTRACT USING FSJAHN<ESC>JOHN<ESC>EC<ESC><ESC> END

        The attribute ABSTRACT is edited.  The characters  JAHN  are
        replaced  by  JOHN  and  the attribute is changed to the new
        value.


   1022 does not recognize #Z  when  reading  the  commands  in  a  USING
   clause.   To  stop  typing  a  USING  clause  and start over, type two
   Control-C's, then the monitor command REENTER.   You  will  return  to
   command prompt level (*).

   To place literal <RET>s into the  TECO  command  of  a  USING  clause,
   precede  them  with  ^  (caret).   Otherwise they are interpreted as a
   space.  The entire TECO command string of the USING clause is  limited
   to 130 characters or fewer, not counting the words USING or END.

   SPECIAL COMMANDS AND FEATURES                                Page 7-20
   Revision 4


   7.5  SOS AND EDIT COMMANDS

   The SOS and EDIT commands are identical in effect when  issued  within
   System  1022:   either  will  access  an  internal  text  editor while
   preserving the 1022 environment.   Which  particular  text  editor  is
   accessed  depends  on  whether  the  system  is  running on TOPS-10 or
   TOPS-20.



   7.5.1  SOS And EDIT On TOPS-10

   On TOPS-10, the SOS and EDIT commands access 1022's internal SOS  text
   editor while preserving the 1022 environment.  The command syntax is:

             { SOS  }
|            {      } [ [FILE] <file-descriptor> ] 
|            { EDIT }
|                [ [USING] <command string> END]

   When the user gives the SOS or EDIT command in its simplest form,  the
   SOS  text  editor  prompts  for  a  file specification.  The user then
   enters the name of the file to be edited.  In the fuller form  of  the
   command,  the  user  supplies  the  name  of  a  disk file, optionally
   preceding this by the word "FILE" for clarity.

   In specifying a file  descriptor,  the  user  may  employ  up  to  six
   alphanumeric  characters  for the file name and up to three characters
   for the extension.

   If the specified file does not exist, the SOS  editor  creates  a  new
   file.  The user then enters or edits text using standard SOS commands.
|  
|  The USING clause allows the user to enter a series of SOS commands  to
|  be executed automatically on entering SOS.

   Leaving SOS returns the user to  the  preserved  1022  environment  at
   command level.



   7.5.2  SOS And EDIT On TOPS-20

   On TOPS-20, the SOS and EDIT commands  call  the  system  text  editor
   defined  by  either  "EDITOR:"  or  "SYS:EDIT.EXE" in that order while
   preserving the 1022 environment.  System 1022  tells  the  user  which
   editing program it is executing.  The command syntax is:

             { SOS  }
|            {      } [ [FILE] <file-descriptor> ] 
|            { EDIT }
|               [ [USING] <command string> END ]
   SPECIAL COMMANDS AND FEATURES                                Page 7-21
   Revision 4


|  The USING clause allows the user to enter a series of commands  to  be
|  executed automatically by the editor as soon as it is accessed.

   Leaving the text editor accessed by the SOS or  EDIT  command  returns
   the user to the preserved 1022 environment at command level.




   7.6  MODIFY COMMAND

   The MODIFY command changes data set characteristics without  reloading
   the  data  set.   It  changes  an  attribute  name or abbreviation, an
   attribute's additive or nonadditive  status,  the  internal  data  set
|  name,  or its its status as an ENQ or RECLOCK data set.  The format of
   the command is:

                                       {NAME new-name       }                                        ___
          {[$ATTRIBUTE] att-descriptor {ABBREVIATION new-abb}      }            ____                        ___
   MODIFY {                            {[NON]ADDITIVE       }   ___                                   ___ ___
          { $DSNAME internal-name                                  }            ____
          { $ACCESS {   ENQ   }                                    }            ____
                    {  NOENQ  }
|                   { RECLOCK }
|                   {NORECLOCK}

   Where:

   $ATTRIBUTE Specifies the attribute-descriptor (name  or  abbreviation)
              of  the  attribute  to be changed.  The NAME clause changes
              the name and the ABBREV clause  changes  the  abbreviation.
              The  [NON]ADDITIVE  clause  allows  the  user to change the
              additive or nonadditive status of real, integer, or  double
              integer  attributes.  (An attempt to change the status of a
              text, date,  or  integer  of  identification  attribute  to
              ADDITIVE results in a System 1022 error message.)

   $DSNAME    Specifies the new internal name  for  the  data  set.   The
              internal name need not be the same as the DMS file name.

|  $ACCESS    Specifies the ENQ or NOENQ,  RECLOCK  or  NORECLOCK  access
|             status  of  the data set.  To change a data set from ENQ to
|             NOENQ status, the data set must be NORECLOCK.  To change  a
|             data  set  to  RECLOCK status, the data set must already be
|             ENQ.  See the "Multiple Access of a Data  Set"  section  in
|             Chapter 5.
|  
|  Changes in attribute name or  abbreviation  and  data  set  name  take
|  effect  immediately.   Changes  in ENQ/NOENQ access status take effect
|  the next time the data set is opened.   Changes  in  RECLOCK/NORECLOCK
|  access status take place immediately.

   SPECIAL COMMANDS AND FEATURES                                Page 7-22
   Revision 4


   Examples:

        * OPEN NAMES IN NAMES.DMS
        * MODIFY SCHOOL NAME COLLEGE
        * MODIFY $ATTR LAST_NAME NAME SURNAME
        * MODIFY $ATTR SURNAME ABBREV SN
        * MODIFY $DSNAME PEOPLE
        * MODIFY $ACCESS ENQ

        These commands  change  the  name  of  the  SCHOOL  attribute  to
        COLLEGE,  change  the  name  and  abbreviation  of  the LAST_NAME
        attribute, change the data set name to PEOPLE in  NAMES.DMS,  and
        change access to ENQ.



   7.7  SET COMMAND

   The SET command controls some options in System  1022,  including  the
   number  of I/O buffers used in update activities, error responses, and
   command level prompt messages.  The form is:

        SET <option-keyword> <argument> ... <argument>

   Where the option keywords are:


        BUFFER    Set up more I/O buffers .

        ERRCHAR   Specifies the character preceding error messages.

        ERROR     Specifies the response to errors in batch streams.

        FILERR    Specifies the response to errors in command files.

        FMSG &    Specify responses to FIND and SEARCH commands.
        FERR
   SPECIAL COMMANDS AND FEATURES                                Page 7-23
   Revision 4


        PROMPT    Specifies the command level prompt messages.
|  
|       SCRATCH   Specifies the number of buffers to be allocated to the
|                 scratch file.

        TAPE      Specifies output conventions to files and terminals.



   7.7.1  BUFFER Option

   SET BUFFER specifies the number of internal I/O buffers 1022 maintains
   for  the  current  data  set.   By  allocating  more I/O buffers, 1022
   efficiency is increased for heavy updating.  8 buffers fit in slightly
   more  than  1K  of  core, and 1022 is initially set up with 8 buffers.
   The command is:

        SET BUFFER <n>

   where n is the number of I/O buffers to use.

   Example:   SET BUFFER 16

              System 1022 uses 16 I/O buffers (approximately 2K core).

   The SET BUFFER command is used  when  many  update  commands  will  be
   issued.  An example of this is a batch update from a file of APPEND or
   CHANGE commands.  The optimum number of buffers is:

        4*(n+1)

   where n is the number  of  keyed  attributes  to  be  changed  in  the
   following updates.  For a large number of attributes, this optimum may
   be unreasonable, but more buffers  increase  efficiency  even  if  not
   optimum.  Thus, for a data set with five keyed attributes, the command
   "SET BUFFER 24" is given before a  series  of  APPEND  commands.   The
   APPEND  operation  "changes"  all five attributes.  The buffers can be
   deallocated after the update has been made;  the command  "SET  BUFFER
   8" resets 1022 to its default of eight I/O buffers.

   These buffers are internal to System 1022 and  do  not  correspond  to
   buffers in the I/O scheme of the operating system.

   I/O buffers contain portions of data set key tables  and  data  record
   blocks.    Increasing   the  number  of  buffers  also  increases  the
   efficiency of reading and writing data records.

   Each open data set references its own  I/O  buffers.   Increasing  the
   number  of  buffers does not increase every data set's buffer size.  A
   DBSET to each open data set, followed by a SET  BUFFER  command,  will
   specify I/O buffers for each data set.
   SPECIAL COMMANDS AND FEATURES                                Page 7-24
   Revision 4


   7.7.2  ERRCHAR Option

   The SET ERRCHAR command supplies the error character  which  is  typed
   before  all  error messages.  Normally, this character is the question
   mark, or the percent sign when  running  under  BATCH.   (BATCH  is  a
   monitor command file feature.) The command is:

        SET ERRCHAR <character>

   where the character is any printing  ASCII  character.   For  example,
   "SET  ERRCHAR  $" makes a dollar sign print out before error messages.
   Single and double quotation marks must be  quoted  by  preceding  them
   with a caret.




   7.7.3  ERROR Option

   When System 1022 encounters an error during interactive operation,  it
   normally  types  an  error  message  and  continues  to accept another
   command.  An error causes 1022  to  abort  when  running  in  a  batch
   stream.   The SET ERROR command chooses how error recovery is handled.
   The choices are:

        SET ERROR ABORT
        SET ERROR CONTINUE

   The SET ERROR ABORT command causes 1022 to  return  to  monitor  level
   following  an error.  Any files that are open are correctly closed and
   saved when 1022 aborts.

   The SET ERROR CONTINUE  command  causes  a  return  to  command  level
   instead  of exiting to monitor level.  The SET ERROR ABORT command can
   be given later to restore the initial error handling.



   7.7.4  FILERR Option

   The SET  FILERR  command  controls  error  handling  when  1022  reads
   commands from a file.  Normally, file reading terminates when an error
   is encountered, and control returns to the user's terminal.   The  two
   options are:

        SET FILERR ABORT
        SET FILERR CONTINUE

   The SET FILERR CONTINUE command causes 1022 to recover from a  command
   file  error  and  continue  reading  commands  from the file.  The SET
   FILERR ABORT command resets 1022 back to its default operating mode.

   The recovery procedure scans the file for the next terminating period.
   SPECIAL COMMANDS AND FEATURES                                Page 7-25
   Revision 4


   The next command is read from that position in the file.



   7.7.5  FMSG And FERR Options

   The SET FMSG and SET FERR commands control the  messages  typed  after
   FIND,  DFIND,  SEARCH,  and MAP commands.  Normally, 1022 types one of
   the following messages after executing these commands:

        NOT FOUND.
        FOUND.
        n RECS FOUND.

   The SET FMSG command suppresses or enables any of  these  messages  in
   any  combination.   The  SET  FERR  command suppresses or includes the
   error character preceding the message.  The commands are:


        SET FMSG <option> [<option>] ...

        SET FERR <option> [<option>] ...


   The options for both commands are:

               ON       Sets the state ON for all messages.

               OFF      Sets the state OFF for all messages.

               0        Sets the state ON for the NOT FOUND message.

               1        Sets the state ON for the FOUND message.

               M        Sets the state ON for the n RECS FOUND message.


   The ON and OFF keywords are used alone.  One or more of 0,  1,  and  M
   appear  to select those messages which print, or which are marked with
   the ERRCHAR.  Options not appearing in the command are turned OFF.

   We summarize the effects of the FMSG command for any  message  in  the
   following outline:

     1. FMSG is OFF for a particular message,

        Then, no message types when a FIND or SEARCH results in
        the matching number of records.

     2. FMSG is ON for a particular message,

        Then, the message types when the number of records matches.
   SPECIAL COMMANDS AND FEATURES                                Page 7-26
   Revision 4


        A.  FERR is ON,

            The ERRCHAR (usually "?") precedes the message.

        B.  FERR is OFF,

            No character precedes the message.

   We suggest two situations where SET FMSG and SET FERR are helpful.  In
   batch  jobs, some results of SEARCH and FIND may be considered errors.
   Use SET FERR 0 so that the message ?NOT FOUND aborts the job  when  no
   records are found.

   As a second case, FIND messages may be bothersome  when  executing  an
   automatic procedure in a PL1022 program or command file.  SET FMSG OFF
   can precede the commands of the file, and SET FMSG ON can restore  the
   FIND messages after the procedure has finished.

|  
|  The system variable SYSFMSG can  be  used  to  save  and  restore  the
|  settings of the bit flags that are manipulated by the SET FMSG and SET
|  FERR commands.  This is chiefly useful when you want to run a  command
|  file  that  contains a SET FMSG or SET FERR command, or both, and want
|  to leave the 1022 environment in its original state  with  respect  to
|  these settings after execution has completed.
|  
|  The use of SYSFMSG is  shown  in  the  following  DMC.   The  variable
|  SAVESET  saves the current settings of the bit flags determined by the
|  SET FMSG and SET  FERR  commands  (or  the  system  defaults).   These
|  settings are then restored after the rest of the file has executed.
|  
|  DEFINE INTEGER SAVEFSET.
|  LET SAVEFSET SYSFMSG.    !Save the current settings in SAVEFSET.
|  SET FMSG OFF.            !Temporarily turn off FMSG.
|  SET FERR OFF.            !Temporarily turn off FERR.
|       .
|       .
|       . 
|  LET SYSFMSG SAVEFSET.    !Restore the original settings.
|  



   7.7.6  PROMPT Option

   The command prompt (*) of System  1022  may  be  expanded  to  include
   information on resource usage of the commands.  The options are:

        SET PROMPT [TIME] [CLOCK] [CPU] [DISK] [TEXT <message>]]

   The selected information prints just before the command  level  prompt
   (usually  an  asterisk) which begins new commands.  You may select any
   combination of options in any  order.   However,  the  options  always
   SPECIAL COMMANDS AND FEATURES                                Page 7-27
   Revision 4


   print in the order:  TIME, CLOCK, CPU, DISK, and TEXT.  Each option is
   explained below.

        1.  TIME - Types the current time of day.

        2.  CLOCK - Types the number of minutes and seconds  elapsed
            since  the last command.  The count begins when the last
            command started execution.

        3.  CPU - Types the number of CPU seconds used by  the  last
            command executed.

        4.  DISK  - Types  the  number  of  disk  reads  and  writes
            executed  by  the  last  command.   (Not available under
            TOPS-20.)

        5.  TEXT  <message> - Types the specified message (up to  24
            characters),  rather  than the asterisk, to prompt for a
            new command.  This message is also typed before the (PL)
            and  (R)  in  interactive  use  of PL1022 and the Report
            Generator, instead of the "* ".  If the message contains
            blanks, it must be enclosed in double quotes.

   To see  the  effect  of  this  command,  consider  the  following
   example:

        * SET PROMPT CPU CLOCK TIME DISK TEXT " *** NEW *** "        _
        [15:12.34 :23 .11 2 0] *** NEW ***         ___________________________________

   which indicates the time of day is 3:12 PM, that  23  seconds  elapsed
   during  the  last  command,  that .11 second of CPU time was used, and
   that 2 disk reads and 0 disk writes have occurred in that time.

   There is no way to selectively change the SET PROMPT options.  Another
   SET PROMPT  command  with  no  arguments  restores 1022 to its default
   conditions.  Another command  with  different  arguments  changes  the
   missing arguments to the 1022 default values.
|  
|  
|  
|  7.7.7  SCRATCH Option
|  
|  System 1022 includes a scratch area for use in forming selection  sets
|  and  updating  key tables.  By default, a 256-word buffer is allocated
|  for every 8000 records per data set.  A minimum of two such buffers is
|  automatically  allocated.  If this amount of low-segment memory is not
|  sufficient, overflow is handled by a scratch file.   The  SET  SCRATCH
|  command and the system variables SYSDCORESS, SYSCORESS, and SYSSCRFILE
|  allow you to regulate the amount of low-segment  memory  allocated  to
|  the  scratch  area,  specify whether the scratch area is to be used in
|  forming selection sets, and choose whether  to  allow  overflow  to  a
|  scratch file.
   SPECIAL COMMANDS AND FEATURES                                Page 7-28
   Revision 4


|  The SET SCRATCH command allows you to specify the number of buffers to
|  be  used  by  the  scratch  file  that  1022 routinely creates for the
|  session for building selection sets.  The syntax is:
|  
|       SET SCRATCH n
|  
|  where n is the number of buffers to be allocated to the  current  data
|  set.
|  
|  The SET SCRATCH command is chiefly useful for limiting the  amount  of
|  low-segment  memory  allocated  to the scratch area, and for expanding
|  that amount if a scratch file is not  going  to  be  used  during  the
|  session.



   7.7.8  TAPE Option

   The SET TAPE command gets its name from the carriage control  tape  in
   many  line  printers.   It  controls  how a request for top-of-form is
   handled in a report or in a PRINT format.   Although  the  name  comes
   from  the line printer, use it for any device or print file.  The form
   of the command is:

                          { FF }
        SET TAPE [ON <n>] {    }
                          {NONE}                           __

   where n is the number of the channel to be affected.  The options are:

        Use SET TAPE FF if the output is generated for a device with
        hardware  formfeeds,  such  as  a  DIABLO or LA120 terminal.
        Formfeed is output as a special  character,  but  all  other
        paper motion is accomplished by <CR> and <LF>.

        SET TAPE NONE causes all paper motion to be done  with  <CR>
        and <LF>.

   If the SET TAPE command is not  used,  output  is  governed  by  these
   rules:

        1. If the output is directed to the terminal, the default is
           SET TAPE NONE.

        2. If the output is directed to a disk file, the default  is
           SET TAPE FF.

   A formfeed character between each page of output aligns the  pages  if
   they  get  out  of  synchronization  from  transmission  errors.   The
   printing device must handle formfeeds.  This formfeed is  supplied  by
   default, when formfeeds are legal in the output.

   SPECIAL COMMANDS AND FEATURES                                Page 7-29
   Revision 4


   7.8  INTERPROGRAM COMMUNICATION

   The RUN, PUSH, and TMPFILE commands permit interprogram communication,
   as described below.



   7.8.1  RUN Command

   The RUN command exits from 1022 and at the same time starts up another
   program.  The command is:

        RUN <file-descriptor> [<core-size>] [ S <start address offset>]

   where the <file-descriptor> names the program to be run.  If no device
   is  specified  in  the file-descriptor, 1022 first looks in the user's
   own disk area, and if this fails, then looks in device SYS:.

   The <core-size> option has no effect in TOPS-20.  In TOPS-10  systems,
   you can specify core allocation with an integer value.

   The S <start  address  offset>  option  lets  you  offset  the  normal
   starting  address of the program by 1.  The legal values for the start
   address offset are 0 and 1.  The default is 0.

   EXAMPLES:

        RUN TEST
        RUN DSKB:CPLOT
        RUN LOADER 15 S 1

   In the last example, the LOADER program is run using a  core  size  of
   15K;  the normal starting address is offset by +1.



   7.8.2  TMPFILE Command

   The TMPFILE command provides a link for TOPS-10 users with TMPCORE for
   interprogram communications.  The command is:

        TMPFILE <name> <d> <string> <d>        ___

   Where:

   <name>    Is a 3-character TMPCORE name.

   <d>       Is any character except space, <cr>, <lf>, or  <tab>  to  be
             used as a delimiter.

   <string>  Is any ASCII string to be placed into TMPCORE.

   If the string does not fit into TMPCORE,  the  file  ###<name>.TMP  is
   SPECIAL COMMANDS AND FEATURES                                Page 7-30
   Revision 4


   created on disk.  ### is the user's job number.



   7.8.3  PUSH Command

   The PUSH command allows the TOPS-20  user  to  suspend  operations  in
   System  1022  and  go  to TOPS-20 monitor level (EXEC), preserving the
   1022 environment.  The syntax of the command is:

        PUSH [USING <string> END]

   When the user types "PUSH", the system prints a message that tells the
   user  it  has  created  a  new command level.  The user can then enter
   commands at EXEC level, and return  to  1022  using  the  TOPS-20  POP
   command.  For example:


        * PUSH        _

         TOPS-20 command processor 4(560)         _______ _______ _________ ______
        @DELETE *.BAK        _
         A.BAK [OK]         _____ ____
         B.BAK [OK]         _____ ____
        @POP        _

        *   (User returns to 1022)        _


   If the PUSH command contains  the  USING  clause,  the  "<string>"  is
   passed  to  the  EXEC  as  if  it  were  a string of commands.  In the
   following example, the EXEC deletes all files which have the extension
   "BAK" and returns to 1022:


        * PUSH USING DELETE *.BAK        _
         # POP END         _

         TOPS-20 Command processor 4(560)         _______ _______ _________ ______
        @ A.BAK [OK]        _ _____ ____
         B.BAK [OK]         _____ ____
        @        _
        *   (User returns to 1022)        _

   After the EXEC processes the commands passed in the USING  string,  it
   accepts  any  additional  commands from the terminal.  The TOPS-20 POP
   command returns the user to 1022.  If a fatal error occurs while  EXEC
   is  processing  the USING arguments, the remainder of the USING string
   is ignored.  When performing a PUSH command  with  the  USING  string,
   EXEC does not echo the commands specified in the string.

   The user cannot give the PUSH command if an open data set  has  update
   mode on.  When 1022 receives the PUSH command while in update mode, it
   SPECIAL COMMANDS AND FEATURES                                Page 7-31
   Revision 4


   prints an error message.



   7.9  FILE COMMAND

   The FILE command manipulates disk files from the  stand-alone  System.
   The four options:  COPY, DELETE, RENAME, and TYPE are described below.
   The options may be abbreviated to their first three characters only.

   No wildcards ("%", "?", or "*") are accepted in the FILE commands.

   Option:  COPY

   This copies a disk file:

        FILE COPY <file-descriptor-1> [TO] <file-descriptor-2>        ___  ____

        [BUFFERS <n>]         ___   _

   Where:

   <file-descriptor-1>  -  Is the source file.

   <file-descriptor-2>  -  Is the destination file.

   BUFFERS <n>  -  is the number of blocks (or quarter pages)  of  buffer
   space  allocated  for  the  file transfer.  Use it to efficiently copy
|  very large files.  The keyword BUFFERS may be abbreviated BUFS.


   Option:  DELETE

   This command deletes the named disk file:

        FILE DELETE <file-descriptor>        ___  ______


   Option:  RENAME

   This command renames a disk file:

        FILE RENAME <file-descriptor-1> [TO] <file-descriptor-2>        ___  ______

   Where:

   <file-descriptor-1>  -  Is the source file.

   <file-descriptor-2>  -  Is the destination file.
   SPECIAL COMMANDS AND FEATURES                                Page 7-32
   Revision 4


   Option:  TYPE

   This command prints a disk file on the user's terminal:

        FILE TYPE <file-descriptor>        ___  ____

   Type  Control-O  to  suppress  output  to  the  terminal.   Type   two
   Control-C's,  followed  by the monitor command REENTER, to stop in the
   middle of printing a file and return to 1022 command level.



   7.10  USERCALL COMMAND

   The  USERCALL  command  passes  values  from  interactive  1022  to  a
   user-written  MACRO  routine  on  TOPS-20  systems.  USERCALL does not
   return values from the MACRO routine to interactive 1022.

   The MACRO routine called by USERCALL must be merged with 1022 so  that
   it  may  be accessed.  The address of the MACRO routine must be placed
   in the system variable SYSUSERADR or SYSUSRADRP prior  to  any  calls.
   See  the  MACRO  chapter  of  the  System 1022 Host Language Interface                                      ______ ____ ____ ________ _________
   Manual for loading conventions and an example MACRO routine.   ______

   The syntax of the command is:

             USERCALL [expression [,] ...  ]

   where each expression evaluates to a value to be passed to  the  MACRO
   routine.

   For example, the following commands first set  SYSUSERADR  to  208904,
   the  memory  location  of  the MACRO routine.  Then USERCALL calls the
   routine, passing the values "ECHO" and 1.  The USERCALL  routine  then
   reads  the  arguments  and  performs the appropriate actions.  In this
   example the routine calls a subroutine to turn terminal echo off.

        * LET SYSUSERADR 208904
        * USERCALL "ECHO" 1
        *












                                 CHAPTER 8

                         DATA PROGRAMMING LANGUAGE



   8.1  PL1022

   The commands  in  System  1022  are  effective  individually  for  the
   interactive  user,  but  there  are  situations  in  which this is not
   enough.  Many problems  can  be  solved  by  using  PL1022,  the  data
   programming language that operates within System 1022.

   The user with some programming experience  should  be  able  to  write
   PL1022  programs  without  resorting to more complicated host language
   programs.  Also, the PL1022 options to define and use variables extend
   the power and flexibility of the interactive command language.

   A PL1022 program recognizes  an  extended  command  syntax,  including
   structured  constructs,  labeled  statements,  and  control  branches.
   Control  branching  can  occur  conditionally  (IF,  IF  THEN   ELSE),
   unconditionally  (GOTO),  or  through  subroutines  (CALL and RETURN).
   Iterative loops are executed by structured REPEAT or WHILE commands or
   by  a  combination  of  predefined  index  variables  and  conditional
   branching.

   PL1022 procedures may  be  included  in  report  programs  to  produce
   customized  reports  by  adding  the  special  logic  needed  onto the
   existing structure of  the  report  program.   Use  of  statements  in
   reports  is  the  same  as in PL1022;  consider reports as a specially
   structured  PL1022   procedure.    Users   interested   in   producing
   sophisticated,  customized  reports  should  read  this chapter before
   reading about the advanced features of the report program.

   A PL1022 program may be executed in one of three ways.  In  the  first
   of  these,  the  user types a PL1022 program directly into 1022.  This
   method provides interactive error checking as you enter  the  program,
   but the program cannot be saved for other executions.

   More commonly, the user creates and edits a PL1022 program in  a  disk
   file,  either  at  monitor  level  or from within 1022 with one of the
   internal text editors, such as TECO or SOS.  Execution of the  program
   is  initiated with a USE command or @file construction (see Chapter 2,
   "Command Files").
   DATA PROGRAMMING LANGUAGE                                     Page 8-2
   Revision 4


   When they are of the appropriate format, PL1022 programs in disk files
   may be precompiled with the COMPILE command and then executed with the
   PERFORM command  (see  "COMPILE  and  PERFORM"  at  the  end  of  this
   chapter).



   8.2  SUMMARY OF PL1022 COMMANDS AND STATEMENTS

   The following are PL1022 commands.  Those marked with an asterisk  (*)
   may  be  used  outside PL1022 or report programs.  The others are used
   only within PL1022 or reports.

   * ACCEPT       Reads the value of a variable from the terminal.     __

     CALL         Executes a PL1022 subroutine.     ____

     GOTO         Branches to a statement within the PL1022 program.     __

   * IF           Tests  an   expression   and   transfers   control     __
                  depending on the outcome of the test.

     LEAVE        Exits a structured statement block in PL1022.     _____

|    PL1022 DEBUG Activates the PL1022 debugger at run time (see the     __     _____
|                 "Debugging   PL1022   Programs"  section  of  this
|                 chapter).

     PL1022 END   Marks the end of a PL1022 program and  starts  the     __     ___
                  execution of the program.

     PL1022 START Declares  that  the  commands  to  follow  form  a     __     _____
                  program module and executes them as a group.

     PL1022 STOP  Halts execution of a PL1022  program  and  returns     __     ____
                  control to the interactive command level.

     QUIT         Ends the entry of an  interactive  PL1022  program     _
                  without  executing  it  and  returns  to  ordinary
                  command input.

   * REPEAT       Executes  a  sequence  of  commands  in  a  PL1022     ______
                  program repeatedly until its termination condition
                  is satisfied.

     RETURN       Terminates a PL1022 subroutine and returns to  the     ___
                  next statement following the last executed CALL.

   * WHILE        Executes  a  sequence  of  commands  in  a  PL1022     _____
                  program repeatedly while its enabling condition is
                  satisfied.
   DATA PROGRAMMING LANGUAGE                                    Page 8-2A
   Revision 4


   Refer  to  the  System  1022  Host  Language  Reference   Manual   for                   ______  ____  ____  ________  _________   ______
   information  about  using  System  1022  directly from FORTRAN, COBOL,
   MACRO, or other languages.  System 1022 is available as  a  subroutine
   library for this purpose.
   DATA PROGRAMMING LANGUAGE                                    Page 8-2B
   Revision 4


   figure 28
                        [ This page intentionally left blank ]
   DATA PROGRAMMING LANGUAGE                                     Page 8-3
   Revision 4


   8.3  RUNNING A PL1022 PROGRAM

   A PL1022 program begins with:

        PL1022 START.        __     _____

   The body of the program follows.  The program ends with:

        PL1022 END.        __     ___

   A PL1022 program may be entered interactively or  written  to  a  disk
   file.   Programs  of  the appropriate format that have been written to
   disk files may subsequently be precompiled with  the  COMPILE  command
   and  then  executed  with  the  PERFORM  command  (see below).  When a
   program has not been precompiled, compilation begins with  the  PL1022
   START command and ends with the PL END command.  Execution then begins
   with the PL1022 END command, ending with PL1022 STOP  or  PL1022  END.
   After   execution,  control  returns  to  interactive  command  level,
   indicated by the command prompt (*).

   To run a PL1022 program from a disk file, give the USE  or  @  command
   after opening the data sets.  For example,

        *OPEN BONUS
        *USE UPSAL.DMC

               or               __

        *OPEN BONUS
        *@ UPSAL.DMC

   Either of these constructions will run the PL1022 program  written  in
   the file UPSAL.DMC.  If System 1022 discovers an error as it reads the
   program, the program does not execute, and an error message is printed
   to the terminal.  Correct the mistake using a text editor.



   8.3.1  Interactive PL1022

   You may type in a PL1022 program interactively rather than run it from
   a  disk  file.   System  1022  checks each interactive line for syntax
   errors as you enter it.   However,  you  must  enter  the  interactive
   program again to run it again since you are not writing the program to
   a file to be saved.

   You begin an interactive PL1022 program with the PL1022 START command.
   System  1022  responds  with  a  modified  prompt string, "* (PL)", to
   indicate it is in PL1022 input mode.

   If an error is  discovered  during  interactive  program  entry,  1022
   prints  an  error  message and ignores the last input so that the user
   may retype the command.
   DATA PROGRAMMING LANGUAGE                                     Page 8-4
   Revision 4


   The following session illustrates an interactive PL1022 program:

        * PL1022 START        _
        * (PL) CLEAR        ______
        ?(CS167) Command not allowed in PL1022 or REPORT        ________ _______ ___ _______ __ ______ __ ______
         CLEAR         _____
        Command ignored, continue...        _______ ________ ___________
        * (PL) WHILE DEPT EQ SALES DO        ______
        * (PL)   GETREC LEAVE        ______
        * (PL)   IF BONUS LT .1*SALARY CHANGE BONUS .1*SALARY        ______
        * (PL) ENDWHILE        ______
        * (PL) PL1022 END        ______
           !Execution begins here.

        The data set is opened and the  selection  group  is  formed  and
        sorted  before  this  program  is entered (not shown).  The CLEAR
        command, which must occur outside of PL1022 context, is  ignored.
        For  each  SALES  department  record, a BONUS of less than 10% of
        SALARY is changed to 10% of SALARY.

   Errors that follow labels do not require you to retype the label.  The
   label  is  already correctly defined, and only the statement should be
   retyped.  Here is an example of error correction  of  a  line  with  a
   label (LABL:) during an interactive PL1022 session:

        * PL1022 START        _
        * (PL) LABL: FINE AGE 30        _ ____
        ? (CS24) Invalid command        _ ______ _______ _______
          START: FINE          ______ ____
        Command ignored, continue..        _______ ________ __________
        * (PL) FIND AGE 30.        _ __ _
        * (PL)  ...        _ __ _

   You may stop entering a PL1022 program, without executing anything, by
   typing  "QUIT"  to  the  *(PL)  prompt.  QUIT halts compilation of the
   program and returns the user to ordinary interactive 1022.



   8.4  USING 1022 COMMANDS IN PL1022

   Most 1022 commands can be used within a PL1022 program, but there  are
   exceptions.   Some  commands,  such as COLLECT, JOIN, and PERFORM, are
   illegal within a PL1022 program (see Chapter  2,  "Summary  of  System
   Commands").    Others,  such  as  OPEN  and  PERMIT,  are  subject  to
   restrictions in their use within PL1022 programs (see "OPEN in  Pl1022
   Programs"  and  "COMPILE  and  PERFORM" in this chapter).  Some others
   have extended forms when used in PL1022 (see  "GETREC  Statement"  and
   "DBSET Statement" in this chapter).

   The ADD command prompts the user for missing attribute values.   In  a
   PL1022  program,  the  ADD  command will prompt for values when PL1022
   compiles rather than when the PL1022 program executes.  An ADD command
   DATA PROGRAMMING LANGUAGE                                     Page 8-5
   Revision 4


   cannot  work  correctly in a PL1022 program unless it specifies values
   for all attributes.  Either provide attribute names and values for all
   the attributes, or end the ADD command with the NUL clause so that the
   command will not prompt for unspecified values.



   8.5  BOOLEAN EXPRESSIONS

   Several PL1022 commands accept Boolean expressions.   The  form  of  a
   Boolean expression is:

        <expression>   <operator>   <expression>

   The two expressions are evaluated and compared to each other using the
   relational  or  logical  operator.   (See  "Relational  Operators" and
   "Logical Operators" in Chapter 4).   The  result  is  either  true  or
   false.   The  operators are the same in all 1022 uses, except that the
   two-word versions of the relational operators  (like  NOT  EQUAL,  NOT
   BET,  or NOT BEG) can be used in FIND, SEARCH, and SELECT commands but
   not elsewhere.

   If either expression is a TEXT value, the other  must  also  be  TEXT.
   The  value  of SYSCASE determines whether upper and lower case have an
   effect on comparisons of TEXT.  When SYSCASE is 0, 1022  distinguishes
   between  upper  and  lower  case.   When  it  is  1, 1022 ignores case
   differences.  All TEXT constants appearing to the left of a relational
   operator  must be quoted.  Only TEXT constants that contain spaces and
   appear to the right of a relational operator must be quoted.

   If both expressions are numeric, the second is converted to  the  type
   of  the  first before the comparison is made.  If the first expression
   has an integer value and the second  a  real  value,  this  conversion
   means  that  the real value is truncated to the integer next closer to
   0.  For example, 3.7 is truncated to 3 and -1.7 is changed to -1.   If
   the  first  expression  is  real  and  the second is integer, then the
   integer is converted to real for the comparison.  Date  variables  are
   treated as integer for these conversions.

   A PL1022  statement  uses  the  values  of  any  attributes  from  the
   currently  selected record (see GETREC).  When more than one record is
   selected, the PL1022 statement uses the values from the  first  record
   in the group.



   8.5.1  Multiple Matching Values

   Boolean expressions may have many matching values for each  relational
   operator.   The multiple values simplify Boolean expressions where one
   term, on the left, is compared to many terms on the  right.   Multiple
   values can follow any of the relational operators.
   DATA PROGRAMMING LANGUAGE                                     Page 8-6
   Revision 4


   Example:

        AGE EQ (10,14,17) AND NAME  BET  ('A','C','M','S')  AND  NAME  NE
        ('ADAMS','PHILLIPS')

   is identical to:

        (AGE EQ 10 OR AGE EQ 14 OR AGE EQ 17) AND (NAME BET 'A' 'C' OR
        NAME BET 'M' 'S') AND (NAME NE 'ADAMS' AND NAME NE 'PHILLIPS')

   Multiple values must be enclosed in parentheses and  separated  within
   the parentheses by commas.

   Negative operators (like NE and NBET) relate multiple values with AND,
   as  in  NAME  NE 'ADAMS AND NE 'PHILLIPS'.  All other operators relate                           ___
   values with OR, as in AGE EQ 10 OR AGE EQ 14.                                   __

   Multiple  values  may  be  followed  by  a  comma  before  the   final
   parenthesis  so  that  lists of values can be easily written to a file
   and then referenced with the at-sign (@) construction.   For  example,
   (10,14,17,) is equivalent to (10,14,17).

   Display numeric data is compared using  its  numeric  value,  not  its
   character by character representation.



   8.6  STATEMENT LABELS

   The user can change the flow of control within a PL1022 program  using
   labels  and  GOTO  statements.   The  user  may  attach a label to any
   statement in the program and alter the flow of control  to  resume  at
   any statement which has a label.

   A label contains from 1 to 10 alphanumeric characters starting with  a
   letter.   Put  a  label on a command by preceding it with the label, a
   colon, and a following space or tab as separator.

   A label may be placed before a command, on a blank line, or on a  line
   with just comments.

   A label need not appear in program sequence before it  is  referenced,
   but  it  must  appear  somewhere  in the PL1022 program in which it is
   used.  Labels are used only within a PL1022 program or report and have
   no  meaning  outside  one.  They are cleared each time the user ends a
   PL1022 execution.  1022 indicates an  error  if  a  label  is  defined
   twice.


   Examples of labels:

        START: FIND AGE EQ 10.
        L1011: FIND SEX F.
   DATA PROGRAMMING LANGUAGE                                     Page 8-7
   Revision 4


        Y:
        X: FIND JOB PLUMBER.



   8.6.1  GOTO Statement

   The GOTO statement transfers control to a statement with a label.  The
   form is:

        GOTO <label>.        __



   8.7  IF STATEMENTS

   The IF statement in PL1022 tests an expression and  transfers  control
   according  to  the  result.  The expression may be a complex, compound
   Boolean relationship.   Control  may  apply  to  single  commands,  or
   programs   may   have  a  block-structured  form  using  the  familiar
   IF--THEN--ELSE and related constructions.

   Structured IF statements may be used interactively, in command  files,
   and  in  reports,  as  well as in PL1022 programs.  The command PL1022
   START need not precede the use of structured IF.

   Structured IF is a new feature of version 114E and later  versions  of
   1022.   The  compatibility system variable SYSIFTYPE controls its use;
   the value 1 indicates the structured IF can be used.   Your  site  may
   have established this as the default value, or you may set it yourself
   with the command LET SYSIFTYPE EQ 1.  Any LET  command  which  changes
   SYSIFTYPE should precede PL1022 START.

   Older PL1022 programs may not run properly unless SYSIFTYPE is 0.  For
   more information, see the section below "IF Statement Compatibility."



   8.7.1  IF Statements With Labels

   The labels form of the IF statement transfers  control  to  a  labeled
   statement   depending  on  the  outcome  of  the  test  on  a  Boolean
   expression.

   The syntax for this IF statement is:


        IF <simple-Boolean-expression> GOTO <label>.                                       __


   The simple Boolean expression may not include logical  operators.   It
   is  evaluated.   If  the  expression  is  true,  control passes to the
   labeled statement.  If the expression is false, then the next  command
   DATA PROGRAMMING LANGUAGE                                     Page 8-8
   Revision 4


   in line is executed.

   Example:

        IF AGE GE 30 GOTO LAB30.

        Control passes to the label LAB30 if AGE is greater than or equal
        to 30.  Otherwise control passes to the next command in line.



   8.7.2  Structured IF Statement

   The structured IF statement tests an expression and transfers  control
   to  blocks of commands depending on the outcome of the test.  Compound
   IF THEN ELSE  constructions  are  allowed.   See  "Implicit  DBSET  in
   Structured Blocks" in this chapter for information about multiple data
   sets and structured commands.



   8.7.2.1  IF Statement Applied To A Single Command

   The syntax for executing conditionally any single command is:


        IF <Boolean-expression> <command>.


   The Boolean expression is tested.  If it is true, the command  in  the
   IF  statement is executed.  If it is false, control passes to the next
   command in line.

   Example:

        IF (1*J LT 2*K OR K EQ 7) AND FN BEGINS "S" PRINT 'YES'.

        The expression is evaluated.  If it is true, YES is printed.   If
        it is not, control passes to the next command.



   8.7.2.2  IF THEN Statement With A Block Of Commands.

   The compound IF THEN statement tests a  Boolean  expression.   If  the
   expression  is  true, the following commands in the block execute.  If
   it is false, the block is skipped and control passes  to  the  command
   after  the  end  of  the  block.   END or ENDIF defines the end of the
   block.

   DATA PROGRAMMING LANGUAGE                                     Page 8-9
   Revision 4


   Example:

        IF A GT B THEN
           PRINT A.
           FIND AGE EQ A.
           CHANGE AGE B.
        ENDIF.

        If A is greater than B the block of commands  (PRINT,  FIND,  and
        CHANGE) executes.

   The syntax for this IF statement is:

        IF <Boolean-expression> THEN <commands>

        {ENDIF.}
        {END.  }





   8.7.2.3  IF--ELSEIF--ELSE Statements

   The compound IF--ELSEIF--ELSE statement  tests  a  series  of  Boolean
   expressions and executes different blocks of commands depending on the
   result.

   Example:

        IF CODE BEG ('A','Z') THEN
              ADD CODE 'AZ' ID 17.
              PRINT ALL.
           ELSEIF CODE BET 'B' 'H' THEN
              ADD CODE 'BH' ID 18.
              PRINT ALL.
           ELSE
              PRINT '?ILLEGAL CODE'.
              ADD CODE 'ILL' ID -1.
        ENDIF.

        If the code begins with A or Z, then  the  first  ADD  and  PRINT
        commands  execute.  If the code does not begin with A or Z but is
        between B and H, the second ADD and PRINT commands  execute.   If
        the  code  does not begin with A or Z and is not between B and H,
        the final PRINT and ADD commands execute.

   DATA PROGRAMMING LANGUAGE                                    Page 8-10
   Revision 4


   The full syntax for the compound IF statement is:

        IF <Boolean-expression> THEN <commands>

           [ELSEIF <Boolean-expression> THEN <commands>]

           ...

           [ELSEIF <Boolean-expression> THEN <commands>]

           [ELSE <commands>]

        {ENDIF.}
        {END.  }


   The first Boolean expression is tested.  If it is true,  the  commands
   following  the  first  THEN  execute  and  control  passes to the next
   command after the ENDIF (or END) which  defines  the  end  of  the  IF
   command.   If  it  is false, control passes to the next ELSEIF or ELSE
   clause.

   The Boolean expression in the ELSEIF clause is tested.  If it is true,
   the commands introduced by THEN execute, and control finally passes to
   the command following ENDIF.  If it is false, control  passes  to  the
   next ELSEIF or ELSE clause.

   If control passes to the ELSE  clause,  the  commands  following  ELSE
   execute and control passes to the command following ENDIF.



   8.7.2.4  Nesting IF Statements

   IF statements can be nested to any level.  In  the  following  example
   notice  the  difference  between  (1)  an  ELSEIF clause and (2) an IF
   statement nested in an  ELSE  clause.   The  ELSEIF  clause  does  not
   require an END or ENDIF statement;  the IF block requires one.

   DATA PROGRAMMING LANGUAGE                                    Page 8-11
   Revision 4


   Example:

        IF AGE LT 21 THEN
           PRINT NAME AGE "MINOR".
           CHANGE CLASS 1.
        ELSEIF AGE LE 65 THEN
           PRINT NAME AGE.
           CHANGE CLASS 2.
        ELSE
           PRINT "AGE IS GREATER THAN 65".
           IF AGE LE 100 THEN
              PRINT NAME AGE "RETIRED".
              CHANGE CLASS 3.
           ELSE
              PRINT NAME AGE "FAULTY AGE DATA".
           ENDIF.
        ENDIF.

        The first IF statement selects records with ages  less  than  21.
        The  ELSEIF  clause  selects  ages  between 21 and 65.  A message
        prints for ages greater than 65.  The  IF  statement  within  the
        ELSE  clause  selects  ages  between 66 and 100, giving different
        error messages for the two ranges of age.



   8.7.2.5  Ending Commands And Compound IF Statements

   Each command in a PL1022  program  ends  with  a  period.   The  THEN,
   ELSEIF, and ELSE keywords are not terminated with a period.

   Each compound IF statement ends with ENDIF or END.  The  ENDIF  checks
   that  it ends an IF statement, and so is especially useful when IF and
   WHILE statements are nested or mixed.  END does no checking.



   8.7.3  IF Statement Compatibility

   Versions of  1022  before  114E  allowed  IF  statements  with  simple
   relational expressions and labels in two equivalent forms:

        IF <simple-Boolean expression> GOTO <label>

        IF <simple-Boolean expression> THEN <label>

   Only the "GOTO" form  is  compatible  with  the  newer  structured  IF
   statements.  To resolve this incompatibility, either (1) change "THEN"
   to "GOTO" before labels in programs, or (2) set  the  system  variable
   SYSIFTYPE  to  0.   When SYSIFTYPE is 0, IF statements with labels are
   the only form of IF statement allowed.
   DATA PROGRAMMING LANGUAGE                                    Page 8-12
   Revision 4


   8.8  REPEAT STATEMENT

   The REPEAT statement  executes  a  command  or  sequence  of  commands
   repeatedly until a termination condition is satisfied.  The syntax is:


        REPEAT <commands>

        UNTIL <Boolean-expression>.


   The commands following REPEAT are executed in order.  Then the Boolean
   expression  is  tested.   If  it  is  true, control passes to the next
   command.  If it is false, control passes back  to  the  first  of  the
   commands  that  follow the keyword REPEAT.  The loop is repeated until
   the Boolean expression is  true.   The  statements  in  the  loop  are
   executed at least once.

   Example:

        LET J=0.

        REPEAT
           PRINT J=J+1.
        UNTIL J GT 10.

        The REPEAT statement prints the integers 1 through 11.  The first
        time  through the loop, J becomes equal to 1 and is printed.  The
        Boolean expression J GT 10 is now false, and control  returns  to
        the  top  of  the  loop.   J becomes equal to 1+1, prints, and is
        still not greater than 10.  Since the assignment command  (J=J+1)
        affects   the   terminating  condition,  the  Boolean  expression
        eventually becomes true and the loop terminates.

   The REPEAT statement can be used outside PL1022  in  reports,  command
   files,  and  interactively.   No  PL1022  START  command need be given
   before using REPEAT.



   8.9  WHILE STATEMENT

   The WHILE statement, like the REPEAT statement, executes a command  or
   sequence  of  commands  repeatedly  until  a  termination condition is
   satisfied.  Unlike REPEAT, its termination condition is tested at  the
   beginning rather than at the end of the loop, and it repeats until its
   termination condition becomes false rather than true.

   DATA PROGRAMMING LANGUAGE                                    Page 8-13
   Revision 4


   The syntax is:

        WHILE <Boolean-expression> DO <commands>

        {ENDWHILE.}
        {END.}


   The Boolean expression is tested.  If it is false, control  passes  to
   the  command  following  ENDWHILE or END.  If it is true, the commands
   following DO are executed in sequence and the  Boolean  expression  is
   tested  again.   The sequence of commands is repeatedly executed until
   the expression becomes false.

   Example:

        LET J=0.

        WHILE J LT 10 DO
           PRINT J=J+1.
        ENDWHILE.

        The WHILE block prints  integers  1  through  10.   It  tests  J,
        increments the value for J, prints J, then tests J again.  When J
        is no longer less than 10, control passes to  the  first  command
        after  ENDWHILE (or END).  As with the REPEAT statement, at least
        one of the commands in the sequence must affect  the  terminating
        condition to avoid an infinite loop.

   ENDWHILE ends a preceding WHILE statement, and so is especially useful
   when  IF and WHILE statements are nested or mixed.  END does not check
   what kind of statement it ends.

   The WHILE statement can be used outside  PL1022  in  reports,  command
   files,  and  interactively.   No  PL1022  START  command need be given
   before using WHILE.



   8.10  LEAVE STATEMENT

   The LEAVE statement exits a structured loop  (REPEAT,  WHILE)  without
   specifying a label.  The syntax is:

        LEAVE.

   When LEAVE executes, control passes directly to the end of the current
   loop without executing intervening commands.

   DATA PROGRAMMING LANGUAGE                                    Page 8-14
   Revision 4


   Example:

        LET SYSIFTYPE 1.
        OPEN SCHEDULE.
        PL1022 START.

        LET J=1.
        SORT YEAR DESCENDING.

        WHILE J LE 100 DO
           GETREC LEAVE.
           IF YEAR LT 1975 LEAVE.
           PRINT NAME ID YEAR.
           LET J=J+1.
        ENDWHILE.

        The WHILE block prints from each record in sorted  order,  up  to
        the first 100 records in the selection group.  If it exhausts the
        selection group before processing  100,  GETREC  LEAVE  transfers
        control to the end of the WHILE block.  If YEAR becomes less than
        1975 before  100  records  have  been  processed  or  before  the
        selection  group  is  exhausted,  the  LEAVE  in the IF statement
        transfers control to the end of the WHILE block.

   When a LEAVE command  outside  a  structured  loop  executes,  control
   passes  to  the  end  of  the  PL1022  program.   A LEAVE command in a
   subroutine which is called from within a structured loop is treated as
   a  LEAVE  outside  of  the  loop, and control passes to the end of the
   Pl1022 program.  The LEAVE statement can be  used  outside  PL1022  in
   reports,  command  files,  and interactively.  No PL1022 START command
   need be given before using LEAVE.



   8.10.1  GETREC Statement

   The  GETREC  command  used  in  PL1022  programs  differs   from   the
   interactive  GETREC in the way it acts when it cannot select a record.
   The interactive form produces an  error  message  when  no  record  is
   selected.   The PL1022 form includes either a LEAVE command or a label
   which identifies the next statement to execute when no records remain.

   The GETREC command selects  one  record  from  the  current  group  of
   records  for individual processing.  Commands such as PRINT and CHANGE
   process the entire selected group of records  when  executed  after  a
   FIND  or SEARCH, but operate only on an individual record of the group
   after a GETREC command.  The first  GETREC  after  a  FIND  or  SEARCH
   selects  the  first  record  of  the  group.   Thereafter, each GETREC
   selects the next record until the records are exhausted.  At the  end,
   control transfers to the label which is named in the command.

   A second form  of  GETREC  includes  an  expression  which  names  the
   sequence  number of the record to select.  This is the position of the
   DATA PROGRAMMING LANGUAGE                                    Page 8-15
   Revision 4


   record in the current group, not its SYSID.  If the group is too small
   to  have  a record with that sequence number, control transfers to the
   named label.  If the expression is not an integer, it is truncated  to
   integer before GETREC selects a record.

   Examples:

        GETREC LABL1.

        This is the  standard  GETREC  statement  in  a  PL1022  program.
        Either  the  next record is selected, or control transfers to the
        statement with the label LABL1.

        GETREC LABL2 (SYSNREC-INDEX).

        This GETREC selects the next record according to the  expression.
        If  the  user  increases  INDEX  by one on each iteration of some
        loop, the records are  retrieved  in  reverse  order.   When  the
        expression  value  reaches  0, the GETREC cannot select a record,
        and transfers to the statement with label LABL2.



   8.10.1.1  LEAVE With GETREC

   The LEAVE command can be used in place of the out-of-records label  in
   a GETREC command within a structured loop.

   Example:

        LET J=1

        WHILE J LT 10 DO
           GETREC LEAVE.
           PRINT NAME AGE.
           LET J=J+1.
        END.

        The WHILE loop prints the NAME and AGE from  each  of  the  first
        nine  records  in  the  selection group.  If there are fewer than
        nine records, the GETREC LEAVE command transfers control  to  the
        end of the WHILE block after the last record.

   When a LEAVE command  executes  outside  a  structured  loop,  control
   passes to the end of the PL1022 program.

   The keyword LEAVE is reserved and should not be used as a label  in  a
   PL1022 program.
   DATA PROGRAMMING LANGUAGE                                    Page 8-16
   Revision 4


   8.11  SUBROUTINES IN THE PL1022 PROGRAM

   The user constructs and executes subroutines in a PL1022 program  with
   the CALL and RETURN statements.  Use subroutines as follows:

        1. A subroutine begins with a labeled statement and ends  at  one
           or more RETURN statements.

        2. Pass control to a subroutine only by  a  CALL  statement;   if
           1022  encounters  a RETURN statement when no matching CALL has
           been made, an error occurs.

        3. A subroutine may be entered at any labeled statement.

   The CALL command is like a GOTO command, except  that  1022  remembers
   the  address  of  the  command.  When a RETURN command is encountered,
   control resumes after the last CALL command  that  was  executed.   No
   arguments are passed by the CALL command;  the called routines use the
   same variables as other commands in the PL1022 segment.

   CALL and RETURN commands may be nested;  1022 keeps track of 5  levels
   of  subroutine nesting.  The user insures that each CALL is terminated
   by a matching RETURN and that no RETURN is encountered unless  a  CALL
   is  in  effect.   Violation  of  these  rules  causes  execution error
   messages.

   Example:

                  PL1022 START.
                  CALL RT1.
                  CALL RT2.
                  CALL RT1.
                  PL1022 STOP.

        RT1:      (commands)

                  RETURN.

        RT2:      CALL RT1.
                  (commands)

                  RETURN.

                  PL1022 END.

   GOTO, IF, and other commands that transfer control do not  affect  the
   logical operation of the CALL - RETURN pairings.
   DATA PROGRAMMING LANGUAGE                                    Page 8-17
   Revision 4


   8.11.1  PL1022 STOP Statement

   PL1022 STOP terminates the execution of the PL1022 program.   This  is
   similar  to  a  STOP in FORTRAN or a STOP RUN in COBOL.  The statement
   is:

        PL1022 STOP        __

   This command stops execution of the program, and control resumes after
   the  PL1022  END command.  If commands are being read from a file, the
   next command is read following the PL1022 END.



   8.12  VARIABLES IN PL1022

   You may use variables in PL1022 programs  and  reports  for  temporary
   storage  of  data values.  These variables are assigned values in many
   ways, tested in conditional statements, and displayed by the PRINT and
   TYPE  commands.   The variables used in PL1022 are first identified to
   1022 with a DEFINE command, or by a LET or EVALUATE command  in  which
   the variable is assigned a value.  In this way 1022 is informed of the
   variable's name and data type, and the variable can be used  in  later
   1022 commands.

   Variables are not restricted to use within the PL1022  program.   They
   may be defined and assigned values interactively.

   Variables remain defined for any use in 1022 until you  exit  1022  or
   execute  a CLEAR command.  (Variables defined in a precompiled program
   that do not match any existing variables  at  execution  time  are  an
   exception  to  this  rule.   Such  variables are treated as temporary,
   disappearing after execution of the program [see "COMPILE and PERFORM"
   below].)  Variables are not local for a block in PL1022.

   Set the value of a variable with the following commands:

        DEFINE    Defines the variable.

        LET       Assigns a value to the variable.

        EVALUATE  Assigns a value involving totals to the variable.

        ACCEPT    Reads a value for a variable from the terminal.

   Variables may  be  used  in  any  1022  command  where  an  arithmetic
   expression   or  text  value  is  allowed.   See  also  this  chapter,
   "Variables in 1022 Commands".
   DATA PROGRAMMING LANGUAGE                                    Page 8-18
   Revision 4


   8.12.1  DEFINE Command

   The DEFINE command is the primary way  to  define  variable  names  to
   1022.  The command can be used either during an interactive session or
   in a PL1022 program.  All variables must be  defined  to  1022  before
   being  used in any commands except the LET and EVALUATE commands.  The
   needed DEFINE commands must appear physically before the  use  of  the
   variables.

   The form of the command is:

        DEFINE [ <variable-type> ] <variable> [<variable>]...

               [<variable-type> <variable> [<variable>]...]...

   Where:

   <variable-type>     Is the System 1022  data  type  of  the  following
                       variable  names.   If  no  variable type is given,
                       System  1022  follows  FORTRAN's   variable   type
                       conventions:   variables starting with an I, J, K,
                       L, M, or N are integers;  all others are real.

   <variable>          Is a variable or array name to be defined as  this
                       data  type.   Define  an  array  by  including the
                       subscript dimensions as part of the variable name.
                       Every  entry  in  the array has the described data
                       type.  The  variable  name  contains  one  to  ten
                       alphanumeric  characters  starting  with a letter.
|                      The name cannot be any of the System 1022 reserved
|                      words  listed  in  Appendix B.  An array has up to
                       seven subscripts (dimensions).  An array subscript
                       may vary between plus and minus 131,071.

   The variable-types are:


       INTEGER         This is a  single-precision  integer.   It  stores
                       values in the range plus or minus 34,359,738,367.

       DOUBLE INTEGER  This is a  double-precision  integer.   It  stores
                       values  in  the approximate range of plus or minus
                       1.18 * (10**21) (a 22-digit number).

       REAL            This is a single-precision floating  point  value.
                       It  stores  values  in  the range of plus or minus
                       10**(-38) to 10**38, and stores 8  decimal  digits
                       of precision.  Rounding errors in calculations and
                       conversions  show  up  in  the  eighth  digit   of
                       precision.

       DATE            This is a half-word integer which  stores  a  date
                       value  between  18000101  (January  1,  1800)  and
   DATA PROGRAMMING LANGUAGE                                    Page 8-19
   Revision 4


                       25170922 (September 22, 2517).

       TEXT <length>   A text value of the specified  length,  which  may
                       store   strings   of  characters  from  the  ASCII
                       character set.  The length  is  from  1  to  65535
                       characters.

   Examples of DEFINE:

        DEFINE INTEGER I J K IAR(5) JAR(2,5) AAR(3,3,20).

        DEFINE INTEGER DTOT GRPTOT(3,3).

        DEFINE TEXT 10 NAME ADDRESS(3).

        DEFINE TEXT 100 ABSTRACT TEMP1(8).



   8.12.1.1  Lower Subscript Bounds


   When a single number is given for a subscript bound, the  lower  bound
   defaults  to  1.  So IAR(5) accepts subscripts in the range of 1 to 5.
   To define subscripts with other  lower  bounds,  replace  any  or  all
   subscript  numbers  with  a  pair of the form lowbound:highbound.  The
   array accepts subscripts in that position which fall  in  that  range.
   For example:

        DEFINE INTEGER IAR(-3:5) JAR(-10:-1) AAR(3,0:3,20)



   8.12.1.2  Multiple Definitions Of Type

   The user may define more than one type of variable in a single  DEFINE
   statement.   Precede  each  group  of variables by the proper variable
   type keyword(s).  This may be done on many  lines  for  clarity.   For
   example:

        DEFINE INTEGER IAR REAL XSUM.

        DEFINE INTEGER JFI JAR
               REAL    YSUM ZSUM.

   The commands here are ended by periods and operate as shown  from  DMC
   files.  If the second example is typed from the terminal, continue the
   command from line to line with "-".
   DATA PROGRAMMING LANGUAGE                                    Page 8-20
   Revision 4


   8.12.1.3  Initial Values And Redefinition

   Variables and arrays  are  initialized  at  the  time  the  DEFINE  is
   processed.  Integers and reals are cleared to zero, text is cleared to
   blanks, and dates are cleared to JAN 1, 1800 (a zero integer value).

   Once a variable is defined, it may not be  redefined  to  a  different
   data  type, length, or array structure unless a CLEAR command has been
   issued.  CLEAR may not be issued in a  PL1022  program.   (See  "CLEAR
   command"  in  this  chapter.) For convenience, a variable may be named
   again in a DEFINE command if its definition does not change.   When  a
   variable is redefined, it is initialized.



   8.12.2  LET Command

   The LET command sets the values of variables and  performs  arithmetic
   operations on them.  The form of the command is:

        LET <variable> {[EQ]} <expression> [ [,] <var> {[EQ]} <exp> ] ...
                       {[= ]}                          {[= ]}

   The variable being assigned a value can  be  any  that  the  user  has
   defined,  or can be one that the user wants to define.  LET defines an
   undefined variable before assigning it a  value.   Variables  starting
   with  the  letters I through N are defined as INTEGER;  the others are
   defined as REAL.

   The expression can contain the name of the variable being  assigned  a
   value;   1022  uses  the  old  value of the variable in the expression
   before the variable is changed.  If the variable  and  the  expression
   have different numeric types, the expression value is converted to the
   result type when setting the variable (See  Chapter  2,  Expressions).
   If  one  is  TEXT,  then  the  other  must be TEXT or 1022 rejects the
   command with an error message.

   Text literals must be enclosed in quotes to avoid any  confusion  with
   attribute names and variable names.

   The expression may  not  contain  any  of  the  Totals  or  Statistics
   functions  described in Chapter 2, System Functions.  Use the EVALUATE
   command for this purpose (see below).

   The keyword EQ or = may be omitted from the command.  The user may put
   more  than  one assignment into one LET statement.  They are processed
   in order and may be separated by commas or spaces.
   DATA PROGRAMMING LANGUAGE                                    Page 8-21
   Revision 4


   Examples:

        LET NAGE EQ AGE+NAGE.

        LET LTYPE 1.

        LET NAME "FRED".

        LET NTYPE EQ 5*35.

        LET N1 1, N2 2, N3 = 0, N4 0  N5 EQ 0.



   8.12.3  ACCEPT Command

   The ACCEPT command  reads  values  from  the  user's  terminal.   This
   command  is  most  often  used  in  PL1022 programs, but it is also an
   interactive command, for example in command files.  The command is:

        ACCEPT [ON ERROR <label>] <variable> [<variable>] ...

   The ON ERROR clause is used only in  PL1022  programs.   It  transfers
   control  to the labeled statement if invalid data is read, for example
   text for an integer variable.  Without an ON ERROR clause, 1022  types
   an error message, and the user retypes the input line.

   The data is typed in free  format.   Each  value  is  separated  by  a
   delimiter  from  the  next value, and a carriage return ends the line.
   Any variables remaining to be read are set to zero or blanks.

   The default  delimiter  is  the  comma  (,).   The  user  specifies  a
   different  delimiter with the system variable SYSDELIM.  The new value
   of SYSDELIM must be a single character, type TEXT.

   Examples:

        * DEFINE DATE D REAL R TEXT 10 T INTEGER I        _
        * ACCEPT D R T I        _
        1/12/75,3.75,ABCD,42      ! User types this
        * PRINT D R T I        _
         1/12/1975  3.7500000 ABCD       42         _________  _________ ____       __
        * ACCEPT SYSPAGE I        _
        22                        ! User types this
        * PRINT SYSPAGE I        _
        22 0        __ _
        * LET SYSDELIM "$"        _
        * ACCEPT D R T I        _
        3/12/76$2.9$A, B, $24     ! User types this
        * PRINT D R T I        _
         3/12/1976  2.9000000 A, B,      24         _________  _________ __ __      __

   DATA PROGRAMMING LANGUAGE                                    Page 8-22
   Revision 4


   8.12.4  EVALUATE Command

   The EVALUATE command forms and stores the value of an expression  that
   contains  Totals  functions.   It  is  evaluated  using  all currently
   selected records.  This is similar to what happens in the Totals  list
   of a PRINT command, except that the values are stored instead of being
   printed.  The form of the command is:

        EVALUATE <variable> {[EQ]} <expression>        __
                            {[= ]}

            [[,] <variable> {[EQ]} <expression> ] ...
                            {[= ]}


   Example:

        EVALUATE NTOT EQ (TOT AGE)+1, NUM EQ TOT 1

        This forms the sum of all AGE fields in  the  currently  selected
        records,  and  stores  this  sum  plus  1 into the variable NTOT.
        Next, it stores the number of records into the variable NUM.


   If  a  variable  to  be  stored  is  not  previously  defined,  it  is
   automatically  defined  as  the  default  type  according to its first
   letter and then assigned a value by the command.  Since  this  command
   causes every selected record to be retrieved, the user should group as
   many clauses as needed into one EVALUATE command.  This evaluates  all
   of the expressions in one pass through the records.




   8.12.5  CLEAR Command

   Variables that the user defines in interactive mode are  available  to
   PL1022  programs  and  interactive  commands that follow.  The same is
   true of variables that are defined in PL1022 programs.   They  do  not
   disappear  when  the  PL1022  program ends its execution.  They remain
   defined and have  their  most  recent  values  when  interactive  mode
   resumes.   (Again,  variables  defined in a precompiled PL1022 program
   that do not match any existing variables  at  execution  time  are  an
   exception  to  this  rule.   Such  variables are treated as temporary,
   disappearing after execution of the program [see "COMPILE and PERFORM"
   below].)

   To start again, erase the previously defined variables with the  CLEAR
   command:

        CLEAR

   This is the only form of the command.   After  a  CLEAR  command,  all
   DATA PROGRAMMING LANGUAGE                                    Page 8-23
   Revision 4


   definition  tables  are  cleared,  and  no user-defined variable names
   exist within 1022.

   The user can only clear all variables at once.  It is not possible  to
   selectively  redefine  or clear individual variable names.  Because of
   this, the CLEAR command may not be used within a PL1022 program.



   8.12.6  Assignments Using The EQ Clause

   A PRINT command using a Totals list generates and  prints  expressions
   that  the  user may wish to use later.  One possible way to do this is
   to evaluate the expression values with the  EVALUATE  command  and  to
   place  them into the assigned variables.  A simpler and more efficient
   way to do this is to assign the variables directly in the  print  list
   by inserting the clause:

        <variable> {EQ}
                   {= }

   in front of any print list expression to be stored.  The variable name
   must already be defined to 1022.  The expression value is converted to
   match the variable if necessary.  Only one "<variable> EQ" clause  may
   be  used  for each expression in the print list.  This may be done for
   any expression in the PRINT command, not limited to the  Totals  list.
   This  method  is  more efficient because the records are only accessed
   once, instead of twice with separate EVALUATE and PRINT commands.

   Example:

        PRINT FNAME LNAME AGE SALARY STOT EQ TOT SALARY NTOT EQ TOT 1.

        The main list is LNAME AGE SALARY, and the  Totals  list  is
        TOT SALARY  TOT 1.   After  execution,  STOT  and  NTOT, two
        previously defined variables, are assigned as indicated.



   8.12.7  Variables In 1022 Commands

   Variables may be used in place of  numeric  or  text  values  in  1022
   commands  such as FIND.  They may appear in any command position which
   takes a general arithmetic expression.  For example:

        FIND AGE LT (RETAGE + 5)
        CHANGE SALARY (MAXSAL + .1*BONUS)
        ADD SALARY MAXSAL BONUS MAXBONUS
        PRINT MAXSAL MAXBONUS (MAXSAL+MAXBONUS)

        Parentheses appear around expressions for clarity but are
        not required.
   DATA PROGRAMMING LANGUAGE                                    Page 8-24
   Revision 4


   Use care when assigning names  to  variables.   Whenever  an  unquoted
   value  is  read  by  1022,  a  match  is made against the names of the
   existing variables.  The value of the variable is used, instead of the
   literal,  if  the  variable exists.  Confusion results when a variable
   has the same name as a common data value in a data set.  For  example,
   the command:

        CHANGE NAME NEWNAME

   is interpreted as

        CHANGE NAME "NEWNAME"

   unless a text variable or attribute named  NEWNAME  is  defined.   The
   value  contained  in  NEWNAME  is used in the CHANGE when NEWNAME is a
   text variable.



   8.13  COMMAND FILES IN PL1022 PROGRAMS

   Command files may be used in PL1022 programs and invoked with the  USE
   command  (See Chapter 2, Command Files), or the "@" construction.  The
   command files must exist when the PL1022  START  command  is  scanned.
   Files  produced by the PL1022 program cannot be invoked as commands in
   the same program but may be used in later PL1022 programs in the  same
   command   file.    The  PL1022  program  is  completely  compiled  and
   determined before it begins execution, and so it cannot be altered  by
   a result it produces.

   Example:

        OPEN PERSON. FIND ALL.
        PL1022 START.
            .
        PRINT ON FILE2 FMT "CHANGE AGE NEWAGE." END.
        RELEASE.
            .
            .
        USE FILE1.
            .
            .
            .
        PL1022 END.

        In this example, FILE1.DMC must exist before the PL1022 START  is
        scanned.   Its  contents  become  part  of the text of the PL1022
        program.  The command USE FILE2 would be  incorrect  anywhere  in
        this  program  if intended to read the line produced by the PRINT
        statement, but would work after the PL1022 END.
   DATA PROGRAMMING LANGUAGE                                    Page 8-25
   Revision 4


   8.14  NESTED PL1022 PROGRAMS

   PL1022 programs may contain many levels  of  nested  PL1022  START  --
   PL1022 END pairs.  The range of the PL1022 program starts on the first
   PL1022 START and ends on  its  matching  PL1022  END  statement.   The
   internal  PL1022 START and PL1022 END statements have no effect on the
   operation of the program.  PL1022  pairs  may  also  exist  completely
   inside or around a report program.

   These nesting features allow the user to include any uncompiled PL1022
   program  inside  another  program  (by  USE or @) without removing any
   PL1022 START and PL1022 END statements.  However, the resulting PL1022
   program  is treated as one large text.  No block structure is implied,
   and variable names must be unambiguous among the programs.



   8.15  MULTIPLE DATA SETS

   This section is a guide to using the multiple  data  set  features  of
   System  1022.   Detailed  information necessary to correctly use these
   features is contained in the descriptions of  the  commands  mentioned
   here.

   The user opens many data sets at once when  they  will  be  referenced
   repeatedly.   The  identity  and  condition  of  each  data set remain
   separate, and they are manipulated separately.  The most common way to
   open many data sets is:

        OPEN PARENT CHILD REMARK

   or a similar command.  This command connects 1022 to  all  three  data
   sets  at  the same time.  Or, many data sets may exist in one physical
   file.  Opening that file by name automatically opens all the data sets
   contained in it.

   At any time, one of the open data sets  is  the  "current"  data  set.
   1022  looks  at  the  current  data  set  first  when  deciding how to
   interpret a command.  Most commands act only on or within the  current
   data set.

   The user obtains information about the data  sets  that  are  open  or
   current with the following commands:

        INFORM SET   Prints name and set number of current data set.
        INFORM BASE  Prints the names and numbers of all open data sets.

   The user controls which data set is current with  the  DBSET  command.
   (See  Chapter 4, DBSET Command and the DBSET section below.) Switching
   between data  sets  with  DBSET  takes  almost  no  time  or  computer
   resources;  the data sets are functionally available at the same time.

   Most commands operate on one data set at a time.   Working  with  many
   DATA PROGRAMMING LANGUAGE                                    Page 8-26
   Revision 4


   data  sets  means  deriving data from one data set and then using this
   data  to  query  or  modify  another  one.   Or,  it  means   deriving
   information  from  many  data  sets  for  use  in  a report.  The user
   satisfies the data retrieval requirements of a job  by  querying  each
   data set and saving intermediate results, or by printing data directly
   from the data sets.

   The mechanics of processing many related data sets are  made  easy  by
   the  independence  of the data sets.  The condition of one data set is
   not changed by any actions or queries in another one.

   The user may have selected a group  of  records  in  data  set  A  and
   pointed  to  the third record of that group.  After a DBSET to another
   data set, and the eventual return to data set A,  the  same  group  of
   records  remains selected, with the pointer to the third record of the
   group.  By using the GETREC command to move  through  the  records  in
   sequence,  a  selected group of records in one data set may be used to
   drive a loop that investigates other data sets for each  record.   See
   the example in the "Using The MAP Command" section below.


   The same data set may be opened more than once at the same time.  This
   gives  multiple  views, all maintained separately.  You can map from a
   data set to itself in either of two ways.  The recommended  method  is
   to assign an alias to the data set each time it is opened and then map
   by alias.  Another method is to map by data set number.



   8.15.1  Alternate Data Set Reference

   Often, a  user  wishes  to  print  or  extract  information  from  the
   currently  selected  records  in  more  than one data set.  The PRINT,
   TYPE, LET, and EVALUATE commands can directly reference attributes  in
   data  sets  other  than  the current one.  This is called an alternate
   data set reference.  When an attribute name in one of  these  commands
   does  not  match any attribute in the current data set, then the other
   open data sets qualify in turn to provide a  match.   If  a  match  is
   found  in only one of the other open data sets, the matching attribute
   of that other data set provides the value.  If a  match  is  found  in
   more  than  one  of the other open data sets, either of two things can
   happen, depending on the setting of the  system  variable  SYSAMBATTR.
   If  SYSAMBATTR  is set to 0, which is the default, 1022 gives an error
   message

        (CS175) Ambiguous attribute name

   and no value is provided.  If SYSAMBATTR is set  to  1,  the  matching
   attribute in the first (lowest numbered) data set provides the value.

   This feature does not automatically select records in other data sets.
   It  uses the values of the currently selected record in the other data
   set.  The related record in an auxiliary data set is selected  by  the
   DATA PROGRAMMING LANGUAGE                                    Page 8-27
   Revision 4


   user,  allowing a PRINT command to reference both the original data in
   the current data set and the auxiliary data.

   If more than one record is selected in the alternate  data  set,  only
   the  value from the first record is used.  If no record is selected, a
   null value is used.



   8.15.2  DBSET Statement

   A PL1022 program may operate with many  open  data  sets.   The  DBSET
   command  chooses  which data set is the current one.  It operates in a
   PL1022 program just like the interactive DBSET command.

   It is important to access the proper data set.  All 1022 commands look
   first  to  the current data set to satisfy the attribute references of
   the PL1022 program.  These references become an internal part  of  the
   command  when  1022  reads  the  command.  Although some commands like
   PRINT may directly refer  to  attributes  in  other  data  sets,  most
   commands  affect  only the current data set (like ADD, CHANGE, DELETE,
   and DROP).

   The current data set is defined by the commands OPEN, DBSET, and  MAP.
   The  current  data  set  does not change from that point onward in the
   PL1022 program, unless another such command appears.  The current data
   set  for any command is determined at compilation, when the program is
   read into 1022.

   In PL1022 programs the current data set at any point is  the  same  at
   both  compilation  and runtime execution.  To insure this consistency,
   PL1022 executes implicit DBSET commands  at  the  end  of  conditional
   commands  and  blocks, at labels, and before each execution of a loop.
   Statements do not execute  in  the  wrong  data  set  because  control
   transfers from another section of the PL1022 program.



   8.15.2.1  Implicit DBSET At Labels

   PL1022 requires that the current data set be the  correct  one.   When
   control  passes  to a labeled statement, the current data set is reset
   to the one in effect for that statement when it was compiled.

   DATA PROGRAMMING LANGUAGE                                    Page 8-28
   Revision 4


   Example:

                  OPEN PARENT CHILD.

                  PL1022 START.
                  FIND ALL.
                  SORT BY LAST_NAME FIRST_NAME.
        LOOP:     GETREC THEEND.             !PARENT is current data set.
                  MAP TO CHILD VIA PARENT_ID.!CHILD is current data set.
                  PRINT FIRSTNAME AGE.
                  GOTO LOOP.

        THEEND:    PL1022 END.

        The OPEN command establishes PARENT as the current data set.  The
        FIND  ALL  command  executes  in  PARENT,  as  does the following
        GETREC.  The MAP starts in PARENT and ends in the CHILD data set,
        producing  a  group of related records.  After the MAP and PRINT,
        control is transferred to LOOP, to select another PARENT  record.
        The  current  data  set established for the GETREC at LOOP is the
        PARENT data set.  The runtime system automatically  reestablishes
        PARENT  as the current data set, even though the current data set
        was CHILD at the time of the GOTO command.




   8.15.2.2  Implicit DBSET In Structured Blocks

   The current data set is the same at  the  beginning  and  end  of  any
   conditional  command or block.  Implicit DBSET commands execute at the
   beginning and end of every conditional command  and  block  to  insure
   this.

   A command like "IF A EQ B DBSET 2" has no effect.  At the end of  this
   IF command the current data set is reset to be the same as the current
   data set at the beginning of the command.

   The current data set remains the same at the beginning  of  each  pass
   through  a loop and the same for each Boolean expression in a compound
   IF statement.  PL1022 performs an  implicit  DBSET  at  each  possible
   entry point and on exit to maintain this consistency.

   Example:

        DBSET 1.
        IF A EQ B THEN
           DBSET 2.
           LET J=SALARY.   !J comes from data set 2
        ENDIF.
        LET K=SALARY.      !K comes from data set 1

        PL1022 executes an implicit DBSET 1 at the end of the IF block.
   DATA PROGRAMMING LANGUAGE                                    Page 8-29
   Revision 4


   In a compound IF statement, PL1022 executes an implicit  DBSET  before
   each Boolean expression is evaluated and at the beginning of each ELSE
   block.

   Example:

        DBSET 1.
        IF A EQ B THEN
           PRINT A.
           DBSET 2.
           PRINT ATTRIBUTE_SET_2. !in set 2
        ELSEIF A EQ C THEN        !implied DBSET 1 before Boolean
                                  !is evaluated
           PRINT C.
           DBSET 2.
           PRINT ATTRIBUTE_SET_2. !in set 2
        ELSE                      !implied DBSET 1
           PRINT B.
        ENDIF.                    !implied DBSET 1


        PL1022 executes an implicit DBSET 1 (set  1  is  current  at  the
        beginning  of  the  IF  block)  at  the  ELSEIF,  ELSE, and ENDIF
        commands.  It would do the same at an END command.

   Example:

        DBSET 1.
        WHILE J LT 10 AND A EQ B DO !evaluated in set 1
           PRINT J A B.
           LET J=J+1.
           DBSET 2.
           PRINT ATTRIBUTE_SET_2.   !in set 2
        ENDWHILE.                   !implicit DBSET 1


        PL1022 executes an implicit DBSET 1 before evaluating the Boolean
        expressions  in  the  WHILE  statement  each  time  control flows
        through the loop, and it executes an implicit  DBSET  1  when  it
        exits the block at ENDWHILE (or END).

   The REPEAT UNTIL statement performs similar  implicit  DBSET  commands
   before testing the Boolean expression and on exit.

   When control passes from a block using  a  LEAVE  command,  a  similar
   implicit  DBSET  reestablishes the set from the beginning of the block
   as current.
   DATA PROGRAMMING LANGUAGE                                    Page 8-30
   Revision 4


   8.15.3  MAP Command In PL1022 Programs

   The MAP command works like FIND to locate records in other  data  sets
   that are related to a current record or group of records.  A MAP takes
   the list of values for a given attribute, one value  for  each  record
   currently  selected,  and uses this list to select matching records in
   another data set.  The process ends with an automatic  DBSET  to  that
   other data set.

   In a common case, a MAP is done from one record into a data  set  that
   holds  the  text  translations  for a numeric tag field.  Even after a
   DBSET back to the original data set, the text description is available
   to a PRINT command by alternate data set reference.

   All data sets needed in the execution of a PL1022 program must be open
   before  starting  it.   Then, a DBSET command defines the current data
   set until it is changed by another DBSET or by  a  MAP  command.   All
   statements  in  the program are interpreted in accord with the current
   data set, and other data sets are treated as external to  the  current
   one.

   As an example of multiple data set operation, consider  the  following
   data sets:

   CUST    A data set of customer header records.  These records  contain
           the IDNUM (customer number) and other information about credit
           rating and salesman (which are not used in this example).

   CUSNAM  This data set holds CNAME (the full customer  name)  which  is
           not  stored  in the CUST data set.  The link to CUST is by the
           IDNUM.

   AMOUNT  Holds one record for each invoice processed for  the  customer
           this  year.  The attribute we look at is BILLAMT, which is the
           total dollars for that invoice.  The link to CUST is IDNUM.

   The following sample program shows how the features of  multiple  data
   sets are used to access information from all the above data sets.  The
   program uses the CUST data set as a base for retrieving each  customer
   name  and  calculating the total dollars for invoices processed so far
   this year.


   Example:

        OPEN CUST AMOUNT CUSNAM.
        PL1022 START.

        DBSET CUST. FIND ALL.        !Locate all CUST records
                                     !for processing.

        REPEAT
   DATA PROGRAMMING LANGUAGE                                    Page 8-31
   Revision 4


           GETREC LEAVE.             !Next customer record.

           MAP TO CUSNAM VIA IDNUM.  !Find the associated customer name
                                     !record based on ID NUMBER.

           MAP TO AMOUNT VIA IDNUM.  !Find the associated AMOUNT
                                     !records based on ID NUMBER.

           PRINT IDNUM CNAME TOT BILLAMT.
                                     !Print the customer id number,
                                     !the customer name (from CUSNAM),
                                     !and the total derived from AMOUNT.

        UNTIL 1=2.                   !Repeat until out of records.

        PRINT "** LIST DONE **".     !End of list message.

        PL1022 END.


   The GETREC command selects the first of the customer records.  The MAP
   to  CUSNAM  finds  the  name  of the customer (in the CUSNAM data set)
   associated with the record.  The MAP to AMOUNT finds  (in  the  AMOUNT
   data  set)  all  the records associated with the one selected customer
   record.

   AMOUNT is then the current data set, but the  PRINT  command,  through
   alternate  data set reference, prints attribute values from all of the
   open data sets.  The  PRINT  command  prints  the  IDNUM  from  AMOUNT
   (identical  in  all  three  data  sets),  CNAME from CUSNAM, and total
   BILLAMT from AMOUNT.  The TOT function provides  a  total  of  BILLAMT
   values for all the selected records in AMOUNT.

   At UNTIL, control returns to the beginning of the REPEAT block.   This
   happens  unconditionally because 1 never equals 2.  The process starts
   over again for the  next  customer  record  selected  by  the  GETREC,
   repeating  until GETREC runs out of CUST records.  Then control passes
   to the end of the REPEAT block, and the program  ends  by  printing  a
   final message.

   Each time control returns  to  REPEAT,  1022  automatically  sets  the
   current  data  set to be CUST, the current data set at the position of
   the REPEAT command.



   8.15.4  OPEN In PL1022 Programs

   The OPEN command accesses one or more data sets.  It  establishes  the
   record  structures, data types, and attribute names which the user may
   specify in commands.  The user must open a data set before  using  the
   commands that work with the data set.
   DATA PROGRAMMING LANGUAGE                                    Page 8-32
   Revision 4


   All the commands in a PL1022 program are read at  one  time,  and  are
   compiled  before  any action occurs within the program.  All data sets
   used in the PL1022 program must be present for 1022 to  interpret  the
   command  references  to  those data sets.  Thus, OPEN commands precede
   PL1022 programs and are not usually included in them.   The  following
   describes  the  circumstances  in which OPEN commands are allowed in a
   PL1022 program.  The discussion is restricted to PL1022 programs  that
   are  not  to  be  precompiled,  since  no OPEN commands are allowed in
   precompiled PL1022 programs (see "COMPILE and PERFORM" below).

   The user cannot  open  data  sets  with  different  structures  during
   program  execution  because System 1022 translates the program into an
   internal  form  and  does  not  re-translate  each  statement   during
   execution.  Such an OPEN results in unpredictable run time errors.

   However, the user can replace an open data set by opening another  one
   of  the  same  structure.   Since bundled and unbundled data sets have
   different structures, the open data set (template) and its replacement
   must  both  be bundled or both be unbundled.  The replacement data set
   is chosen at execution time  within  the  following  limits.   Open  a
   template  data set before entering the PL1022 program to establish the
   data set structure.  Then, parts of the PL1022 program may use OPEN to
   process  a replacement data set with the same structure, after closing
   the template data set with the CLOSE command.

   It is important to pair each CLOSE command with an OPEN  command  that
   opens  a  data set of the same structure as the one just closed on the
   same channel to ensure that the DBSET commands and  labels  associated
   with  particular data set structures on particular channels at compile
   time remain so at run time.  Otherwise, run time errors will occur.

   The new data set takes its place in line  with  the  other  open  data
   sets,  at  the  same  position  as  the template data set.  The PL1022
   statements which were compiled to  access  the  template  will  access
   instead the new data set.

   A restriction is built into any OPEN executed in a PL1022  program  to
   maintain  data  set  security.  The user must have the same, or freer,
   access privileges to the  new  data  set  as  were  available  in  the
   template  data  set.   This  must  be  true  for all attributes in the
   template data set, whether or not they are referenced.  This  prevents
   building  a  PL1022 program with a private template data set, and then
   using the program to access protected data sets.  Below is an  example
   which  uses this feature to select between two data sets at runtime in
   a PL1022 program.

   Example:

                  OPEN TPLATE TRANSL.
                  DEFINE TEXT 1 CHOICE. DEFINE INTEGER USERID.
                  PL1022 START.
        LOOP1:    PRINT FMT "ENTER N(NEW) OR A(ARCHIVE) -<RET>
                     OR Q(QUIT): " $  END.
   DATA PROGRAMMING LANGUAGE                                    Page 8-33
   Revision 4


                  ACCEPT CHOICE.
                  IF CHOICE EQ "Q" THEN ENDIT.
                  IF CHOICE EQ "N" THEN CN.
                  IF CHOICE EQ "A" THEN CA.
                  PRINT "INCORRECT ENTRY, TRY AGAIN".
                     GOTO LOOP1.

        CN:       DBSET TPLATE. CLOSE. OPEN NOCLOSE NEWDAT.
                     GOTO NEXT.

        CA:       DBSET TPLATE. CLOSE. OPEN NOCLOSE OLDDAT.

        NEXT:     PRINT FMT "ENTER USER NUMBER: " $ END.
                  ACCEPT USERID.
                  FIND ID EQ USERID.
                  IF SYSNREC NE 0 THEN OK1.
                  PRINT "NO USER BY THAT USER ID". GOTO LOOP1.

        OK1:      MAP TO TRANSL VIA UCODE.

                  PRINT ID FN LN CODENAME
                     FMT I6 X A10 X A12 2X A20 / END.

                  GOTO LOOP1.
        ENDIT:    PL1022 END.

   TPLATE is a template data set with the following structure:

        ATTRIBUTE ID INTEGER KEYED LENGTH 6 RANGE 0 999999
        ATTRIBUTE FN TEXT LENGTH 10
        ATTRIBUTE LN TEXT LENGTH 12
        ATTRIBUTE UCODE INTEGER LENGTH 4 RANGE 0 1000

        ID is a keyed identification number.
        FN and LN are the first and last names for the person.
        UCODE is a number which indicates the profession of the person.

   TRANSL is the data set which translates the profession codes into  the
   names of the professions.  It has the structure:

        ATTRIBUTE UCODE INTEGER LENGTH 4 KEYED RANGE 0 1000
        ATTRIBUTE CODENAME TEXT LENGTH 20

   This example program starts by asking which of two data sets  will  be
   used  to  satisfy  the  inquiry.  The data set NEWDAT.DMS contains the
   current data, and the data set OLDDAT.DMS contains the  archive  data.
   Statements  at label CN or CA choose the proper data set after closing
   the template data set or the previously open data set  from  the  last
   question.  The new data set is opened at the same data set position as
   the previous one providing that the user has  followed  the  procedure
   for opening and closing data sets in a program described above.

   Thereafter, the PL1022 program is constructed in a  normal  way.   The
   DATA PROGRAMMING LANGUAGE                                    Page 8-34
   Revision 4


   program  prints  a message if no user with that id number exists.  The
   MAP to the TRANSL data set looks  up  the  text  translation  for  the
   profession  code  stored  in NEWDAT or OLDDAT as the case may be.  The
   command PRINT ID FN LN CODENAME displays the  found  information  from
   TPLATE  by alternate data set reference and from TRANSL.  Then control
   returns to the initial question.

   By writing the PL1022 program this way, no initialization time is lost
   reading the PL1022 procedure again for each data set access;  only the
   time needed to open the data set is used.
|  
|  
|  
|  8.16  DEBUGGING PL1022 PROGRAMS
|  
|  There is a special  set  of  commands  for  use  in  debugging  PL1022
|  programs.   These  commands  are  similar to the ACCEPT, BREAK, CLEAR,
|  NEXT, PROCEED, STOP, TRACE ON, and TRACE OFF commands of COBDDT.  They
|  may  be  used  to  debug  a  PL1022  program that you will be entering
|  interactively or have written to a file.
|  
|  To use these tools, enter the command PL DEBUG in place of  PL  START.
|  At execution time, the debugging prompt will appear:
|  
|       1022DDT>
|  
|  You may then enter any of the following commands:
|  
|           HELP -- Displays a brief  summary  of  the  PL1022  debugging
|           commands.
|  
|           BREAK <label> -- Sets a breakpoint at the specified label  in
|           the  program.  There is no limit on the number of breakpoints
|           that may be set in a series of BREAK commands.
|  
|           CLEAR <label> --  Clears  the  breakpoint  at  the  specified
|           label.   If  no  label  is  specified,  all  breakpoints  are
|           cleared.
|  
|           DISPLAY <item> -- Displays the contents of the specified user
|           variable,  system  variable, or attribute of the current data
|           set.  The PL1022 DISPLAY command does not accept wildcards or
|           ranges as part of an argument.
|  
|           ACCEPT <item>  <RET>  <value>  --  Assigns  a  value  to  the
|           specified user variable or system variable.
|  
|           PROCEED <n> -- Continues execution  of  the  program,  either
|           until  completion,  until the nth occurrence of the preceding
|           breakpoint is reached, or  until  some  other  breakpoint  is
|           reached,  whichever happens first.  If no numeric argument is
|           given, the default is 1.
   DATA PROGRAMMING LANGUAGE                                    Page 8-35
   Revision 4


|           NEXT <n> -- Continues execution of the program, either  until
|           completion,  until  the  next  n  labels have been passed, or
|           until a breakpoint is reached, whichever happens  first.   If
|           no numeric argument is given, the default is 1.
|  
|           TRACE ON -- Displays all labels as they are encountered.
|  
|           TRACE OFF -- Stops displaying labels as they are encountered.
|  
|           STOP -- Terminates execution of the  program,  returning  the
|           user to the 1022 prompt.
|  



   8.17  COMPILE AND PERFORM

   The COMPILE command  allows  the  user  to  compile  and  save  PL1022
   routines  and  report  programs  in  disk  files for future execution,
   thereby avoiding recompilation  prior  to  each  run.   Such  compiled
   procedures are executed with the PERFORM command.

   The following describes the requirements for a compiled procedure  and
   defines the environment in which a compiled procedure may be executed.



   8.17.1  The COMPILE Command

   The syntax of the COMPILE command is:

             COMPILE [FROM] source-file [ [TO] compiled-file ]

   where:

   source-file    Is a disk file containing a PL1022 or  report  program.
                  The  default  structure  for  this file is DSK: and its
|                 default extension is DMA.  If  no  appropriately  named
|                 DMA  file  exists, 1022 then looks for an appropriately
|                 named file with the extension DMC.

   compiled-file  Is the output file  containing  the  compiled  program.
                  The  default  structure  for  this  file  is  DSK:, its
                  default extension is DMX, and its default name is  that
                  of the source-file.

   A source file must meet the following requirements:

             (1) It must be a disk file: COMPILE does not work on  PL1022
             programs   that  have  been  entered  interactively  at  the
             terminal.

             (2) After any  opening  comments,  the  first  statement  or
   DATA PROGRAMMING LANGUAGE                                    Page 8-36
   Revision 4


             command in the source file must be one of the following:

                       PL1022 START
                       REPORT START
                       WHILE
                       REPEAT
                       IF (with the system variable SYSIFTYPE set to 1)

             If anything else appears at the beginning of  the  file,  an
             error  message is generated and command scanning is aborted,
             regardless of the setting of SET FILERR CONTINUE.

             (3) A source file may contain any  legal  PL1022  or  report
             program commands except OPEN and PERMIT.

             (4) The last element in the source file must be a terminator
             (such  as  PL1022  END, REPORT END, or ENDWHILE) closing the
             segment initiated in  the  program's  opening  statement  or
             command.   (PL  segments and report procedures may be nested
             within each other.)  COMPILE will ignore anything  following
             this terminator in the file.




   8.17.2  The Environment

   At COMPILE time (when the COMPILE command is issued),  information  is
   written  to  the DMX file about the environment in which the procedure
   is compiled.  This information includes:

         o  the attribute structure, attribute protections,  and  bundled
            or  unbundled  status  of  each  data  set  referenced in the
            procedure;

         o  the number of each referenced data set;

         o  the internal and external name of each  referenced  data  set
            (or collection) and any alias under which each was opened;

         o  each referenced JOIN relationship;

         o  the name,  type,  dimension,  and  subscript  range  of  each
            referenced variable;  and

         o  the current version number of System 1022.

   At PERFORM time (when the PERFORM command is issued), System 1022 uses
   this  information  to  compare  the  PERFORM-time  environment  to the
   COMPILE-time environment.  These environments must match in order  for
   PERFORM  to  execute the procedure.  If the environments do not match,
   error messages  are  generated  and  execution  of  the  procedure  is
   suppressed.
   DATA PROGRAMMING LANGUAGE                                    Page 8-37
   Revision 4


   The PERFORM-time environment must match the  COMPILE-time  environment
   in the following ways:

         o  The major version of 1022 must be the same.   Minor  versions
            must be compatible, though they need not be identical.

         o  Each data set referenced at PERFORM time must  match  exactly
            one  data set referenced at COMPILE time.  Matching data sets
            must share  the  same  attribute  structure  and  bundled  or
            unbundled  status.  Access to protected attributes must be at
            least as free at PERFORM time as it was at COMPILE time.

         o  Each variable referenced at PERFORM time must  match  exactly
            one  variable referenced at COMPILE time.  Matching variables
            must share the same name, type,  number  of  dimensions,  and
            subscript ranges.

   Data set matching and the use  of  variables  are  described  in  more
   detail below.



   8.17.2.1  Data Set Matching

   A compiled PL1022 procedure may reference a data set by  its  position
   (data  set  number), by its internal name, by its external name, by an
   alias, or by some combination of these.  Reference to  collections  is
   by  collection  name.   PERFORM  must  find  exactly one data set that
   matches all saved references to that data set.  This means that  if  a
   data  set  is  referenced  by  its  internal  name and an alias in the
   compiled program, there must be exactly one open data  set  with  that
   internal name and alias at PERFORM time.
|  
|  For example, suppose that the user has created a DMA file (A.DMA) that
|  contains the following commands:

             PL1022 START.
             DBSET NEW.
             FIND ALL.
             MAP TO OLD VIA GROSS.
                  .
                  .
                  .
             DBSET ACCREC.FEB.
                  .
                  .
                  .
             PL1022 END.

   The user might then issue the commands:

             OPEN ACCREC.JAN IN ACCREC.DMS AS OLD
                ACCREC.FEB IN ACCREC.DMS AS NEW
   DATA PROGRAMMING LANGUAGE                                    Page 8-38
   Revision 4


|            COMPILE A.DMA

   The first of these commands establishes the COMPILE-time  environment,
   and  the  second  produces  the  compiled  file A.DMX.  To execute the
   procedure contained in A.DMX, the user must first issue the command:

             OPEN X AS OLD
                ACCREC.FEB IN ACCREC.DMS AS NEW

   where X is a  data  set  that  is  compatible  with  ACCREC.JAN.   (If
   ACCREC.JAN  had been referenced in the program by its internal name, X
   would have to  be  ACCREC.JAN.)  ACCREC.FEB  must  be  opened  as  NEW
   because  both  the  internal  name and the alias are referenced in the
   procedure.

   The user may then execute the procedure by issuing the command:

             PERFORM A.DMX

   A compiled PL1022 procedure may also reference data  sets  implicitly.
   Implicit data set references occur under the following circumstances:

         *  An unqualified alternate data set reference is made to a data
            set that is not joined to the current one.

         *  An implicit DBSET occurs.  Implicit DBSET commands  occur  at
            the  beginning of a program, at the beginning of a structured
            command block, at report sections, and at program labels.  In
            addition,  if  the  first  executable command in the compiled
            program is not an explicit DBSET, the  implied  reference  is
            further qualified by the requirement that the referenced data
            set (or collection) must be the current one.

         *  A JOIN relation is referenced, either by an  ENABLE  JOIN  or
            DISABLE  JOIN  command  or  by reference to an attribute in a
            data set that is joined to the current one.


   References to data sets by unqualified alternate data set reference or
   by implicit DBSET are implicitly by data set number.  This means that,
   unless overriding measures are taken, data  sets  must  be  opened  in
   exactly  the  same order at PERFORM time as they were at COMPILE time.
   An implicit reference to a collection is simply treated as an ordinary
   collection  reference.   Collections,  because  they are referenced by
   name, are position-independant.

   An implicit reference by data set number is overridden by the presence
   of  any other type of reference to that data set at any other point in
   the compiled program.

   Users who do not wish to be constrained by  the  defaults  imposed  by
   implicit  data  set references of the three types outlined here should
   be aware of the following methods of overriding the defaults:
   DATA PROGRAMMING LANGUAGE                                    Page 8-39
   Revision 4


         o  Immediately follow the first command in the  program  (PL1022
            START,  REPORT  START, WHILE, REPEAT, IF) with a DBSET to the
            desired data set;

         o  For alternate data set references,  use  the  qualified  form
            (data-set-descriptor.attribute-name);

         o  Use an explicit reference to each data set in the program  at
            some point in the program.

   When a JOIN relation is invoked, the implicit reference is to both  of
   the  joined  data  sets  (or  collections).  The type of reference (by
   number, name, or alias) that is written to the  DMX  file  at  COMPILE
   time is that specified in the original JOIN command.

   For example, suppose that LAST_NAME is an attribute shared by the data
   sets  CENSUS and PHONE, that FIRST_NAME is an attribute of CENSUS, and
   that NUMBER is an attribute of  PHONE.   Suppose  that  the  following
   commands are given:

        OPEN CENSUS AS C PHONE AS P
        JOIN 1 TO P VIA LAST_NAME AS J1

   and that the following file is compiled:

        PL1022 START.
        DBSET C.
        FIND ALL.
        PRINT LAST_NAME FIRST_NAME NUMBER.
        PL1022 END.

   The reference to the attribute NUMBER in the joined data set PHONE (P)
   implies a reference to both data sets.  The reference to CENSUS (C) is
   by data set number, since that was the type of reference used  in  the
   original JOIN command.  The reference to PHONE (P) is by alias for the
   same reason.  The DBSET command explicitly refers to CENSUS (C) by its
   alias.



   8.17.2.2  Variables

   A compiled program may reference variables that are not defined within
   that  program.   Such variables must be defined outside the program at
   PERFORM time in exactly the same way that they were at  COMPILE  time.
   That  is,  they  must  match  by name, type, length (if text), and (if
   arrays) by number of dimensions and subscript ranges.  Variables  need
   not  be  defined  in  the  same  order at PERFORM time as they were at
   COMPILE time.

   Since such variables exist both before and after the compiled  program
   is  executed,  they  may  be  used  both to pass values to and receive
   values from the program.
   DATA PROGRAMMING LANGUAGE                                    Page 8-40
   Revision 4


   Because variables that are explicitly  or  implicitly  defined  during
   compilation  remain  defined after compilation, successive compilation
   of the same program with no intervening CLEAR can  produce  unexpected
|  results.  For example, assume the sample command file SAMPLE.DMA:

        PL1022 START.
        LET I EQ I+1.
        PL1022 END.

   Suppose that the following commands are given:

        CLEAR
|       COMPILE SAMPLE.DMA TO A.DMX
|       COMPILE SAMPLE.DMA TO B.DMX

   The  CLEAR  command  deletes  all  previously  existing   user-defined
   variables.   The first COMPILE command compiles the file, defining the
   variable I implicitly as it does so.  When the file is  recompiled  by
   the  second  COMPILE  command,  the  LET  is taken as a reference to a
   preexisting variable I.  If a subsequent CLEAR command is  given,  the
   command

        PERFORM A.DMX

   will execute successfully, while the command

        PERFORM B.DMX

   will genenerate an error message and execution will be suppressed.

   A variable that is defined  within  a  compiled  program  and  exactly
   matches  a  variable  existing  at  PERFORM  time  is  cleared  before
   execution of the PL1022 code.  Such a variable may  therefore  not  be
   used to pass values to a program but may be used to receive them.

   A variable that is defined within a  compiled  program  and  does  not
   match  any variable existing at PERFORM time is treated as a temporary
   variable that may only be used within the compiled code and is  "lost"
   upon completion of execution of the program.

   If a variable defined within the compiled program matches  a  variable
   existing  at  PERFORM  time in name but not in other all other ways, a
   mismatch error occurs.



   8.17.2.3  Recommended Procedures

   The following are recommended practices in designing  PL1022  programs
   to be compiled by COMPILE and executed by PERFORM:
   DATA PROGRAMMING LANGUAGE                                    Page 8-41
   Revision 4


         o  Override  the  defaults  imposed  by  implicit  reference  by
            referring to each data set and collection explicitly.

         o  Reduce the possibility  of  multiple-match  errors  by  using
            aliases  or  data set numbers wherever possible, as these are
            unique.  If an internal or external data  set  name  must  be
            used, use both (in the form A IN B) for the same reason.

            References to data sets by aliases or data set numbers are to
            be  preferred  because they permit more flexibility as to the
            choice of actual data set used at PERFORM time.  If a program
            refers to a data set solely by data set number, then the only
            PERFORM-time requirement is that there be a  compatible  data
            set  with the same same data set number in the same position.
            This allows a data set other than  the  original  one  to  be
            substituted   at   PERFORM   time.   Reference  by  alias  is
            preferable to reference by data set number because  an  alias
            does not imply data set position.

         o  Refer to a given data set in the same  way  (only  by  alias,
            only  by number, etc.) consistently throughout the code.  The
            environment check runs more quickly when there  is  only  one
            criterion for matching with each referenced data set.

         o  When defining necessary JOIN  relations  before  compilation,
            refer  to the data sets being joined in the same way in which
            they are referenced elsewhere in the program  (by  alias,  by
            number, etc.).

         o  Open only the necessary data sets before executing a  program
            with   the  PERFORM  command.   This  eliminates  unnecessary
            reference checking and increases PERFORM's efficiency.


   In the majority of  cases,  the  most  straightforward  way  to  avoid
   differences  between  COMPILE-time and PERFORM-time environments is to
   use the following standard procedure:

             (1) Create a command file command-file.DMC containing

                   o  the OPEN commands necessary to open  all  the  data
                      sets  to  be  referenced  in  your PL1022 or report
                      program;

                   o  the PERMIT  commands  necessary  to  give  you  the
                      appropriate   degree   of   access   to   protected
                      attributes referenced  in  your  PL1022  or  report
                      program;

                   o  whatever other commands (such as JOIN  or  COLLECT)
                      that  are necessary for the successful execution of
                      your program but are not legal within a  PL1022  or
                      report program proper;
   DATA PROGRAMMING LANGUAGE                                    Page 8-42
   Revision 4


                   o  the commands defining any variables  that  will  be
                      referenced  (but  not  otherwise  defined)  in your
                      program;
|  
|                  o  the command COMPILE source-file.DMC;

                   o  commands (such as  RELEASE  and  TYPE)  that  would
                      ordinarily  follow  PL1022  END or REPORT END.  You
                      may wish to "comment out" these commands  until  it
                      is time to execute your compiled program.

|  
|            (2) Create a source file source-file.DMA.  This file  should
|            contain your program

             (3) Run 1022 and issue the command

                  USE command-file.DMC

             to   produce   the   compiled   program    in    the    file
             compiled-file.DMX in its proper environment.

             (4) Edit command-file.DMC,  replacing  the  COMPILE  command
             with the command

                            PERFORM compiled-file.DMX

             and  restoring  any  end  commands   that   you   previously
             "commented out."

             (5) To run the program whose environment  was  specified  in
             step  (1),  whose  PL1022  or report program commands proper
             were specified in  step  (2),  and  whose  source  file  was
             compiled in step (3), issue the command

                  USE command-file.DMC



   8.17.3  The PERFORM Command

   The syntax of the PERFORM command is:

             PERFORM compiled-file

   where:

   compiled-file  Is the output of a COMPILE command,  that  is,  a  file
                  containing  a  compiled  PL1022 or report program.  The
                  default for this file is DSK:<filename>.DMX.

   Before executing the compiled program, PERFORM checks the  environment
   to make sure that the following conditions have been met:
   DATA PROGRAMMING LANGUAGE                                    Page 8-43
   Revision 4


         o  all data sets and collections  that  are  referenced  in  the
            program  are open and are compatible with those referenced at
            COMPILE time, and access to protected attributes is at  least
            as free as it was at COMPILE time;

         o  any variables referenced in the program that are not  defined
            within  the program itself exist and are defined the same way
            they were at COMPILE time;

         o  the major  version  of  1022  under  which  the  program  was
            compiled is the same as that under which the program is to be
            executed, and no change between minor versions has been  such
            as to introduce significant incompatibilities.


   If any of these conditions have not been met,  a  warning  message  is
   typed  to the user's terminal followed by a standard System 1022 error
   message, and execution of the program is suppressed.

   If no errors or inconsistencies are found, the PERFORM  command  takes
   certain other initializing actions.  These include the following:

         o  If there are any JOIN references in the compiled program,

            1.  all JOIN relations established just before  PERFORM  time
                are invalidated;

            2.  all JOIN relations that existed at COMPILE time and  were
                invoked  in  the  compiled  program  are  established and
                remain  in  effect  until  the   program   has   finished
                executing.   At that time, all pre-PERFORM JOIN relations
                are restored, subject to the following condition:

                when a CLOSE command applies within the program to a data
                set or collection, all JOIN relations involving that data
                set or collection are cleared.


         o  SELECT  conditions  are  cleared  in  all   data   sets   and
            collections  referenced  by  the program at PERFORM time.  An
            informational message of the form

                      (Clearing SELECT conditions for d/s #: n)

            appears at the terminal when the SELECT conditions for a data
            set  are  cleared.  Thus, SELECT commands that are to be used
            during the execution of the program should  be  given  within
            the   compiled   program   itself.    Any  SELECT  conditions
            established during the course of  the  program  are  likewise
            cleared   when   the   program  finishes  execution.   SELECT
            conditions for  other  data  sets  and  collections  are  not
            cleared.
   DATA PROGRAMMING LANGUAGE                                    Page 8-44
   Revision 4


         o  In a report program, each HEADING and FOOTING established  on
            an active PRINT channel is cleared, regardless of the setting
            of SYSREPMODE.  Thus, any  HEADING  or  FOOTING  to  be  used
            during  the  execution  of  the  program  should be specified
            within the compiled program itself.  Any HEADING  or  FOOTING
            established  during  the  course  of  the program is likewise
            cleared   when   the   program   finishes   execution.     An
            informational message of the form

                      (Clearing HEADING (FOOTING) on print channel n)

            appears at  the  terminal  when  each  HEADING  (FOOTING)  is
            cleared.




   8.17.4  Error Handling

   When System 1022 detects  errors  during  a  PERFORM-time  environment
   check,  either  of  two types of error message are typed to the user's
   terminal, depending on the nature of the errors.  If an error involves
   a mismatch between COMPILE-time and PERFORM-time data sets, variables,
   or versions of System 1022, a warning message appears:

        %Errors encountered -- see error file <filename.DMF>

   where <filename.DMF> is the error file produced when  mismatch  errors
   are discovered during the operation of the PERFORM command on the file
   <filename.DMX>.  This warning is followed by a  standard  System  1022
   error message.

   Other types of PERFORM-time error (such as "out of core" or "file  not
   found")  generate  a standard System error message and are not written
   to an error file.

   A DMF error file contains the following information:

        1.  The file descriptor of the source file  from  which  the  DMX
            file was compiled;

        2.  The COMPILE-time version of System 1022;

        3.  Diagnostic messages concerning variable mismatching, if any;

        4.  Diagnostic messages concerning data set mismatching, if any.

|  
|  For example, suppose a DMA file SAMPLE.DMA consisting of the following
|  commands:

        PL1022 START.
        DBSET NEW.
   DATA PROGRAMMING LANGUAGE                                    Page 8-45
   Revision 4


        FIND ALL.
        PL1022 END.

   In the sample session below, the data set BLOOD in BLOOD.DMS is opened
|  under  the  alias  NEW  and  SAMPLE.DMA is then compiled.  The command
   DBSET NEW is treated as a reference to the target data set  by  alias.
   After  compilation,  the  user  opens BLOOD in BLOOD.DMS but omits the
   alias by which it was  referenced  at  COMPILE  time.   The  resultant
   PERFORM error is then recorded in the error file SAMPLE.DMF:

        OPEN BLOOD IN BLOOD.DMS AS NEW
        COMPILE SAMPLE
             .
             .
             .
        OPEN BLOOD IN BLOOD.DMS
        PERFORM SAMPLE
|  
|  If SAMPLE.DMA was created under version 116B(75) of System 1022 by the
|  user whose user name is <JONES>, SAMPLE.DMF will read:
|  
|     Source file: PS:<JONES>SAMPLE.DMA
      Compiled under System 1022 116B(75)

      %ERRORS ENCOUNTERED CHECKING DATASET DESCRIPTOR BLOCK # 1
      No dataset was found with the required alias: NEW

        **** Saved Dataset Description ****

        Dataset position (at compile-time): 1
        Internal name: BLOOD
        External name: BLOOD.DMS
        Alias: NEW (required)

   In the case of version skew, the only information that appears in  the
   error  file  is  the specification for the source file and the version
   under which it was compiled.

   The following are the diagnostic error messages that may appear  in  a
   DMF error file:

   %ERRORS ENCOUNTERED CHECKING DATASET DESCRIPTOR BLOCK # n
   This message can appear under any of the following circumstances:

         o  the referenced data set (collection) is not found;

         o  the referenced data set (collection) is not the current one;

         o  there is a multiple match error (when more than one data  set
            matches the reference);
   DATA PROGRAMMING LANGUAGE                                    Page 8-46
   Revision 4


         o  there is a matching conflict error (when a data set is  found
            that matches some but not all of the reference requirements);

         o  reference is made by data set number to a data set  that  was
            uncollected  at  COMPILE  time but is part of a collection at
            PERFORM time;

         o  there is a structure mismatch (when a data  set  matches  the
            reference  requirements  but  differs  in  structure from the
            original data set, whether in the name, type,  keyed  status,
            protection, or other defined characteristic of one or more of
            its attributes).


   Additional text following this diagnostic message provides information
   as to the precise nature of the problem.

   %NO DATASETS OPEN AT PERFORM-TIME, AT LEAST 1 REQUIRED
   INFORMATION ON REQUIRED DATASETS FOLLOWS.
   This message appears when a compiled program references  one  or  more
   data  sets and none are open.  The required data sets are listed after
   this message.

   %ERRORS ENCOUNTERED CHECKING PERFORM-TIME USER VARIABLES
   This message occurs when variables defined at COMPILE time have either
   been  misdefined or not defined at all at PERFORM time.  A description
   of the variable(s) in question follows the message.












                                 CHAPTER 9

                             REPORT GENERATION



   System 1022 provides the Report Generator to produce reports in  which
   the data is grouped into hierarchies with headings and totals for each
   group in the hierarchy.

   A report program can be stored in a disk file for repeated  use.   The
   output of a Report Program (a "report") may be directed to a disk file
   or typed at the terminal,  whichever  is  needed.   Most  reports  are
   written  using  a  simple structure which requires little programming.
   If custom procedures are required, the features of  PL1022,  the  data
   programming language, (see Chapter 8) are used.

   1022 can skip  sections  with  no  entries,  create  multiply  divided
   subtotal  lines,  and calculate pretotals for percentage computations.
   These features are optional and are not usually required in  a  simple
   report.

   The material in this chapter is divided into two  sections  describing
   the  basic  elements  and  the programmed elements of a report.  Users
   with simple report applications need not read the second section.



   9.1  SUMMARY OF REPORT COMMANDS AND FEATURES

   The following list summarizes the commands and features  of  a  Report
   program.   Commands  which  are marked with an asterisk (*) can appear
   only in reports.  Any command used in PL1022 programs may be  used  in
   an advanced report program.


        Command        Description        _______        ___________


        BODY           Defines the portion of the page  to  be  used        ____
                       for printing.

        FOOTING        Sets up page footings for an output channel.        ___

        HEADING        Sets up page headings for an output channel.        ___
   REPORT GENERATION                                             Page 9-2
   Revision 4


        INIT           Assigns a channel for report output.        ___

      * ON CHANGE      Takes action at the beginning  or  end  of  a        __ _
                       group  of  related  records.   This  triggers
                       group headings and totals.

      * ON END         Takes  action  after  the  last   record   is        __ _
                       processed.

      * ON START       Takes  action  before  the  first  record  is        __ __
                       processed.

        PAGE           Defines the  number  of  lines  per  physical        ____
                       page.

        PRINT          Outputs the detail lines of the report.        _

        QUIT           Aborts interactive input of a report  program        _
                       and returns to the basic command level.

        REPORT END     Ends a report  program.   The  report  begins        ___    _
                       execution,  unless  inside  a  larger  PL1022
                       program.

        REPORT START   Starts a report program.        ___    _

      * SECTION        Divides  a  programmed  report  into  control        ___
                       sections.

        SET TAPE       Controls the output of formfeed characters.        ___ ____

        TYPAGE         Defines the page size when output is  to  the        ____
                       user's terminal.

        TYPE           Same as PRINT except the output is always  to        _
                       the user's terminal.


   Most of these commands are described in this chapter.  The  exceptions
   are PRINT, TYPE, INIT, QUIT, and SET TAPE which are discussed in other
   chapters.
   REPORT GENERATION                                             Page 9-3
   Revision 4


   Many System defined variables are useful in reports.  These are:


      System Variable                 Function      _______________                 ________

          SYSDATE      Is today's date.

          SYSDAYTIME   Is the same as SYSTIME except it  is  updated
                       each time it is used.

          SYSLINE(n)   Is the current line number for output channel
                       n.  1022 increments the value when a new line
                       is output, and resets the value to 1  at  the
                       start of a new page.  The user may not change
                       this variable.

          SYSMSTIME    Is the number of milliseconds since midnight.
                       It is updated when referenced.

          SYSPAGE(n)   Is the current page number for output channel
                       n.  1022 increments the value when a new page
                       is output, but the user may change the  value
                       with the LET command.

          SYSRECNO     Is the sequence number of  the  record  being
                       processed in the current selection group.

          SYSREP1      Controls the admission of a record into an ON
                       CHANGE total.

          SYSREP2      Controls printing group headings  and  totals
                       for groups with no records.

          SYSREPMODE   Turns  on  page  parameters,  headings,   and
                       footings outside of reports.

          SYSREPSYNC   Controls  form  feeds  between  pages  of   a
                       report.   When  SYSREPSYNC  is  0 and the SET
                       TAPE  NONE  command  has  been  given,   1022
                       suppresses   automatic   form  feeds  between
                       pages;  when it is 1 and  no  SET  TAPE  NONE
                       command has been given, 1022 generates a form
                       feed between each page.

          SYSTIME      Is the current time of day, updated  at  each
                       command  prompt,  in  an eight character text
                       field of form hh:mm:ss
                       ( <hours>:<minutes>:<seconds> ).


   Except for SYSDATE, SYSTIME, and SYSDAYTIME,  these  System  variables
   are  type  INTEGER and may be treated in the same way as other integer
   variables.  (See also Chapter 2, System Functions).
   REPORT GENERATION                                             Page 9-4
   Revision 4


   9.2  USING REPORT OUTPUT AS PROGRAM INPUT

   To use report output as input to programs or systems (for example,  as
   a  DMI  file  for  System  1022), suppress formfeed characters at page
   boundaries with the FORMFEED IGNORE clause of  a  LOAD,  TRANSACT,  or
   APPEND  command;   or  give  the  command  SET  TAPE  NONE to suppress
   formfeeds in the report output.



   9.3  WRITING A REPORT PROGRAM

   Begin a report program with the command:

        REPORT START        ___    _

   The commands in the report program follow, ending with the command:

        REPORT END        ___    _

   The user may prepare report programs and store them  in  disk  command
   files  which  can  be  executed  with  the  USE  command.  This allows
   mistakes to be corrected  and  later  additions  to  be  made  without
   retyping  the  entire  report.   If the user places the required FIND,
   SEARCH, and SORT commands in the file, the entire selection and report
   procedure can be run from the disk command file.

   As with PL1022 programs of the appropriate format, it is  possible  to
   precompile   report  programs  with  the  COMPILE  command  for  later
   execution with the PERFORM  command  (see  "COMPILE  and  PERFORM"  in
   chapter  8).   When the user types a report program interactively, the
   command level prompt changes from the asterisk to  the  string  * (R).                                                                   _____
   Commands  are  checked  for  language errors as they are entered.  The
   user can abort interactive input of a report program at any time,  and
   return to the basic command level, by typing:

        QUIT

   which erases what was typed.  The following example of a short session
   illustrates  the  interactive  input of a report program.  It contains
   command and typing errors which are caught and  ignored,  followed  by
   the command QUIT.
   REPORT GENERATION                                             Page 9-5
   Revision 4


        * REPORT START        _
        * (R) CLEAR        _____
        ? (CS57) COMMAND OUT OF CONTEXT (EG. REPORTS)        ________ _______ ___ __ _______ ____ ________
         CLEAR         _____
        * (R) HEADINK PRINT SYSPAGE        _____
        ? (CS24) INVALID COMMAND        ________________ _______
        HEADINK        _______
        * (R) HEADING PRINT SYSPAGE        _____
        * (R) QUIT        _____
        TERMINATING PL1022 OR REPORT        ____________________________
        *        _


   Interactive input of a report program  is  useful  for  short  reports
   after  the  user  has  experience  with  the  commands.   Mistakes  in
   interactive input can be corrected only within the current input line.
   A  report  program executes immediately after it is completely scanned
   when it is typed directly from the terminal or executed from a command
   file.

   The report program can be inside a larger  PL1022  program,  in  which
   case  the  report  program  executes  when control comes to the REPORT
   START command inside the PL1022 program.



   9.4  SIMPLE REPORT PROGRAM STRUCTURE

   A simple report program has four main features:

        1. A standard page format with  headings  and  footings  on  each
           page.

        2. Section headings for each group and subgroup.

        3. Detail lines containing information printed from  each  record
           in the group.

        4. Subtotal and total lines.


   A simple report program may contain only the commands we  discuss.   A
   report  program requires SECTION commands if it contains commands such
   as LET, MAP, or GOTO.  A programmed report has no SECTION commands  to
   declare areas of separate report function;  this distinguishes it from
   a simple report.
   REPORT GENERATION                                             Page 9-6
   Revision 4


   The following example illustrates  output  from  a  two  level  report
   program.  The physical page boundaries are denoted by asterisks.


           ********************************************************
           *                                                      *
           *  MOTOR POOL REPORT       -       JULY 8, 1979        *
           *                                                      *
           *    GROUP:   TRUCKS                                   *
           *      SUBGROUP:    SINGLE AXLE                        *
           *         DODGE   70     V-8             $7000         *
           *         CHEVY   72     V-6             $6500         *
           *         FORD    69     V-8             $5000         *
           *         COST FOR SUBGROUP:            $18500         *
           *      SUBGROUP:    DUAL AXLE                          *
           *         MACK    70     DSL            $23000         *
           *         WHITE   72     DSL            $18000         *
           *         COST FOR SUBGROUP:            $41000         *
           *                                                      *
           *    COST FOR TRUCKS:                   $59500         *
           *                                                      *
           *                                                      *
           *    GROUP:   CARS                                     *
           *                                                      *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *                                                      *
           *    COST FOR CARS:                    $140000         *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *           .      .      .               .            *
           *                                                      *
           *    TOTAL COST:                       $199500         *
           *                                                      *
           *  SAVIO TRANSPORT                          PAGE 1     *
           *                                                      *
           ********************************************************



                                Figure 9-1.
                   EXAMPLE OF OUTPUT FROM A SIMPLE REPORT
   REPORT GENERATION                                             Page 9-7
   Revision 4


   The following report program generates the  above  example.   We  have
   omitted the print formats to emphasize the report program structure.

        REPORT START.

        HEADING PRINT "MOTOR POOL REPORT" SYSDATE.
        FOOTING 2 PRINT "SAVIO TRANSPORT" SYSPAGE.
        PAGE 60.
        BODY 60.

        ON CHANGE GROUP PRINT GROUP.
        ON CHANGE SGROUP PRINT SGROUP.

        PRINT MAKER YEAR ENGINE PRICE.

        ON CHANGE SGROUP PRINT TOT PRICE.
        ON CHANGE GROUP PRINT GROUP TOT PRICE.

        REPORT END.

   Simple report programs contain four command groups which  reflect  the
   four  main  features  of  the  report.  This is an outline of a simple
   report program:


        REPORT START
        Page Formatting Commands
        Group Heading Commands
        Detail Lines PRINT Commands
        Group Totalling Commands
        REPORT END


   The commands used in page formatting include:

        HEADING
        FOOTING
        PAGE
        BODY
        TYPAGE

   These commands set up the headings and footings for the  page,  define
   the  physical  page  size,  and define how much of the page to use for
   printing.  In most report programs these commands appear once, and the
   report program uses the same page format throughout.

   The Group Heading and Group Totalling commands are  in  the  ON CHANGE
   family of commands, which includes:

        ON CHANGE
        ON START
        ON END
   REPORT GENERATION                                             Page 9-8
   Revision 4


   The ON CHANGE command is  an  element  of  all  report  programs;   it
   controls group heading and totalling functions for record groups.  The
   Heading ON CHANGE commands precede the detail line commands and govern
   group  headings;   those  which follow govern the totalling functions.
   For this reason there must be at least one PRINT or TYPE command in  a
   simple report program to separate the Heading and Totalling commands.

   The output of detail lines in the report is done  by  PRINT  and  TYPE
   commands.  PRINT directs output either to a disk file or the terminal;
   TYPE outputs only to the user's terminal.

   See Appendix G for a standard form useful for designing reports.



   9.5  PAGE FORMATTING COMMANDS

   These commands define headings, footings, page size,  and  other  page
   parameters  for  System  output channels.  They are used most often in
   report programs, but may also specify paged format for any output.

   An INIT command initializes a System output channel to  write  to  the
   terminal  or  a  file.   Eight output channels are available.  In both
   cases, page conventions on that channel apply to the output.  When  an
   INIT command is issued for a currently inited channel, 1022 performs a
   RELEASE first.  Releasing a channel resets PAGE, BODY, and  TYPAGE  to
   their default values.

   The reassignment of channel 1 by a PRINT  ON <file-descriptor>  clause
   acts like an INIT and resets the page parameters.

   When the TYPE command uses channel 1 (when channel 1 is not in use, or
   when it is set to the TTY), the output respects any page parameters on
   channel 1.   Otherwise,  TYPE  uses  a  background  channel,  no  page
   formatting  applies  to the output, and the output does not affect any
   page or line numbers on any channels.

   When a report starts, page and line numbers are cleared if  SYSREPMODE
   is not set to 1.  If SYSREPMODE is set to 1, page and line numbers are
   not changed.   The  first  HEADING  of  a  report  may  not  print  if
   interactive  PRINT  requests have advanced the output line number past
   1.  A fresh INIT at the  beginning  of  the  report  clears  the  page
   numbers and line numbers regardless of the SYSREPMODE setting.

   The values of the page and line number are  in  the  system  variables
   SYSPAGE(n)  and  SYSLINE(n)  respectively.   The  page  number  may be
   changed in midstream by assigning a value  to  SYSPAGE(n).   The  line
   number  can  not  be  changed.  SYSPAGE or SYSLINE without a subscript
   refer to channel 1.

   A simple report ends by moving to the beginning of a new page on  each
   output channel it uses.
   REPORT GENERATION                                             Page 9-9
   Revision 4


   9.5.1  HEADING And FOOTING Commands

   The HEADING and FOOTING commands associate a heading or footing with a
   System  output  channel.   This  is  done separately for each channel.
   INIT the channel before setting headings and footings.   The  commands
   are:

        HEADING [ON <n>] PRINT <heading-items> [FORMAT ---- END]        ____             _

        FOOTING [ON <n>] <m> PRINT <footing-items> [FORMAT ---- END]        ____                 _

   The clause ON <n> specifies the channel to which the command  applies.
   Channel  1  is assumed if the ON clause is omitted.  The print portion
   of the command is a PRINT  command,  with  a  print  list  and  FORMAT
   included,  except  that the Totals list has no meaning here and totals
   or Totals Functions do not operate.  References to data set attributes
   in  a HEADING or FOOTING refer to the values printing on that page and
   act as an index to the report output.

   The HEADING prints on as many lines of the  page  as  necessary.   The
   FOOTING  requires the integer <m> to specify how many lines to reserve
   for the footing at the end of the BODY.  Unused lines are left  blank;
   it is not necessary for the FOOTING to print them all.

   The HEADING and FOOTING commands normally appear at the beginning of a
   report  program.  They may be used anywhere within a report program at
   any time during execution to change the heading or footing  from  page
   to page.  If a HEADING or FOOTING command is given in the middle of an
   output stream, then it is used when  the  HEADING  or  FOOTING  prints
   next.

   Note that HEADING ON 2 PRINT is correct, but HEADING  PRINT  ON  2  is
   incorrect.


   An example of HEADING is:

        HEADING PRINT SYSPAGE SYSDATE LNAME FORMAT 'DAILY REPORT'
            21T I2..0 31T D1 51T A10 / END

   The above command prints:

        DAILY REPORT         1.       MARCH 23, 1978      BAKER

   LNAME (BAKER) is used as an index to the report.

   If we had not specified a FORMAT we would have printed:

        1 MARCH 23, 1978   BAKER

   The print list in a HEADING print statement cannot contain any  Totals
   functions  such  as  MIN,  MAX,  and  MEAN, but otherwise behaves as a
   general PRINT statement.  An example of FOOTING is:
   REPORT GENERATION                                            Page 9-10
   Revision 4


        FOOTING 2 PRINT SYSPAGE FORMAT / 10T I2..0 5X
            "NOT FOR RELEASE" END

   This produces

        (blank line)
        bbbbbbbbb14.bbbbbNOT FOR RELEASE

   where each "b" represents a space.

   The FORMAT includes the / to separate the text in the footing from the
   text in the report.



   9.5.2  BODY, PAGE, And TYPAGE Commands

   These commands are:

        PAGE [ON <n>] <i>

        BODY [ON <n>] <i>

        TYPAGE [ON <n>] <i>

   These commands  set  output  page  parameters  on  any  System  output
   channel.   <n>  is  the channel number and <i> is the new value of the
   parameter.  The command applies to channel 1 if the ON <n>  clause  is
   omitted.

   The PAGE size is the number of printing lines  on  each  page.   On  a
   printer  with  standard  control tape, the printer skips automatically
   every 60 lines, so this is the PAGE specification for such  a  printer
   and is the default.

   The BODY is the number of lines on each page used for  printing.   The
   printable lines are centered within the PAGE lines.

   TYPAGE streamlines changing the output device.  TYPAGE is used instead
   of  the  PAGE  parameter  when  output  goes directly to the terminal.
   Thus, output designed to go to a disk file can be correctly  formatted
   if it is sent directly to a terminal.  Typically, the user sets TYPAGE
   to 66, the number of lines on an 11 inch page.  If report output is to
   a  CRT terminal, set TYPAGE to the number of lines on the screen.  All
   three parameters default to 60 when a channel is INITed.

   REPORT GENERATION                                            Page 9-11
   Revision 4


   Example:

        Set the nonstandard printing format of 25 printing lines per
        page,  with  an  automatic printer form feed after 25 lines,
        with the commands:

             PAGE 25
             BODY 25

        This places 25 lines on each page  and  generates  no  blank
        fill lines.

        To place this report within the 25 line limit, but only  use
        the middle 20 lines, specify:

             PAGE 25
             BODY 20

        System 1022 generates two blank fill  lines,  prints  on  20
        lines,  and  then  generates three blank fill lines for each
        page.



   9.5.3  Paged Output Outside Of Reports

   Generate paged output outside of report programs by setting the system
   variable SYSREPMODE equal to 1 in the following manner:

        LET SYSREPMODE EQ 1

   Output on all channels follows the default page parameters or the ones
   last set by the user.

   SYSREPMODE affects both simple and complex report programs when it  is
   set equal to 1.  The report program does not print an ending form feed
   or clear the page parameters;  only the user's commands produce output
   to the file.
   REPORT GENERATION                                            Page 9-12
   Revision 4


   9.6  BASIC ON CHANGE COMMANDS

   The  ON CHANGE  command  produces  group  headings  and  totals  which
   surround  the  detail lines for each group and subgroup in the report.
   The ON CHANGE commands which produce the headings  appear  before  the
   detail  commands  in the order that the headings print.  The ON CHANGE
   commands which produce  the  group  totals  appear  after  the  detail
   commands in the order that the totals print.

   An ON CHANGE statement detects the change in value of an attribute  or
   expression.  A group is introduced by a group heading ON CHANGE and is
   totalled by a group totalling ON CHANGE.  This logic  works  when  all
   alike  records  appear  together as the report program retrieves them.
   The user establishes the proper record order by giving a SORT  command
   on the attributes which are used to distinguish groups.

   A single level report distinguishes  records  by  the  values  of  one
   attribute.   The  needed  SORT command sorts the records into order on
   that attribute.

   A two level report has groups within groups.   The  major  groups  are
   distinguished  by  the  values  in  the major attribute, and the minor
   groups within a major group are distinguished by  the  values  in  the
   minor  attribute.  The needed SORT command sorts by both the major and
   minor attributes, in that order.


   The ON CHANGE command has the form:

                                {PRINT [ON <n>] }
        ON CHANGE <expression>  {               } <output-list>        __ _
                                {TYPE           }

                       [ FMT ... END ]

   The <expression> may be any attribute name or  expression.   Attribute
   names  refer  to  attributes  in the current data set.  In expressions
   involving  variable-length  string  functions,  only  the   first   25
   characters are examined to determine change breaks.

   An ON CHANGE command takes action, "triggers", when the value  of  the
   expression  changes  from  one  group to the next.  A group heading ON
   CHANGE triggers just before the first record  of  a  group.   A  group
   totals ON CHANGE triggers just after the last record of a group.

   The PRINT statement inside an ON CHANGE command  produces  the  output
   when  the ON CHANGE triggers.  A group heading ON CHANGE PRINT command
   cannot print totals functions;  there is no totals list.

   A group totals ON CHANGE  PRINT  command  may  print  expressions  and
   totals  functions freely intermixed in one list;  there is no separate
   main-list.
   REPORT GENERATION                                            Page 9-13
   Revision 4


   Output from an ON CHANGE may be directed to any channel by  using  the
   ON  <n>  clause.   The  output goes to channel <n>.  Do not use the ON
   <file-descriptor> clause; this repeatedly overwrites the  named  file.
   Output goes to channel 1 when there is no ON <n> clause.

   Use the ability to direct output to many channels to  produce  summary
   reports.   ON  CHANGE  commands  may  be  repeated with the second one
   printing its output to a separate file.  This  separate  file  is  the
   summary  report.   Headings  and  Footings  may be established for the
   second file just as for the main report file.

   For example:

             ON CHANGE CITY PRINT...
             PRINT...
             ON CHANGE CITY PRINT...
             !Make an entry in the summary file
             ON CHANGE CITY PRINT ON 2...

   where channel 2 has been INITed to a file for summary.


   A heading ON CHANGE is one which precedes  the  detail  lines  of  the
   report;   it prints information just before records having a new value
   of the ON CHANGE expression.  Attributes which appear in a heading  ON
   CHANGE take their values from the first record of the following group.
   Totals  functions  do  not  appear  in  a  heading  ON  CHANGE.    The
   information  needed  to  construct  a  total has not been scanned yet.
   (See Pretotals in Advanced Reports for a way to introduce a group with
   a total derived from that group.)

   A totals ON CHANGE is one  which  follows  the  detail  lines  of  the
   report.   It  prints information just after the last record of a group
   when  the  next  record  has  a  different  value  of  the  ON  CHANGE
   expression.   Attributes take their values from the last record of the
   group.

   Totals functions usually appear in the  print  list  of  a  totals  ON
   CHANGE.   These functions are evaluated using the preceding records of
   the ON CHANGE group.  For example, the expression TOT  SALARY  is  the
   total of all the SALARY fields in the preceding group for which the ON
   CHANGE expression is constant.  This is the subtotal of SALARY for the
   CITY if CITY is the ON CHANGE expression.

   Two special ON CHANGE commands are used at the  start  and  end  of  a
   report program:

        ON START PRINT ...

        ON END PRINT ...

   No change expression appears because the group is all of  the  records
   in  the  report.  The ON START is triggered by the start of the report
   REPORT GENERATION                                            Page 9-14
   Revision 4


   and produces a heading for the entire report.  The ON END is triggered
   by  the  end  of  the  report and produces summary messages and totals
   derived from all records in the report.  An ON START  or  ON  END  may
   reference  attributes;   they take their values from the first or last
   record of the report.  ON  END  may  contain  Totals  functions  which
   produce grand totals using all the records in the report.

   The rest of ON START or ON END is exactly like the PRINT clause in the
   ON CHANGE command.  The user may place any number of these commands in
   a report structure, provided that the ON STARTs occur before the first
   group  heading  commands  and  the  ON ENDs occur after the last group
   total commands.


   A typical two level report program has the following structure:


        SORT STATE CITY...                 <====Sort command

        REPORT START

        HEADING...                         <==== Page Formatting commands
        FOOTING...

        ON CHANGE STATE PRINT STATE ...    <====Group Heading commands
        ON CHANGE CITY PRINT CITY ...

        PRINT LASTNAME FIRSTNAME SALARY... <====Detail Lines command

        ON CH CITY P CITY TOT SALARY...    <====Group Totals commands
        ON CHANGE STATE PRINT STATE TOT SALARY ...

        REPORT END


   The major groups of records are the states, and the  minor  groups  of
   records  are  the cities in those states.  The central PRINT statement
   displays information about the people in the report.   The  ON  CHANGE
   statements  introduce  and summarize the groups and subgroups.  The ON
   CHANGE statements are like parentheses inserted into the overall  flow
   of records.  Their output groups related records.

   The innermost ON CHANGEs are the statements ON  CHANGE  CITY...   They
   immediately  precede and follow the detail PRINT statement.  The value
   of the attribute CITY changes most frequently and is a subgroup within
   each  value  of  STATE.   These ON CHANGE statements produce the group
   headings and group totals which depend  on  CITY.   They  produce  the
   innermost sets of parentheses in our analogy.

   The statements ON CHANGE STATE...  are  each  farther  away  from  the
   detail  PRINT,  and  produce output less often than the ones for CITY.
   The ON CHANGE STATE  statements  enclose  a  number  of  CITY  groups,
   introducing  and  summarizing  them.  Their output forms the outermost
   REPORT GENERATION                                            Page 9-15
   Revision 4


   sets of parentheses, in our analogy.

   The attribute STATE defines a level in the hierarchy, and CITY defines
   a  sublevel  within  STATE.   The  ON CHANGE statements for each level
   appear in pairs in this example, but they need  not  be  paired.   The
   user leaves out the heading ON CHANGE for a level when that heading is
   not needed, or leaves out the totalling ON CHANGE for a level when  no
   totals are needed.

   The user may have more than one ON CHANGE  statement  at  each  level.
   All ON CHANGE statements based on the same attribute or expression are
   at the same level.  They execute at the same time and  in  order  when
   the group defined by that attribute changes.

   The user may also include more than one central PRINT statement.   All
   of them print for each record of the report, in the order they appear.
   REPORT GENERATION                                            Page 9-16
   Revision 4


   9.7  EXAMPLE OF A THREE LEVEL REPORT

   The  following  is  a  typical  three  level   report   program   with
   initialization  commands.   It might be a report in a large interstate
   company with employees in many states, cities, and locations.



   FIND ALL.
   SORT BY STATE CITY LOCATION LASTNAME FIRSTNAME.

   REPORT START.
   HEADING PRINT SYSPAGE SYSDATE
      FMT 30T I2..0 5X D3 // END.

   FOOTING 2 PRINT FMT / 'XYZ EMPLOYEES' END.
   TYPAGE 66.

   ON START PRINT FMT  'XYZ EMPLOYEE REPORT' / END.

   ON CHANGE STATE  PRINT STATE  FMT '*** FOR STATE ' A /// END.

   ON CHANGE CITY  PRINT CITY  FMT '* CITY ' A // END.

   ON CHANGE LOCATION  PRINT LOCATION  FMT 'LOC ' A / END.


   PRINT LASTNAME FIRSTNAME SALARY BONUS SALARY+BONUS
      FMT A11 A16 30T I6 I7 I9 END.


   ON CHANGE LOCATION  PRINT TOT SALARY  TOT BONUS  TOT SALARY+BONUS
      FMT / 15T 'LOC SUBTOTAL' 30T I6 I7 I9 / END.

   ON CHANGE CITY  PRINT TOT SALARY  TOT BONUS  TOT SALARY+BONUS
      FMT / 10T 'CITY SUBTOTAL' 30T I6 I7 I9 // END.

   ON CHANGE STATE  PRINT TOT SALARY  TOT BONUS  TOT SALARY+BONUS
      FMT / 5T 'STATE SUBTOTAL' 30T I6 I7 I9 C1 END.

   ON END PRINT TOT SALARY  TOT BONUS  TOT SALARY+BONUS
      FMT 'TOTALS FOR REPORT' //
         'SALARY' I$8 5X 'BONUS' I$7 5X 'TOTAL' I$9 C1 END.


   REPORT END.
   REPORT GENERATION                                            Page 9-17
   Revision 4


   (Output of the Sample Report)

                                  1.      6/01/1979


   XYZ EMPLOYEE REPORT

   *** FOR STATE ALABAMA



   * CITY ALTON


   LOC PLANT1

   ABRAMS     MARTIN              10400    500    10900
   BROWN      CARL                15000    800    15800
   WILLIAMS   STANLEY              9800    500    10300

                  LOC SUBTOTAL    35200   1800    37000

   LOC PLANT2

   FRANKLIN   LAURA               15000    900    15900
   PETERS     BILL                11500    500    12000

                  LOC SUBTOTAL    26500   1400    27900


             CITY SUBTOTAL        61700   3200    64900


   * CITY FLINT


   LOC SALES1

   SMITH      LINDA               11500    800    12300
   SMITH      JIM                 10800    500    11300

                  LOC SUBTOTAL    22300   1300    23600

             CITY SUBTOTAL        22300   1300    23600


        STATE SUBTOTAL            84000   4500    88500



   (blank line)
   XYZ EMPLOYEES
   (page)
   REPORT GENERATION                                            Page 9-18
   Revision 4


   (Output of the Sample Report)

                                  3.      6/01/1979


   (additional report output similar to page 1 follows)

   . . .

   (blank line)
   XYZ EMPLOYEES
   (page)


   . . .

   (page)


                                 26.      6/01/1979


   TOTALS FOR REPORT


   SALARY $1453400     BONUS   $71300     TOTAL $1524700




   (blank lines)




   XYZ EMPLOYEES
   (page)
   REPORT GENERATION                                            Page 9-19
   Revision 4


   9.8  COMPLETING A HIERARCHY

   The following report program prints totals for the smallest groups  in
   the  data.   Additional ON CHANGE commands are included to assure that
   the groups are separated by any larger  groups,  although  the  larger
   groups are not of interest for totals.  The report program operates on
   the interstate company example introduced in the previous section.

   (The numbers in parentheses are for the discussion below; they do  not
   appear in the actual report program.)

           FIND ALL.
           SORT BY STATE CITY LOCATION LASTNAME FIRSTNAME.
       
           REPORT START.
       
      (1)  ON CHANGE STATE PRINT.
      (2)  ON CHANGE CITY PRINT.
       
      (3)  ON CHANGE LOCATION PRINT LOCATION.
       
           PRINT LASTNAME FIRSTNAME SALARY BONUS SALARY+BONUS.
       
      (4)  ON CHANGE LOCATION PRINT TOT SALARY  TOT BONUS
                     TOT SALARY+BONUS.
       
      (5)  ON CHANGE CITY PRINT.
      (6)  ON CHANGE STATE PRINT.
       
           REPORT END.


   Lines (3) and (4) are the  ON  CHANGE  commands  which  produce  group
   headings and totals.

   ON CHANGE commands (1), (2), (5), and (6) are null.  The PRINT command
   in  each  one  is  a placemarker;  it prints nothing because it has no
   print list.

   The null ON CHANGE commands describe the group  boundaries  for  STATE
   and  CITY.   Without  them,  only the value of LOCATION in each record
   defines a location group.  It might be that two adjacent  cities  have
   locations  by the same name, and that these locations would be grouped
   as one location although in different  cities.   The  null  ON  CHANGE
   commands  establish  group boundaries at higher levels which also have
   effect at the lower levels.   They  divide  the  records  into  groups
   according to all group values.
   REPORT GENERATION                                            Page 9-20
   Revision 4


   9.9  PRETOTALS IN SIMPLE REPORT PROGRAMS

   The PRETOTAL feature described in Sectioned Reports  may  be  used  in
   simple  report  programs without including the SECTION commands of the
   programmed report.  PRETOTALS are used to  print  percentages  in  the
   detail  lines  of  a  report  which  are  derived  from  group totals.
   PRETOTALS may also print a group total as part of the heading for  the
   group.




   9.10  ADVANCED REPORT PROGRAM STRUCTURE

   A Report program is a specialized  PL1022  program.   The  program  is
   divided into six sections:

        Section                       Function        _______                       ________

        INITIAL   Processes all initialization commands such  as  HEADING
                  and  FOOTING,  and any commands which are executed once
                  at the start of the report.

        GETREC    Retrieves records for processing, one by one, from  the
                  current data set.

        HEADING   Processes  all  group   heading   ON CHANGE   commands,
                  including ON START.

        PRINT     Outputs the detail lines.

        TOTALS    Processes  all   ON CHANGE   group   totals   commands,
                  including ON END.

        FINAL     Processes all commands which execute once at the end of
                  the report.

   These internal divisions are invisible  to  the  user  of  the  simple
   report;  1022  decides  which  commands  belong  to each section.  The
   sections do not execute in the order in which they  are  written  (see
   this  chapter,  Report  Execution  Sequence).   1022  depends  on each
   section doing its assigned function so that background operations  are
   managed correctly.

   The SECTION commands keep the  different  report  functions  separated
   when  programming  commands  are used.  A sectioned report program has
   the form:

   REPORT GENERATION                                            Page 9-21
   Revision 4


        REPORT START.

        SECTION INITIAL.
             *
        SECTION GETREC.
             *
        SECTION HEADING.
             *
        SECTION PRINT.
             *
        SECTION TOTALS.
             *
        SECTION FINAL.
             *
        REPORT END.

   All of the SECTION commands must appear in the order listed above  and
   as  a  complete  set.   The SECTION command word may be abbreviated to
   SEC.  The keywords may be shortened to 1 letter.

   Each SECTION is a report program subroutine.  Control  enters  at  the
   top  and leaves at the bottom at the next SECTION command.  The user's
   report commands and PL1022 procedures execute within each  section  to
   accomplish its task.

   Each section receives complete control to handle its assigned function
   and executes as a separate routine.  The user must end each section by
   transferring control  to  the  following  section  command  either  by
   branching  or  by allowing control to pass through.  Labels may be put
   on SECTION commands for this purpose.  (See also the  chapter  "PL1022
   Programming").

   Report  programs  may  appear  in  larger  PL1022   programs   without
   confusion,  and control may pass outside the report program using CALL
   commands or GOTOs, provided that control returns to the  same  section
   that called.



   9.10.1  SECTION INITIAL

   Section Initial appears in the report  program  immediately  following
   the  REPORT  START  command.   The  user places here any commands that
   execute once at the beginning of the report, such as initialization of
   program  control variables, channel assignments, and HEADING, FOOTING,
   and page control specifications.

   Channel and data set initialization commands may be placed in front of
   REPORT START and will apply to the report.

   Any OPEN commands must be placed  before  the  REPORT  START  command.
   (See Chapter 8, Running a PL1022 Program.)
   REPORT GENERATION                                            Page 9-22
   Revision 4


   Heading, footing, and  other  output  initialization  commands  go  in
   SECTION INITIAL, not SECTION HEADING.



   9.10.2  SECTION GETREC

   Section Getrec is the part of the report program which  retrieves  the
   next  record.   The report program looks at records one at a time, and
   it is the job of Section Getrec to select each record for examination.
   This function requires a separate section because the report must know
   about the next record to decide which ON CHANGE totals print  for  the
   earlier records.

   The "next record" may be many records  when  working  with  many  data
   sets.   The  report program does not need to work with single records,
   but with "frames" of data, as if each frame were part of a sequence of
   data  being  presented to the report program for printing and summary.
   All currently selected records, possibly in many data sets,  form  one
   frame.   This  data  is  available  for  one  cycle through the report
   sections.  The ON CHANGE statements can look at any data in the  frame
   to decide where to break the data into groups.

   Further, the user may set the values of variables and think of them as
   part  of  the frame, using them for display and to control the report.
   Do not assign values in Section Getrec to variables which are used for
   totals.

   For example, consider the following report program fragment:

       OPEN PERSNL PLAN. FIND ALL.

       REPORT START.
       SECTION INITIAL.
          DEFINE INTEGER CONTRIB.

       SECTION GETREC.
          MAP TO PLAN VIA PLAN_NO.
          DBSET PRSNEL.

       SECTION HEADING.
       SECTION PRINT.
          LET CONTRIB EQ .02*SALARY+.05*BONUS.


   This is a report on employees of a company.  The employee records  are
   in  PERSNL.   Each employee belongs to a health plan which is recorded
   by PLAN_NO, the plan number.

   REPORT GENERATION                                            Page 9-23
   Revision 4


   Section Getrec extends the main record by selecting the proper  record
   from  the  health  plan  data set PLAN.  The last line of the fragment
   calculates the value of the employee health plan contribution.   These
   actions   both  add  to  the  current  data  frame  and  provide  more
   information which is used in the report  for  each  report  cycle.   A
   cycle  corresponds  to  a  PRSNEL record.  The PRSNEL record, the Plan
   record, and the  variable  CONTRIB  are  available  for  printing  and
   totalling as needed.



   9.10.2.1  Empty Section Getrec

   An empty Section Getrec leaves the  record  selection  to  the  report
   program in the background.  The report program selects the next record
   from the current selection group for each cycle  through  the  report.
   The report program ends when the records are exhausted.

   When there are many data sets open, the blank Section  Getrec  selects
   records  from  the  data  set  which is current at the location of the
   SECTION GETREC command.



   9.10.2.2  Nonempty Section Getrec

   The user may place commands in  Section  Getrec,  but  may  avoid  any
   GETREC  commands.   In  this  case  also,  the  report program selects
   records for the user and ends when the records are exhausted.  Control
   transfers  to  the  beginning  of  Section Getrec after each record is
   selected.  The user's commands can test and derive other  values  from
   the record before the other sections of the report program execute.



   9.10.2.3  User GETRECs

   The user may have complete control of the record selection process  by
   placing  one  or  more  GETREC commands in Section Getrec.  The report
   program does not select any records for the user when a GETREC command
   appears there.

   User GETRECs are usually done for multiple data set reports.  The user
   places  commands  in this section to select the next frame of data for
   each pass through the report program.  The "data frame"  is  the  data
   which  is  selected  in  the  records  and  derived  in the associated
   variables.

   The report does  not  end  automatically  when  the  user  has  GETREC
   control.   End  the report when the records are exhausted by branching
   directly to the SECTION TOTALS command from Section Getrec.   This  is
   the  one  case  where a branch is allowed to any but the next section.
   The report program notices that the user has skipped  Section  Heading
   REPORT GENERATION                                            Page 9-24
   Revision 4


   and  Section Print and ends the report program by executing the totals
   to finish the report.  Then  the  report  program  ends  by  executing
   Section Final.

   Example:

                  SECTION GETREC.
                  LET FLAG  EQ 0.
                  GETREC DONE.
                  IF AGE GT IVAL THEN L1.
                  LET FLAG EQ 1.

        L1:       SECTION HEADING.

                    .
                    .
                    .  

        DONE:     SECTION TOTALS.


             The user does his own GETREC command  in  the  example.
             If  it  is  successful, the variable FLAG is set 0 or 1
             depending on the  AGE  in  the  record.   Control  goes
             directly   to  Section  Totals  when  the  records  are
             exhausted.



   9.10.3  SECTION HEADING

   "Heading" refers to Heading ON CHANGE commands and  to  their  special
   case,  ON  START.   It  does not refer to the page heading or footing.
   All HEADING and FOOTING commands belong in  Section  Initial,  not  in
   Section Heading.

   The Heading ON CHANGE commands  are  placed  in  this  section.   They
   appear  in  the order that they print when activated by a change.  Any
   ON START commands appear first.  There is no restriction to the  other
   statements  which  may be included for control.  The user can maintain
   his own results and flags in and around  the  ON CHANGE,  but  control
   must not jump around an ON CHANGE command.

   Group totals are produced in  Section  Totals,  not  Section  Heading.
   Heading ON CHANGEs refer to the records to follow, specifically to the
   first record in the group.  Variables which are assigned  a  value  in
   this section are proper for producing totals in Section Totals.
   REPORT GENERATION                                            Page 9-25
   Revision 4


   9.10.4  SECTION PRINT

   Section Print receives control after any group headings have  printed.
   This  section  displays  the  detail  information  of the report.  The
   report is called a summary report when Section Print prints nothing.

   Many PRINT and conditional statements may be placed in this section to
   achieve a desired result.

   Variables which are assigned their values in Section Print are  proper
   for  use  in  tests  and  totals  in  Section  Totals.  (See also this
   chapter, Custom Reports).



   9.10.5  SECTION TOTALS

   Section Totals contains  all  totals  ON  CHANGE  commands  and  their
   special case, ON END.

   This section generates the  group  totals  and  summary  data  of  the
   report.   The  ON  CHANGE  command  totals  report  data  by group and
   subgroup when used in Section Totals.  The data comes  from  the  last
   group  of  records  having a common value of the ON CHANGE expression,
   and from variables derived from those records.

   A totals ON CHANGE  is  designed  to  produce  group  totals.   Totals
   expressions  may  be  included  freely  in the print list of the PRINT
   clause.  The value of each expression is produced when the  ON  CHANGE
   triggers  at  the  end  of a subgroup.  The value is accumulated while
   reading records of the group before the ON CHANGE triggers.

   Variables may be used  in  ON  CHANGE  totals.   Assign  their  values
   anywhere but in Section Getrec.  A value assigned in Section Getrec is
   too new;  it is one record ahead of the record  needed  for  totalling
   the  previous  group.  A convenient standard is to assign variables in
   Section Print and Section  Totals  if  they  take  their  values  from
   attributes and if they are totalled by ON CHANGEs.

   The ON CHANGE expression determines when the ON CHANGE triggers.  When
   the  expression  is  about  to  change,  the values accumulated in the
   totalling  expressions  are  printed.   They  then  are   cleared   in
   preparation for the next total.

   ON CHANGE commands are  independent  of  each  other  except  for  the
   following.   The  ON  CHANGEs  are hierarchical.  ON CHANGEs which are
   later in Section Totals apply to  larger  groups  than  earlier  ones.
   When  a  later  ON  CHANGE  triggers,  it causes all earlier ON CHANGE
   commands to trigger also.  Earlier ON CHANGE  commands  define  groups
   which  are  completely  contained  in  the  groups  of later ON CHANGE
   commands.

   Section Heading ON CHANGE commands  are  hierarchical  also.   Earlier
   REPORT GENERATION                                            Page 9-26
   Revision 4


   heading ON CHANGEs define larger groups than later heading ON CHANGEs.
   As they appear closer to Section Print, the  ON  CHANGEs  change  more
   often during the report and define smaller groups and subgroups.



   9.10.6  SECTION FINAL

   Operations to be performed at the end of the report are  placed  here.
   This  section  is  executed  only  once at the end of the report.  The
   report program finishes executing at the REPORT END command.

   The output file need not be released in Section Final, but may be left
   assigned    for   further   output   from   other   report   programs.
   Alternatively, the file may be released and further  output  added  to
   the file by reassigning the file with the INIT APPEND command.

   All ending commands need not be grouped  in  this  section;  some  may
   follow the REPORT END command outside and after the report.
   REPORT GENERATION                                            Page 9-27
   Revision 4


   9.10.7  Sectioned Report Example

   The following example  produces  the  same  report  as  the  preceding
   example  of a Three Level Report except that it also totals the number
   of employees whose earnings  are  $15000  or  greater.   Some  of  the
   changes are indicated by "-->" arrows in the margin.

        FIND ALL.
        SORT BY STATE CITY LOCATION LASTNAME FIRSTNAME.
        
        REPORT START.
        SECTION INITIAL.
           HEADING PRINT SYSPAGE SYSDATE FMT 30T I2..0
                5X D3 // END.
           FOOTING 2 PRINT FMT / 'XYZ EMPLOYEES' END.
       --> DEFINE INTEGER EMPL15.
           TYPAGE 66.
        
        SECTION GETREC.
        SECTION HEADING.
           ON START PRINT FMT 'XYZ EMPLOYEE REPORT' / END.
           ON CHANGE STATE PRINT STATE FMT '*** FOR STATE ' A /// END.
           ON CHANGE CITY PRINT CITY FMT '* CITY ' A // END.
           ON CHANGE LOCATION PRINT LOCATION FMT 'LOC ' A / END.
        
        SECTION PRINT.
           PRINT LASTNAME FIRSTNAME SALARY BONUS SALARY+BONUS
                 FMT A11 A16 30T I6 I7 I9 END.
       --> LET EMPL15 EQ 0.
       --> IF SALARY+BONUS LT 15000 GOTO TOTS.
       --> LET EMPL15 EQ 1.
        
   TOTS:   SECTION TOTALS.
        
           ON CHANGE LOCATION PRINT TOT SALARY TOT BONUS
       -->      TOT SALARY+BONUS TOT EMPL15 FMT 15T
                'LOC SUBTOTAL' 30T I6 I7 I9 I5 / END.
        
           ON CHANGE CITY PRINT TOT SALARY TOT BONUS TOT SALARY+BONUS
       -->      TOT EMPL15  FMT / 10T 'CITY SUBTOTAL'
           30T I6 I7 I9 I5 // END.
        
           ON CHANGE STATE PRINT TOT SALARY TOT BONUS TOT SALARY+BONUS
       -->      TOT EMPL15 FMT / 5T 'STATE SUBTOTAL'
           30T I6 I7 I9 I5 // END.
        
           ON END PRINT TOT SALARY TOT BONUS TOT SALARY+BONUS
       -->      TOT EMPL15  FMT 'TOTALS FOR REPORT' //
                'SALARY' I$8 5X 'BONUS' I$7 5X 'TOTAL' I$9
       -->      'NUMBER OF EMPLOYEES EARNING > $15000:' I C1 END.
        
        SECTION FINAL.
        REPORT END.
   REPORT GENERATION                                            Page 9-28
   Revision 4


   9.11  PROGRAMMED ON CHANGE FEATURES

   The following options to the ON CHANGE command are used  to  construct
   report  programs  in which the user directs more of the report program
   operation.  These apply to ON START and ON END as well as ON CHANGE.



   9.11.1  GOTO Clause

   The GOTO clause branches to a labelled statement when a change in  the
   record group occurs.  The form is:

        ON CHANGE <expression> GOTO <label>.

   where the label refers to a labelled statement in the  report  program
   or  in  a  surrounding  PL1022  program.   (See  the  chapter  "PL1022
   Programming").

   Command execution jumps directly to  <label>  when  the  record  group
   changes  as  determined by the <expression>.  Command execution passes
   through to the next statement on any report cycle where the expression
   does  not detect a new record group.  As a comparison, ON CHANGE PRINT
   prints something for a new group;  ON CHANGE GOTO transfers to execute
   other commands.

   Typically,  the  program  accumulates  totals  and  flags   when   the
   expression  does  not change, then prints values and clears the totals
   when the expression changes.

        Example:

                    LET CITYSAL EQ CITYSAL+SALARY.
                    ON CHANGE CITY GOTO CITYCHNG.  GOTO L1.
        CITYCHNG:   PRINT CITYSAL --- .
                    LET CITYSAL 0.
        L1:         (following commands)


        The  above  report  fragment  does  manually  what  is  done   by
        ON CHANGE PRINT  CITYSAL  EQ  TOT SALARY.   The  initial value of
        CITYSAL must be set 0  in  Section  Initial  so  that  the  first
        accumulated  total  is  correct.  The only statement that affects
        the ON CHANGE hierarchical structure  is  the  ON CHANGE  command
        itself.
   REPORT GENERATION                                            Page 9-29
   Revision 4


   9.11.2  EVALUATE Clause

   Use the ON CHANGE EVALUATE command  to  assemble  totals  for  use  in
   commands  which are executed by an ON CHANGE GOTO.  ON CHANGE EVALUATE
   forms group totals without printing them.

        Example:

                    ON CHANGE CITY EVALUATE CITYSAL EQ TOT SALARY, ...
                    ON CHANGE CITY GOTO CITYCHNG.  GOTO L1.
        CITYCHNG:   PRINT CITYSAL ...
                    ( Commands execute here when CITY changes. )
                     
        L1:         (next statements)

   Many totals can be put into one EVALUATE clause.

   Totals functions must appear in ON CHANGE commands to  work  properly.
   For example:

           ON CHANGE SALARY GOTO A1.
           GOTO A2.
       A1: PRINT TOT SALARY.
            .
            .
            .
       A2: etc.

   does not work, but:

           ON CHANGE SALARY EVALUATE I EQ TOT SALARY.
           ON CHANGE SALARY GOTO A1.  GOTO A2.
       A1: PRINT I.
            .
            .
            .
       A2: etc.

   is correct.

   PRINT executes as an independent command when it stands by itself.  It
   can  only  try  to  total  the  one record which is current during the
   report cycle when it executes, and it knows nothing  about  groups  in
   the  report.   ON CHANGE  SALARY EVALUATE  detects  groups and assigns
   group totals to variable I.  A PRINT command then prints this value.
   REPORT GENERATION                                            Page 9-30
   Revision 4


   9.11.3  PRETOTAL Clause

   Pretotals in a single  PRINT  command  are  discussed  in  Chapter  4,
   Pretotals.   The  same capability is available in report programs with
   ON CHANGE commands.  In an interactive  PRINT  command,  specifying  a
   Mixed  Totals expression causes 1022 to scan the records once silently
   to generate the totals used in the print-list expressions.   Something
   similar but more complicated is done to generate groups of totals from
   different levels of the report.  In a report program, the  user  calls
   for  the  Pretotal  operation  with  the  keyword  PRETOTAL  as in the
   following:

                                        { TYPE     }                                          _
        ON CHANGE <expression> PRETOTAL { PRINT    } ...                                          _
                                        { EVALUATE }                                          ___

   The Pretotal option may be used in any ON CHANGE or ON END command  in
   Section  Totals of the report program with PRINT, TYPE, and especially
   EVALUATE.  PRETOTAL has no meaning in Section Heading.

   Pretotals work as follows.  The user chooses the totals that he  wants
   available  for arithmetic and printing in Section Print.  These may be
   the same as quantities he also wants to print in Section Totals.

      If they are, he uses  the  EQ  clause  construction  in  the  PRINT
      command to assign these totals to variables.

      If the totals  are  not  printed  in  Section  Totals,  he  assigns
      variables in ON CHANGE EVALUATE statements.

   The keyword PRETOTAL  in  these  ON CHANGE  commands  causes  1022  to
   generate  those  totals  during a silent report execution.  The totals
   are then available during a second printing execution at the beginning
   of each group of records which generated them.

   The variables assigned in this way may appear in arithmetic and  print
   statements  in  Section  Print.   They  are  also  meaningful  in  any
   ON CHANGE statements in Section Heading or Section Totals which are at
   an equal or lower group level in the report.

   Use PRETOTAL in each ON CHANGE command which assigns a  variable  that
   is  used  across group levels.  PRETOTAL is not needed in the commands
   which only reference a pretotalled variable.

   PRETOTAL is not needed in an ON  CHANGE  to  make  a  value  available
   within  the  same  command.  Variables assigned first in a command are
   available to expressions later in the same command, as in any PRINT or
   EVALUATE.


   REPORT GENERATION                                            Page 9-31
   Revision 4


   Following is the skeleton structure of a three  level  report  program
   about   salaries  for  an  interstate  company.   The  report  program
   generates information about each group's  total  as  a  percentage  of
   higher group totals.


        REPORT START.
        SECTION INITIAL.
        DEFINE INTEGER CTYTOT STATTOT GRNDTOT.

        SECTION GETREC.

        SECTION HEADING.
        ON START PRINT GRNDTOT.

        ON CHANGE STATE PRINT STATE STATTOT.

        ON CHANGE CITY PRINT CITY CTYTOT 0.+CTYTOT/STATTOT.


        SECTION PRINT.
        PRINT LASTNAME FIRSTNAME SALARY  0.+SALARY/CTYTOT.


        SECTION TOTALS.
        ON CHANGE CITY PRETOTAL PRINT CTYTOT EQ TOT SALARY
             0.+CTYTOT/STATTOT  0.+CTYTOT/GRNDTOT.

        ON CHANGE STATE PRETOTAL PRINT STATTOT EQ TOT SALARY
             0.+STATTOT/GRNDTOT.

        ON END PRETOTAL EVALUATE GRNDTOT EQ TOT SALARY.

        SECTION FINAL.
        REPORT END.


   The above example shows how to use PRETOTAL.  The  variables  GRNDTOT,
   STATTOT,  and CTYTOT are integers.  The construction 0.+var/var forces
   what would ordinarily be an integer division to be a real division and
   print as a real number.

   GRNDTOT is pretotalled by the ON END statement and  is  available  for
   printing or arithmetic in the ON START command at the beginning of the
   report.

   Pretotal values are useful at or below the group level in  which  they
   are generated, for the following reason.  Suppose the ON START command
   in the example referred to STATTOT.   It  would  print  the  value  of
   STATTOT for the first STATE in the report.  This is not useful because
   there are many values of STATTOT, one for each state at the  beginning
   of the group for each state.
   REPORT GENERATION                                            Page 9-32
   Revision 4


   Printing  a  value  from  a  lower  group   level   gives   incomplete
   information.  It only gives results from one subgroup.

   Printing a value at the same group level, like STATTOT in the  heading
   ON CHANGE STATE command, moves a value from the totals to the heading.

   Using a value from a higher group level gives a reference for printing
   percentages depending on that larger group total.

   The second Heading command prints the total salary for the STATE group
   to  follow,  along with other heading information for that state.  The
   third Heading command prints the CITY total and the percentage of  the
   STATE  total  which  the  CITY  total  contributes.   Each of GRNDTOT,
   STATTOT, and CTYTOT are evaluated from the clause TOT SALARY evaluated
   at different group levels of the report.

   Section Print displays each salary and its percentage of  total  STATE
   salary.

   Section Totals demonstrates how higher level totals are used at  lower
   levels  of  Section Totals itself.  The ON CHANGE STATE command prints
   not only its normal group total, STATTOT, but also a percentage  using
   GRNDTOT.   Referring  to  CTYTOT in that ON CHANGE would not have much
   meaning, because only the last value  of  CTYTOT  for  that  state  is
   present when the ON CHANGE STATE command triggers.

   The STATTOT EQ clause in the second Totals ON CHANGE defines the value
   of  STATTOT  in  time  for STATTOT to be used farther down in the same
   print list.  Also, any Totals Function or expression can  be  used  in
   addition to TOT.




   9.11.4  Restrictions On Pretotals In Report Programs

   Any report program containing an ON CHANGE command using  PRETOTAL  is
   first  executed silently to generate the totals.  Then it is run again
   to produce output.  It is necessary that all  significant  aspects  of
   the  report operate the same way during both executions of the report.
   The user may include his own routines if they  reinitialize  when  the
   report is started again from Section Initial.

   The following initializations commonly are required:

        1. User variables  must  be  assigned  starting  values  if  they
           control report operation.

   REPORT GENERATION                                            Page 9-33
   Revision 4


        2. Multiple data  set  reports  may  require  clearing  selection
           conditions  in  some data sets.  A FIND SYSID 0 command clears
           the selection conditions for  data  sets  that  must  have  no
           records  selected  at  the  start  of  the  report.  These are
           usually data sets beneath the top hierarchical  level  of  the
           report whose records are selected during the report.

   A System variable is available to the report program to determine when
   the report is in a silent pass.

   SYSREP3  has the following values when a report is executing:

      -1  If in a PRETOTAL silent pass.
       0  If in a normal print pass with no PRETOTAL feature.
       1  If in a print pass with the PRETOTAL feature.

   Use SYSREP3 for skipping routines which would operate differently in a
   silent  pass,  but  do not affect the totals.  Because the silent pass
   does not  create  any  output,  routines  that  sense  page  and  line
   positions  may  execute  strangely during a silent pass.  The page and
   line numbers are incremented only by actual output.

   The overhead for using the PRETOTAL feature is the time it takes to do
   the  report twice instead of once, minus the time saved from not doing
   any output during the silent pass.  The overhead  is  about  the  same
   regardless of the number of statements that use PRETOTAL.



   9.11.5  Jumping Around An ON CHANGE

   Because ON CHANGE commands appear in a  general  program  environment,
   the  idea of "jumping around an ON CHANGE" often occurs.  For example,
   the user may not wish to add the values from a particular record  into
   a  total.   The  user  cannot  simply  jump  around an ON CHANGE;  the
   ON CHANGE does not see the current record and has no chance  to  print
   accumulated totals if it has triggered for that record.

   It may be desirable to suppress the printing of an ON CHANGE that  has
   not  seen  any records in the current group because we have ignored it
   for all records in the group.


   There are two System variables which control ignoring an ON CHANGE:

   SYSREP1  is integer and is assigned values by LET commands.  If it  is
   -1 when control enters an ON CHANGE command, the current record is not
   added into the expressions controlled by  that  command.   SYSREP1  is
   automatically reset to 0 by the ON CHANGE.

   SYSREP2  is integer and is assigned values by LET commands.  If it  is
   -1,  it suppresses the printing of any ON CHANGE command which has not
   seen any records in the previous group.  Because  this  is  a  feature
   REPORT GENERATION                                            Page 9-34
   Revision 4


   that  probably  applies to the entire report, 1022 does not reset this
   variable.

   The following example illustrates these System variables:

              LET SYSREP2 -1.
              ON CHANGE CITY PRINT FMT / $ END.
              IF SEX EQ "M" THEN L1.  LET SYSREP1 -1.
   L1:        ON CHANGE CITY PRINT TOT SALARY
                 FMT 5T 'TOTAL FOR MALES   ' I$6..2 END.

              IF SEX EQ "F" THEN L2.  LET SYSREP1 -1.
   L2:        ON CHANGE CITY PRINT TOT SALARY
                 FMT 5T 'TOTAL FOR FEMALES ' I$6..2 END.

              ON CHANGE CITY PRINT FMT / END.

   Setting SYSREP1 to -1  keeps  the  current  record  out  of  the  next
   ON CHANGE  statement.  The variable SYSREP2 is not changed by 1022 and
   its value of -1 keeps null subtotal lines from printing, for  example,
   if  there  are  no  females  in  a  particular  group.  Many ON CHANGE
   statements are grouped in this example on the same trigger expression.



   9.11.6  Generating Distributed Totals

   The previous section shows how an ON CHANGE can be skipped to generate
   separate  totals  for  records  which  differ  in  their  values of an
   attribute.  We show in this section how to produce a distributed total
   by using variables to store parallel values for each record and how to
   total them with ON CHANGE statements.

   Consider a report on a project log data set.   The  data  set  records
   contain  how  many hours were spent by employees on each phase of many
   projects.  The data set contains the following attributes:

        PROJECT     Project ID number.
        NAME        Employee name.
        FUNCTION    DES  (Design),  PRO  (Production),  or  QUA  (Quality
                    Control).
        HOURS       Hours spent by the employee on project activity.

   We want a report at the end of each month which contains  a  breakdown
   of  the  number  of  hours spent on each activity of the project.  For
   example:

        HOURS SPENT ON PROJECT #403:

             DESIGN:             230 HOURS
             PRODUCTION:         640 HOURS
             QUALITY CONTROL:    185 HOURS
   REPORT GENERATION                                            Page 9-35
   Revision 4


   For our purposes it would be convenient if each record  contained  the
   following attributes:

        HOURS DESIGN             _
        HOURS PRODUCTION             _
        HOURS QUALITY CONTROL             _       _

   We could then directly  produce  the  totals  by  putting  the  totals
   functions  for each attribute in the ON CHANGE statement and totalling
   on a change in PROJECT.

   We accomplish the same thing in the data set as it is by  distributing
   HOURS into three associated variables.  We then total the variables as
   if they were separate attributes in the data set.


           FIND ALL.
           SORT BY PROJECT.

           REPORT START.
           SECTION INITIAL.
           DEFINE INTEGER HDES HPRO HQUA.
                .
                .
           SECTION GETREC.
                .
                .
           SECTION HEADING.
                .
                .
           SECTION PRINT.
           PRINT NAME FUNCTION HOURS FMT A10 A15 I3 END.

           SECTION TOTALS.
           LET HDES EQ 0 HPRO EQ 0 HQUA EQ 0.

           IF FUNCTION NE "DES" THEN L1. LET HDES EQ HOURS. GOTO L3.
   L1:     IF FUNCTION NE "PRO" THEN L2. LET HPRO EQ HOURS. GOTO L3.
   L2:     LET HQUA EQ HOURS.

   L3:     ON CHANGE PROJECT PRINT
                       TOT HOURS TOT HDES TOT HPRO TOT HQUA
                   FMT 'TOTAL HOURS; ' I4 /
                       'TOTAL DESIGN: ' I3 /
                       'TOTAL PRODUCTION: ' I3 /
                       'TOTAL Q.C.: ' I3  END.

           SECTION FINAL.
           REPORT END.

   REPORT GENERATION                                            Page 9-36
   Revision 4


   What we have done is to use program logic to expand the  single  value
   HOURS  into  one of three associated variables HDES, HPRO, or HQUA for
   each record.  The totals for the report are then easily obtained.

   The associated values are set at  the  beginning  of  Section  Totals.
   This  guarantees  that  they  are  related to the proper record as the
   records are processed.  Values set in Section Getrec  would  refer  to
   the  next record.  A GETREC record has already been retrieved when the        ____
   record we are actually referring to is processed  in  Section  Totals.
   See the section Custom Reports for more explanation.



   9.12  SUMMARY REPORTS

   The PRINT statement in an ON CHANGE  command  or  in  the  user's  own
   ON CHANGE  routine  can  specify  any  System  channel for its output.
   PRINT statements without an ON clause print on System channel 1.

   The ability to print on any output channel can  be  used  to  generate
   more than one report at the same time in one pass through the data set
   records.  The user  often  desires  a  summary  report  of  totals  in
   addition  to  a  detailed  report.   He only need specify headings and
   footings  for  the  other  channel  and  include  ON CHANGE  or  other
   statements to print information onto that other output file.

   Example:

                       .
                       .
                       .
        SECTION PRINT.
        PRINT LASTNAME FIRSTNAME SALARY --- .

        SECTION TOTALS.
        ON CHANGE CITY PRINT TOT SALARY  FMT --- .
        ON CHANGE CITY PRINT ON 2 TOT SALARY  FMT --- .
                       .
                       .
                       .


   The above is an extract from a typical report program where  the  user
   generates  both  a  full  and a summary report.  One ON CHANGE command
   prints totals for the main report;  the other prints its totals to the
   output file on channel 2.

   The user must INIT an output file for channel 2 and  specify  HEADINGS
   and  FOOTINGS  for each channel separately.  Statements in any part of
   the report program may reference different output channels to  achieve
   the  desired  results.   Eight  channels  are available for generating
   simultaneous report output files.
   REPORT GENERATION                                            Page 9-37
   Revision 4


   Output from a TYPE command does not appear with the expected  headings
   and  footings  if  those  headings  and footings are specified for the
   terminal on a channel other than channel 1.  For a full discussion  of
   how  TYPE  behaves when other channels are in use, see Chapter 4, TYPE
   Command.  It is always proper  to  INIT  the  terminal  to  an  output
   channel  and  direct  output  to  it  with  ON clauses.  The headings,
   footings, and page settings for that channel will apply.



   9.13  MULTIPLE DATA SET REPORTS

   A multiple data set report reads information from more than  one  data
   set.   Information  from  any  data  set may control ON CHANGE groups,
   contribute to totals, and print.

   Multiple data set reports fall into three classes according  to  their
   complexity.   The  differences  are  illustrated by the examples which
   follow.  The classes are:

     1. One data set provides primary records which determine the  report
        cycles.   Other data sets provide information for printing or for
        expanding information from the  primary  record.   This  includes
        translating  codes  by  referencing  other data sets and deriving
        totals from other data sets.

     2. More than one data set in a hierarchy determines the next  report
        program  cycle.   The  report  program  examines the records at a
        level below the top level of a hierarchy and retrieves  from  the
        top levels to determine the participating lower level records.

        The report program also subdivides the lower level  records  more
        finely  than determined by the higher levels.  This distinguishes
        a class 2 report from a class 1 report.  The report  cycles  once
        for  each lower level record, and the ON CHANGEs divide them into
        subgroups.  In contrast, the lower level records  in  a  class  1
        report could be printed as one group for each primary record.

     3. A report program goes beyond class 2 when it  totals  information
        from   the  higher  level  records.   A  class  2  report  totals
        information only from the lowest level.  It uses the higher level
        records  only  to  locate  the  lower  level  ones and to provide
        identification.

        A class 3 report generates totals from the higher level  records.
        There  is a complication because a higher level record is part of
        many frames of data, one for each lower level  record  linked  to
        it.   A  special  technique  adds to a total once for each higher
        level record rather than once for each frame of data.


   REPORT GENERATION                                            Page 9-38
   Revision 4


   The following data sets represent sales information in a  company  and
   illustrate  these  types  of  reports.  The sales area is divided into
   territories.  The territories are ranked by size.

   Each salesman is assigned  to  a  territory  by  TERRITORY_CODE.   The
   dollar  volume  of  a  salesman's  work  in  the  previous  year is in
   LSTYR_SALES.

   A SALES record is a transaction with a customer.  Each transaction  is
   identified  by  the  customer, invoice number, the amount of sale, and
   the salesman.  There may be  many  SALES  records  for  one  customer,
   representing many transactions.

   TERRIT is linked to SALSMN by TERRITORY_CODE.   SALSMN  is  linked  to
   SALES by SLSID.

   The data set descriptions are as follows:


             TERRIT  --  Territory information
              
           .--> ATTRIBUTE TERRITORY_CODE LENGTH  2 INTEGER KEYED
           |                   ! Territory code number
           |    ATTRIBUTE TERRITORY_NAME LENGTH 30
           |                   ! Territory identification
           |    ATTRIBUTE TERRITORY_SIZE LENGTH  4 INTEGER
           |                   ! The rank of the territory
           |  
           |  
           | SALSMN  --  The salesmen in the company.
           |  
        .=====> ATTRIBUTE SLSID LENGTH  3 INTEGER KEYED
        |  |                   ! Salesman's number
        |  '--> ATTRIBUTE TERRITORY_CODE LENGTH  2 INTEGER KEYED
        |                      ! Territory for the salesman
        |       ATTRIBUTE SNAME LENGTH 20         KEYED
        |                      ! Salesman's name
        |       ATTRIBUTE LSTYR_SALES LENGTH  8 INTEGER
        |                      ! Sales last year
        |     
        |     
        |    SALES  --  A record for each sale to a customer.
        |     
        |       ATTRIBUTE CUST_NAME LENGTH 20         KEYED
        |                      ! Customer's name
        '=====> ATTRIBUTE SLSID LENGTH  3 INTEGER KEYED
                               ! Salesman's number
                ATTRIBUTE INVOICE LENGTH  6 INTEGER KEYED
                               ! Invoice number
                ATTRIBUTE SALE_AMT LENGTH  8 INTEGER
                               ! Amount of this sale
   REPORT GENERATION                                            Page 9-39
   Revision 4


   The following examples contain numbers in parentheses in front of some
   commands.  These identify the commands in the discussions which follow
   and are not part of the command;  they do not appear in the text of an
   actual report program.

   Note how these examples locate records  and  manipulate  values.   The
   report  output  from each ON CHANGE level is just group information as
   in a simple report program.  The content of these examples  shows  how
   to  write the report so that totals are generated easily with standard
   ON CHANGE commands.



   9.13.1  Class 1:  Investigating Other Data Sets

   A class 1 report is structured by one data set  and  uses  other  data
   sets to supply additional information.

   The following report program examines the salesmen of the company  and
   prints  each  name,  territory,  and  total sales.  The SALES data set
   provides the total sales, and the TERRIT data set provides the name of
   the salesman's territory.


   REPORT GENERATION                                            Page 9-40
   Revision 4


             OPEN SALSMN SALES TERRIT.
             FIND ALL.
             SORT BY TERRITORY_CODE SNAME.

             REPORT START.
             SECTION INITIAL.
                 DEFINE INTEGER SALESTOT.
         (1) SECTION GETREC.
             SECTION HEADING.

                 DBSET SALSMN.
             (2) ON CHANGE TERRITORY_CODE GOTO NEWTERR. GOTO CONT1.
   NEWTERR:      MAP TERRIT VIA TERRITORY_CODE.
                 PRINT TERRITORY_NAME. ! This is the heading.
   CONT1:
             SECTION PRINT.

             (3) DBSET SALSMN.
                 MAP SALES VIA SLSID.
                                 ! Locate all sales for this salesman.
                 EVALUATE SALESTOT EQ TOT SALE_AMT.
                                 ! Generate the sales total.
                 DBSET SALSMN.
                 PRINT SNAME SALESTOT.
                                 ! Each detail record is a salesman
                                 !   with his sales total.

             SECTION TOTALS.
                 DBSET SALSMN.
             (4) ON CHANGE TERRITORY  PRINT TERRITORY_NAME TOT SALESTOT.
                                 ! Summarize sales by territory.
             (5) ON END PRINT TOT SALESTOT.

             SECTION FINAL.
             REPORT END.



   Discussion:

   (1)  Section Getrec has no statements in it.  SALSMN  is  the  current
        data  set  because  SALSMN is first in the OPEN command.  Section
        Getrec automatically selects the  next  SALSMN  record  for  each
        report cycle.  Class 1 reports are structured by one data set.

   (2)  This ON CHANGE detects the beginning of the next sales territory.
        The report program MAPs the territory code to the TERRIT data set
        to select a record with the territory name in  it.   The  heading
        for territory prints this name.

   REPORT GENERATION                                            Page 9-41
   Revision 4


   (3)  Each detail line of the report prints  the  salesman's  name  and
        total  sales.   The  report program places the total sales figure
        into SALESTOT by MAPping to SALES and EVALUATing the total.

        The MAP and EVALUATE are local operations which do not affect the
        overall  structure  of  the  report.  The report program could as
        easily MAP and PRINT all the SALES records for each salesman, and
        print totals as well.

   (4)  This ON  CHANGE  summarizes  a  territory.   It  properly  totals
        SALESTOT  because  SALESTOT is assigned in Section Print for each
        salesman record.

   (5)  The final totals are generated by similarly totalling SALESTOT.



   9.13.2  Class 2:  Structuring A Report With Two Data Sets

   A class 2 report is structured by two or more  linked  data  sets.   A
   frame  of  data  contains  both a "parent" record and a "child" record
   from the hierarchy.  The report program cycles once for  each  "child"
   record to detect subgroups within them.

   The following report program examines the customer  records  for  each
   salesman.   There  may  be many records for each customer;  the report
   summarizes the  customer  records  and  reports  one  total  for  each
   customer.   This  report  is class 2 because it examines the detail of
   the customer records and places them into subgroups.


   REPORT GENERATION                                            Page 9-42
   Revision 4


|            OPEN SALSMN SALES TERRIT.
             FIND ALL.
         (1) SORT BY TERRITORY_CODE SNAME.

             REPORT START.
             SECTION INITIAL.
             (2) DBSET SALES. FIND SYSID 0.

             SECTION GETREC.
             (3) GOTO NEXT_CUST.

   NEXT_SLSMN:   DBSET SALSMN.
                 GETREC END_REPORT.
                 MAP TO SALES VIA SLSID.
                 SORT BY CUST_NAME.

   NEXT_CUST:    GETREC NEXT_SLSMN.

             SECTION HEADING.

             (4) DBSET SALSMN.
                 ON CHANGE TERRITORY_CODE GOTO NEWTERR.  GOTO CONT1.
   NEWTERR:      MAP TERRIT VIA TERRITORY_CODE.
                 PRINT TERRITORY_NAME.
   CONT1:
             (5) ON CHANGE SLSID PRINT SNAME SLSID.

         (6) SECTION PRINT.
   END_REPORT:
             SECTION TOTALS.

             (7) ON CHANGE CUST_NAME PRINT CUST_NAME  TOT SALE_AMT.

             (8) ON CHANGE SLSID PRINT TOT SALE_AMT.

             (9) ON CHANGE TERRITORY_CODE PRINT TOT SALE_AMT.

            (10) ON END PRINT TOT SALE_AMT.

             SECTION FINAL.
             REPORT END.



   Discussion:

   (1)  The salesman records are  grouped  by  territory  and  appear  in
        alphabetic order by salesman's name.

   REPORT GENERATION                                            Page 9-43
   Revision 4


   (2)  FIND SYSID 0 finds no records and clears the selection  group  in
        the SALES data set.  This is necessary for the first execution of
        Section Getrec in this report program.

   (3)  Section Getrec is the heart of a class 2  report.   This  is  the
        best  design for examining two data sets in a hierarchy to select
        the next "parent" and "child" pair of records.

        Control goes to label NEXT_CUST  each  time  the  report  program
        executes  Section Getrec.  The current data set at that statement
        is SALES, determined by the MAP command just above.   The  GETREC
        at  NEXT_CUST  selects  the  next  SALES  record  for the current
        salesman.  Control goes to NEXT_SLSMN  when  there  are  no  more
        SALES records for that salesman.  Control goes to Section Totals,
        to the label END_REPORT, when the SALSMN records are exhausted.

        The action of Section Getrec usually is to select the next  SALES
        record.  Sometimes, a new SALSMN record is selected and MAPped to
        new SALES records.  These are  sorted  into  customer  groups  in
        preparation  for  processing.   Then  the  first  SALES record is
        selected for that salesman, and a cycle begins.

        This Section Getrec starts the report in a convenient  way.   The
        first  execution  of  the  section  finds that there are no SALES
        records, guaranteed by  the  initial  FIND  at  (2).   Therefore,
        control  goes  to  select  the  first SALSMN record, and then the
        first qualifying SALES record.  The ordering  of  the  statements
        eliminates  the  need  for any special tests for the beginning or
        end of the report program execution.

        There must be no records selected in SALES  when  Section  Getrec
        first  executes.  This usually follows from OPENing SALES and not
        needing to select any records in it.  Specifically  clearing  the
        selection  group  in  Section  Initial  is necessary for PRETOTAL
        reports.  The report program  will  process  some  SALES  records
        twice during the second pass unless the leftover records from the
        first pass are cleared as shown in Section Initial.

   (4)  This ON CHANGE command detects the beginning of a  territory  and
        triggers  a  MAP  to retrieve the name of the territory using the
        numeric code.

   (5)  This ON CHANGE prints the heading for the salesman groups.

   (6)  Section Print is empty.  There  are  no  detail  lines  to  print
        because  the  lowest  level of the report is a summary of records
        for customers, not individual records.

   REPORT GENERATION                                            Page 9-44
   Revision 4


   (7)  This ON CHANGE detects a change in the  customer.   This  divides
        the  records  for any salesman by customer, a finer division than
        all SALES records for that salesman.  The value SALE_AMT from the
        SALES records is available for totalling and printing.

   (8)  This ON CHANGE divides the report by  salesman.   The  expression
        TOT SALE_AMT  yields  the  total  for  the  salesman  because  it
        includes each SALES record which belongs to that salesman.

   (9)  This is an ON CHANGE similar to (8) but at  the  territory  group
        level.

   (10) This is an ON CHANGE similar to (8) but at the grand total level.



   9.13.2.1  A Report Structured At Three Levels

   The organization of a three level hierarchical report  is  similar  to
   that  of  the  two  level report above.  Section Getrec is expanded to
   look at three data sets.

   The following report program fragment reports on sales by customer  in
   decreasing  order of territory size rather than in increasing order of
   territory number.  Only the beginning is  presented  in  the  example;
   the end of the report program is identical to the previous example.

   REPORT GENERATION                                            Page 9-45
   Revision 4


             OPEN TERRIT SALSMN SALES.
             FIND ALL. SORT BY TERRITORY_SIZE DESCENDING.

             REPORT START.
             SECTION INITIAL.

                DBSET SALSMN. FIND SYSID 0.
                DBSET SALES. FIND SYSID 0.

             SECTION GETREC.

                GOTO NEXT_CUST.

   NEXT_TERR:   DBSET TERRIT.
                GETREC END_REPORT.
                MAP TO SALSMN VIA TERRITORY_CODE.
                SORT BY SNAME.

   NEXT_SLSMN:  GETREC NEXT_TERR.
                MAP TO SALES VIA SLSID.
                SORT BY CUST_NAME.

   NEXT_CUST:   GETREC NEXT_SLSMN.

             SECTION HEADING.
             .
             .
             .



   Discussion:

   Section Getrec of this example operates in the same  way  as  the  two
   level  sales  example.   An  extra  GETREC and MAP portion is added to
   handle the additional level of structure needed to retrieve records by
   territory size.

   Attributes from all three data sets may be referenced  in  the  report
   program.
   REPORT GENERATION                                            Page 9-46
   Revision 4


   9.13.3  Class 3:  Hierarchical Totals

   A class 3 report is a class 2 report with an  additional  requirement;
   totals are derived from more than one hierarchical level.

   The previous sales report program becomes a  class  3  report  if  the
   report program totals a value from the SALSMN records.

   The SALSMN records are not at  the  lowest  level  in  the  hierarchy.
   There  are  many frames of data for each SALSMN record.  An expression
   TOT LSTYR_SALES would produce a total that is multiplied by the number
   of SALES records for that salesman.

        For example, consider the following attributes from the data sets
        SALSMN and SALES:

        SALSMN                       SALES        ______                       _____

        SNAME    SLSID   LSTYR       CUST         SLSID  INVOICE SALE
                         SALES       NAME                        AMT

        Jackson  037     123,000     AJAX CO      037    000162  450.00
                                     AJAX CO      037    000248  320.00
                                     AJAX CO      037    000360  130.00

                                     INTERART     037    000120   35.00
                                     INTERART     037    000211  180.00
                                     .
                                     .


        The above records  illustrate  the  relationship  between  SALSMN
        records  and SALES records.  Salesman Jackson has many customers,
        each with many transactions.  The previous class 2 report program
        example  selects  a  SALSMN record and an associated SALES record
        for each report cycle.

        Jackson is associated with AJAX 000162 for the first cycle,  with
        AJAX 000248  for  the  second  cycle,  and so on.  When Jackson's
        customer records are exhausted, the report  program  selects  the
        next salesman and associates him with his first customer recor                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                

   REPORT GENERATION                                            Page 9-48
   Revision 4


   (3)  Territory is the next larger group than salesman.   This  is  the
        first  level  at  which the values from the SALSMN records can be
        totalled.  The  expression  TOT S_SALES  produces  the  total  of
        LSTYR_SALES   from  the  salesman  records,  and  the  expression
        TOT S_COUNT produces the count of the SALSMN records.

   (4)  This ON CHANGE does the same totals as in (3) at the grand  total
        level.

   (5)  This statement works with (2) to provide  proper  values  in  the
        variables.   The  variables  have  a  nonzero value only during a
        cycle which is  the  last  SALES  record  for  a  salesman.   The
        variables  are  set  to  zero at the end of each cycle and remain
        zero until the end of the next salesman group.



   9.14  REPORT EXECUTION SEQUENCE

   A report program is divided into sections so  that  the  sections  can
   appear  in  a  natural  order  but execute in a different order.  1022
   operates between sections to coordinate the report  functions  and  to
   trigger the ON CHANGE commands.

   The report program  executes  in  the  following  way  except  at  the
   beginning  and  end of the report.  The left hand margin shows actions
   that the user sees;  the indented margin shows actions which are  done
   by 1022.

   REPORT GENERATION                                            Page 9-49
   Revision 4


   SECTION GETREC

     Select the records which control the groups in the report.

                       Examine the values and  records  selected  by  the
                       user.   Evaluate  the  ON  CHANGE  expressions  to
                       detect  group  boundaries.   Set  the  ON   CHANGE
                       triggers   for  later  execution.   Establish  the
                       previous record(s) for evaluation  of  expressions
                       in Section Totals.

   SECTION TOTALS

     Control passes through the ON CHANGE commands which act if they have
     been  set  to  trigger.   Values are added into the totals for later
     printing or evaluation.  Values of  attributes  refer  to  the  last
     record of a group.

                       Establish the current record(s) for evaluation  of
                       expressions.

   SECTION HEADING

     Control passes through the heading ON  CHANGE  commands  to  produce
     introductions for the groups which have changed.

   SECTION PRINT

     Print values from current record(s) and set variables for totalling.
     The  current  record will be the previous record when Section Totals
     next executes.

   (SECTION GETREC)

     Control returns to Section Getrec for another cycle of  data.   This
     repeats  until  the  report ends by exhausting the records which are
     retrieved in Section Getrec.


   The execution of Section Totals is omitted for the first report cycle;
   there  can  be  no  previous groups for which to print summaries.  The
   report program ends after Section Totals executes for the last record.

   The report program keeps two  records  for  each  cycle,  the  current
   record selected by Section Getrec and the previous record selected the
   time before.  The previous record is used to print values  in  Section
   Totals.  The current record(s) and variables determine which ON CHANGE
   commands trigger during this cycle.
   REPORT GENERATION                                            Page 9-50
   Revision 4


   9.15  CUSTOM REPORTS

   This section explains how to get full  value  out  of  the  ON  CHANGE
   command  and the 1022 totals functions to produce custom reports.  The
   example explains how to use variables in ON CHANGE control expressions
   and in System totals generated by those ON CHANGE commands.

   Control over the ON CHANGE expressions is control over how the records
   of a report are grouped.  In the following command:

        ON CHANGE DIVISION PRINT...

   the ON CHANGE expression, the "trigger expression", is  the  attribute
   DIVISION.  In most data sets there is an attribute like DIVISION which
   divides the records into groups.   A  variable  is  used  as  a  break
   expression when the desired record group is not determined by a simple
   value for any attribute in the data set.

   Consider the problem of grouping payment records by quarter using  the
   date of payment.  For example:

                  DEFINE INTEGER AMNT(4) COUNT.
                  DEFINE DATE QTR(4).
                  LET QTR(1) "3/31/78" QTR(2) "6/30/78" QTR(3)
                     "9/30/78" QTR(4) "12/31/78".

                  REPORT START.
                  SECTION INITIAL.
                  FIND INVDATE BETWEEN 1/1/78 AND 12/31/78.
                  SORT BY CUSTNO INVDATE.

                  SECTION GETREC.
                  LET I EQ 1.
        L1:       IF INVDATE LE QTR(I) THEN HDNG.
                  LET I EQ I+1.  IF I LE 4 THEN L1.
                     PRINT "RECORD OUT OF BOUNDS".  !Shouldn't happen.

        HDNG:     SECTION HEADING.

                  SECTION PRINT.
                  LET IOLD EQ I.

                  SECTION TOTALS.

                  ON CHANGE I EVALUATE AMNT(IOLD) EQ TOT BILLAMNT.
                                            !Use the variable I to
                                            !   distinguish quarterly
                                            !   groups.

   REPORT GENERATION                                            Page 9-51
   Revision 4


                  ON CHANGE CUSTNO PRINT CUSTNAME CUSTNO
                     AMNT(1) AMNT(2) AMNT(3) AMNT(4)
                     TOT BILLAMNT.
                                            !Print the totals when the
                                            !   customer changes.


                  ON CHANGE CUSTNO
                     EVALUATE AMNT(1) EQ 0 AMNT(2) EQ 0 AMNT(3) EQ 0
                     AMNT(4) EQ 0 COUNT EQ 1.
                                            !Clear the AMNT array for the
                                            !   next group when customer
                                            !   changes.

                  ON END PRINT TOT BILLAMNT TOT COUNT.
                  LET COUNT 0.

                  SECTION FINAL. REPORT END.

   The report needs a value which changes only when the quarter  changes,
   to  divide  properly  the  payment  records.  The above Section Getrec
   produces this value in the integer variable I.   Section  Getrec  does
   not contain a GETREC command, thus 1022 selects the next record before
   entering the section.  The small loop at label  L1  uses  the  quarter
   boundaries  to divide the payment dates into quarters.  The variable I
   is set to the quarter number before control passes to the  label  HDNG
   at the start of Section Heading.

   I is constructed for use in Section Totals in the statement ON  CHANGE
   I  EVALUATE  --.   The  value  of  I is assigned just after the newest
   record is selected, so its value can be used to  detect  the  boundary
   between different groups.  Section Getrec provides a place to set such
   "new" values so that the report  program  may  determine  when  groups
   change.

   This same ON CHANGE statement uses a technique which  distributes  the
   four possible quarterly amounts into four positions in the array AMNT.
   The assignments in an ON CHANGE EVALUATE command are done only at  the
   time the change occurs.  The amounts go into different array positions
   because the subscript of the array changes in time for the assignment.
   The  automatic  totalling  and  clearing  functions  of  the ON CHANGE
   statement keep the subtotals by quarter separate from each other.

   The variable IOLD is a subscript instead  of  the  variable  I.   This
   illustrates  a rule about assigning values to variables and using them
   in Section Totals of a report.  The value of I is assigned from values
   in  the  newest record before any totals breaks occur.  Section Totals
   operates one record behind the  newest  record  retrieved  in  Section
   Getrec.  Thus, commands in Section Totals refer to the previous group,
   not the next group.  The value of I is too new to control  the  totals
   for the previous group;  the subscript must be the value of I that was
   around on the last cycle of the report.
   REPORT GENERATION                                            Page 9-52
   Revision 4


   The proper value is saved by assigning the  value  of  I  to  IOLD  in
   Section  Print.   Section  Print executes after group totals have been
   done for the previous group.  The value of I in IOLD will be the value
   for the last record when Section Totals sees it next.

   These  are  the  rules  about  variable  assignments.    The   trigger
   expressions  in  ON CHANGE commands require "new" values to detect the
   appearance of a new  group.   Any  variables  used  in  them  must  be
   assigned  in  Section  Getrec.   The  totalling  expressions and array
   indexes require the "last" value.  1022  automatically  arranges  this
   for  attribute references.  Variables which are used in Section Totals
   for values and indexes must be assigned their value in Section Heading
   or Section Print.  They may be assigned their values in Section Totals
   when their value is derived only from attributes  and  from  variables
   already assigned their values in Section Heading or Section Print.


   The ON CHANGE CUSTNO PRINT command uses the values assigned in the  ON
   CHANGE  I  command.   The  expression  TOT BILLAMNT produces the total
   billing for the customer, because it totals the contributions from all
   customer  records regardless of quarter.  Equivalently, the expression
   could be written AMNT(1)+AMNT(2)+ AMNT(3)+AMNT(4) to do this.


   The ON CHANGE CUSTNO EVALUATE command does two tasks for each customer
   group.  The first task is to clear the entries in the AMNT array.  Old
   values from the previous group would remain if the next group did  not
   have  values  in  all four quarters.  AMNT is cleared after the values
   have been used and before the next group begins.

   The second task is to construct a count flag in the variable COUNT  to
   use  in  forming the number of different customers in the report.  The
   command sets COUNT equal to 1 each time the customer changes, not  for
   each  record  of that customer.  The LET COUNT 0 command at the end of
   Section Totals keeps the COUNT variable 0 unless it is set again to  1
   by a new customer.


   The ON END command uses the COUNT variable  and  illustrates  how  the
   values  of  variables  may  be manipulated in Section Totals.  The TOT
   BILLAMNT expression produces a grand total  for  all  amounts  billed,
   because  amounts  from all records participate in this total.  The TOT
   COUNT expression produces the number of customers in the report.   The
   expression  TOT  1 counts the number of records in the report, not the
   smaller number of different customers.  The  variable  COUNT  has  the
   value  1  when control passes through the ON END statement only when a
   customer is finishing; otherwise it is zero.  The TOT COUNT expression
   totals many zeroes and a few 1's.


   These are the rules about ON CHANGE used in the  above  example.   The
   totals  produced  by ON CHANGE totals expressions depend on the values
   of attributes and variables at the time that the  statement  executes.
   REPORT GENERATION                                            Page 9-53
   Revision 4


   Programming  procedures control the values of attributes and variables
   that ON CHANGE statements "see" during the report.   These  procedures
   thus  control  the  type  of  totals  produced without duplicating the
   features available in the ON CHANGE commands.

   The following outline summarizes all the rules  about  assignments  to
   variables:

        I. On Change Trigger Expressions

           A. Are evaluated just after Section Getrec.

           B. May contain attributes and variables.

           C. The values of variables must be assigned in Section Getrec.

        II. On Change Totals Expressions

           A. Are formed from the values of attributes and variables each
              time  those  values  are  seen by the command during report
              program execution.

           B. Variables may be used  as  indexes  and  values  in  totals
              expressions.

              1. Assign the value of  a  variable  anywhere  but  Section                                                             ___
                 Getrec  when  it  is  derived  from attributes and other
                 variables of this type.

              2. Assign the value of a variable  in  Section  Heading  or
                 Section  Print  when  it is derived from variables whose
                 values are set in Section Getrec.

   For further information about the operation  of  report  programs  and
   more  examples  of  their  construction in complex situations, see the
   separate manual "Report Generator Operations and Examples".
   REPORT GENERATION                                            Page 9-54
   Revision 4















                                 CHAPTER 10

                              THE AUDIT TRAIL



   10.1  INTRODUCTION

   The AUDIT commands maintain journal files that permit you  to  recover
   data sets in the event of a computer crash or software failure.  These
   journal files are called audit trails.  An audit  trail  contains  the
   information  needed  to  restore a data set to its condition before it
   was damaged.

   Your application must be coordinated with the audit trail in order  to
   recover  automatically.   Your program must know what data has and has
   not been added to a data set so it may proceed after a recovery.   The
   program can write named checkpoints to identify its progress through a
   long update stream.

   The AUDIT commands provide functions other than  the  primary  one  of
   recovering  a  data set.  The data set may be interlocked from further
   use until action is taken after data set damage  is  detected.   Also,
   the  audit  trail  lists  when  updates  were  done  and  which  users
   controlled them.



   10.1.1  When To Use Audit Trails

   Not all data sets require audit trails.  The  expense  of  maintaining
   audit   trails  is  avoided  by  more  traditional  copy-before-update
   methods.  It is more efficient to copy the data set to tape first  and
   run  without audit when massive updating is to be done by a program in
   batch mode.  The copy is restored as the original and the job rerun if
   an error occurs.

   The audit trail is useful when updates will take such a long time that
   a  machine  failure  might  be  expected  during  the run.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                data   ___   __________
                     set  history  for possible use in restoring the data
                     set.  AUDIT CHECK  is  an  alternate  form  of  this                           ___   _____
                     command.

   AUDIT CLEAR       Turn off the AUTO mode of the audit trail;  auditing   ___   _____
                     is now manual, activated job by job.

   AUDIT COMMENT     Place a comment into the audit trail.   ___   _______

   AUDIT FORWARD     Restores a data set to a  previous  state  using  an   ___   _______
                     archive copy of the data set and post-images.

   AUDIT FIX         A simplified AUDIT BACKUP command, to  do  the  most   ___   ___
                     common backup for damaged data sets.

   AUDIT LIST        Print the audit information.   ___   ____

   AUDIT MERGE       Combine many separate audit files.   ___   _____

   AUDIT RECOVERY    Set the mode of recovery.  Recovery may be automatic   ___   ________
                     or manual.  Access to the data set may be restricted
                     until recovery is completed.

   AUDIT START       Start an audit file for this data set, and establish   ___   _____
                     the mode of the audit trail.



   10.2  TYPES OF AUDIT TRAILS

   System 1022 offers two types of  audit  trails:   roll  forward  using
   post-images and roll backward using pre-images.  You may choose to run
   either type or both.

   (1)  Roll  forward  audit  trails  are  series  of   post-images   and
       checkpoints.  A post-image is a picture of the data set after each                                                               _____
       change is made.  To use roll forward  to  recover  from  data  set
       damage,  you  take a copy of the undamaged data set, made when the
       audit trail was started, and make each change in that  copy  until
       the  checkpoint  just  before  damage  occurred.  The roll forward
       audit trail is similar to an incremental save in that it preserves
       every  change since a full save preserved the whole data set.  The
       data set is restored to  its  condition  at  the  last  checkpoint
       before damage.
   THE AUDIT TRAIL                                              Page 10-4
   Revision 4


          ROLL FORWARD                          
    -----------------------------------> 

   |_________________________________________________________________AUDIT
         ^                              ^                           ^TRAIL
         |                              |                           |
    checkpoint                       checkpoint                  DAMAGE

                   Figure 10-1: Roll Forward Audit Trail


   (2) Roll backward audit trails store pre-images.   A  pre-image  is  a
       picture  of  the  data  set  before each change is made.  The roll                                    ______
       backward audit trail is a series of  pre-images  and  checkpoints.
       To use roll backward to recover from data set damage, you take the
       damaged data set and undo each change  by  stepping  back  through
       each  pre-image  to the undamaged state.  The data set is restored
       to its condition at the last checkpoint before damage.


                                                ROLL BACKWARD
                                         <--------------------------

   |_________________________________________________________________AUDIT
         ^                              ^                           ^TRAIL
         |                              |                           |
    checkpoint                       checkpoint                  DAMAGE

                   Figure 10-2: Roll Backward Audit Trail





   10.2.1  Choosing Between Roll Forward And Roll Backward

   You choose to use audit trails with post-images, pre-images,  or  both
   when  you  give  the  AUDIT  START  command.   The  main reason to use
   post-images  and  roll  forward  is  to  provide  security  from  disk
   failures.   Roll  forward audit trails require that you have a copy of
   the data set in its unchanged state when  starting  the  audit  trail.
   The  audit  trail  file itself should be kept on a different disk from
   the one with the data set.  The main reason to use pre-images and roll
   backward  is to backup to the last checkpoint and restore the data set
   quickly.   This,  however,  does  not  provide  protection  from  disk
   failure.   Using  both  gives both advantages at the cost of increased
   overhead (writing both post-images and pre-images to the audit trail).
   THE AUDIT TRAIL                                              Page 10-5
   Revision 4


   10.3  AUDIT TRAIL FILES

   When constructing an audit system, you first decide where  each  audit
   trail  will  be  stored.   These  may  all  exist  in a single file, a
   separate file may be created for each audit trail, or a  single  audit
   trail  may  be  written into several files.  The greater the number of
   audit files used, the less contention there will be for access to each
   file.   However,  an  increased  number of audit files complicates the
   administration of the audit system.  We explain each of  the  possible
   storage schemes below.



   10.3.1  One Data Set To One Audit File

   In the simplest case, you direct 1022 to write one audit file for each
   data  set.   When many jobs update the data set, all audit information
   goes to one file.  Only that file is  used  for  this  data  set  when
   recovery  is  necessary.  System 1022 closes the audit file repeatedly
   so that other jobs may access it.



   10.3.2  One Data Set To Many Audit Files

   The JOB option of the AUDIT START command gives each job updating  the
   data  set its own audit file, with a name derived from the job number.
   Then, there is no contention between jobs  for  access  to  the  audit
   file,  and  fewer  operations are spent closing the audit file between
   updates.  A disadvantage is that many audit  files  will  be  created,
   even  when  just  one  process at a time updates the data set, because
   that process will have different job numbers each time it is run.   It
   is  necessary  to gather together all the audit files created for this
   data set with the AUDIT MERGE command when recovery is required.



   10.3.3  Many Data Sets For One Audit File

   One file may record audit trail information from many data sets.  This
   is  usually  done  where  many  data  sets  form one data base and are
   updated together.  In  this  mode  there  is  the  maximum  contention
   between  users of the separate data sets for access to the audit file.
   When the many data sets are opened together for processing,  there  is
   no  more  contention  than if separate audit files were used.  One I/O
   channel is needed to maintain the audit information for all  the  data
   sets.   The  single  audit  file is processed against each data set in
   turn when recovery is needed.
   THE AUDIT TRAIL                                              Page 10-6
   Revision 4


   10.3.4  Mixtures Of Audit Modes

   The above modes may be mixed in any application.  It may be  that  one
   data  set,  in  a multiple data set data base, deserves JOB treatment,
   while all the other data sets use only one audit file for  simplicity.
   A   recovery   can  be  done  by  gathering  together  all  the  audit
   information.



   10.4  OPERATION

   You may select from the following  types  of  audit  file  access  for
   recording  audit  trail  information.  These set the degree to which a
   data set is tied to an audit file and the  efficiency  of  maintaining
   the audit file.



   10.4.1  Audit On Demand

   System 1022 opens the audit file only when  necessary  and  closes  it
   when  an  update  is  complete.   It  anticipates that other jobs need
   access to the file to carry out updates.

   Audit trail creation  and  maintenance  may  be  either  automatic  or
   manual.   The  automatic  mode is activated by the AUTO keyword in the
   AUDIT START command and is the recommended mode for maintaining  audit
   files  with many users.  It remains in effect until ended by the AUDIT
   CLEAR command.

   In AUTO mode all updates are recorded in the file without any  special
   actions  by  that job.  AUTO assures that all jobs make entries in the
   audit file and that the data set can be restored when necessary.

   The use of the audit file is manual when AUTO is  not  specified.   In
   manual  mode,  each job must issue an AUDIT START to turn on auditing.
   Auditing will remain in effect for that run only.  The auditing ceases
   when  the  data  set  is closed.  A job which updates the data set and
   does not turn on auditing will not leave a trail in  the  audit  file.
   Should  this  happen,  the  audit file is useless and cannot correctly
   restore the data set.  We recommend audit trails in manual mode when a
   single user wishes to protect against error in a single update run.
   THE AUDIT TRAIL                                              Page 10-7
   Revision 4


   10.4.2  Audit With Locked Audit File

   When you use the LOCKED option in the AUDIT  START  command,  the  job
   opens  the audit file and keeps it open for updating.  This results in
   less overhead than with audit on demand.

   Locking the audit file  locks  out  other  users  from  all  data  set
   operations  when  a  single  audit  file  is  used for a data set.  If
   auditing is in effect for other users  (AUTO  mode),  then  they  must
   access  the  audit file when they open the data set.  They will not be
   able to open the data set when audit file access is denied because one
   job  has  locked the data set.  If the mode is MANUAL, then other jobs
   may query and even update the data set, but these updates  will  occur
   outside the protection of the audit system and cannot be restored from
   the current audit file.

   This interlock effect is  strengthened  when  many  audit  trails  are
   written  to  one  physical file.  Locking any one audit file will lock
   out all the data  sets  which  write  their  audit  trails  into  that
   physical  file.   Normally,  a job expects to have exclusive access to
   all the associated data sets  and  will  lock  all  the  audit  trails
   written to one audit file.

        Do not depend on this  multiple  file  effect  of  LOCK.   Future
        versions  of  System 1022 will not lock all data sets when one is
        locked.  Use an appropriate audit command on all data  sets  that
        you access.

   Use the JOB option to get the efficiency of  locking  open  the  audit
   trail, while allowing multiple access to the data set.  The JOB option
   causes each job to have its own audit file for that  data  set.   This
   file  is  kept  open  and ready to record update transactions, without
   interference from other users of the data set, when LOCK is used  with
   JOB.  The LOCK, JOB and AUTO clauses are commonly used together.



   10.4.3  Audit Entries For Readonly Access

   In AUTO mode any job which opens the data set makes an entry into  the
   audit  trail by default.  The audit trail records every opening of the
   data set and every change.  The  NOREAD  clause  of  the  AUDIT  START
   command  excludes  readonly  openings  of  the data set from the audit
   trail journal.

   Use AUDIT START AUTO without the NOREAD clause to record all access to                        _______
   a data set.  Use the NOREAD clause to write a shorter audit trail that
   still provides for full recovery.  The NOREAD clause  offers  improved
   efficiency  for readonly jobs which are spared the overhead of writing
   the audit trail.  The NOREAD clause is significant only when used with
   the AUTO clause.
   THE AUDIT TRAIL                                              Page 10-8
   Revision 4


   10.4.4  Checkpoints

   A checkpoint is an entry in the audit trail indicating that  the  data
   set  is  stable.   It  is generated automatically in a pre-image audit
   trail  just  before  1022  begins  an   update.    It   is   generated                ______
   automatically in a post-image audit trail just after 1022 completes an                                                  _____
   update.  And it may be generated by your request at any time.   System
   1022   may  have  updated  information  in  temporary  memory  between
   checkpoints that has not yet been written to the  data  set.   If  the
   update  operation  stops  abnormally  (due  to  hardware  or  software
   failure), there will be inconsistencies in the data set.

   A continuous update sequence begins when the user  issues  UPDATE  ON,
   and  it  ends at UPDATE OFF or when the data set is closed.  If UPDATE
   ON - UPDATE OFF is not used, then each command that updates  the  data
   set  is  a  complete  update sequence in itself.  A checkpoint will be
   generated just before or after the update, in both cases.

   The AUDIT CHECKPOINT command writes a checkpoint.  Use it to  generate
   checkpoints inside an UPDATE ON - UPDATE OFF sequence, and to generate
   checkpoints  with  user  assigned  names.   The  word  CHECK  may   be
   substituted for CHECKPOINT when it appears in a command.  An automated
   procedure generates named checkpoints that are  related  to  the  data
   stream  used  for  the  updates.   Use  of  AUDIT  CHECKPOINT  is more
   efficient than creating a checkpoint by  issuing  extra  UPDATE  ON  -
   UPDATE OFF commands.

   A checkpoint is a state where everything is consistent as far  as  the
   disk management software is concerned.  It is not a guarantee that the
   data set is undamaged at that point.  Errors  in  the  data  set  that
   existed  at  the  time the checkpoint was written will still be in the
   data set.  It may be necessary to backup over more than one checkpoint
   to correct longstanding errors that were previously unnoticed.



   10.4.5  Recovering Damaged Data Sets

   The AUDIT RECOVERY command  sets  up  the  rules  for  the  manual  or
   automatic  recovery  of a data set.  The AUDIT BACKUP or AUDIT FORWARD
   command does the actual recovery.  AUDIT FIX is a convenient  form  of
   the  AUDIT  BACKUP  command  for the most common case of backup to the
   last checkpoint.
   THE AUDIT TRAIL                                              Page 10-9
   Revision 4


   10.4.5.1  The Roll Forward Or Backward Operation

   The roll forward procedure applies the post-image  audit  trail  to  a
   copy  of  the  data  set  made  when  the audit trail was started.  It
   restores the data set to its condition at any  checkpoint.   The  roll
   backward procedure uses the pre-image audit trail information to bring
   the data set  back  to  its  condition  at  the  time  of  a  previous
   checkpoint.   The checkpoint to attain is identified by its checkpoint
   number, or the name given to the checkpoint  in  an  AUDIT  CHECKPOINT
   command, or by its relative position in the current audit trail.  Most
   backups go backward just one checkpoint to erase damage from the  last
   computer crash.

   The user is protected from a bad  recovery  operation.   It  might  be
   worse  to  start  a  recovery that cannot succeed, than to correct the
   damage by rekeying, or dumping and loading a new data set.  A recovery
   would  fail if the audit file did not contain a complete record of the
   transactions that  occurred  since  (roll  backward)  or  until  (roll
   forward)  the  desired  checkpoint.  This happens if some of the audit
   files pertinent to the data set are not  merged  together  (see  AUDIT
   MERGE), or if the data set is updated outside the audit system.

   System 1022 protects the user  by  examining  the  audit  file  before
   starting the physical recovery.  System 1022 verifies that all entries
   necessary to do the recovery exist in the file.  If  any  entries  are
   missing,  an  error  message  is  produced  and  the  data set is left
   unchanged.   The  recovery   proceeds   immediately   after   a   good
   verification.


   There is a chance that the computer will crash while a recovery is  in
   progress.   This  does  not harm anything.  The AUDIT FORWARD or AUDIT
   BACKUP command can be repeated any number  of  times  if  interrupted.
   When  the  recovery  finally  succeeds,  the  data  set  is  restored.
   However, the data set will be in a  highly  damaged  state  until  the
   recovery is finished.

   The user may wish to write out  new  information  from  the  data  set
   before  doing  the  recovery,  because  a  recovery  removes  all  new
   information from the data set since the desired checkpoint.  Damage to
   a 1022 data set is usually concentrated in the KEY structures and does
   not affect the ability to write out the data records last changed,  if
   it is possible to locate those records.
   THE AUDIT TRAIL                                             Page 10-10
   Revision 4


   10.5  AUDIT QUICK FIX

   A common case of backing up a data set is done easily by the AUDIT FIX
   command  with a pre-image audit trail.  AUDIT FIX backs up to the most
   recent checkpoint.  Use it just after a crash to establish the  latest
   possible  version  of the data set that is consistent.  It is a simple
   means for any user to do a backup operation without  remembering  much
   about the more complicated AUDIT BACKUP command.

   AUDIT FIX does nothing if the data set is not damaged.  The  data  set
   is  damaged  if  an update sequence is interrupted.  A later update to
   the data set, after damage, establishes a later checkpoint.  AUDIT FIX
   always  stops at the last checkpoint.  Use the AUDIT BACKUP command to
   attain any earlier checkpoint, and check the data set damage  flag  to
   know when damage is removed.

   AUDIT FIX may be issued by any qualified user, to backup the data  set
   to  the  most  recent  checkpoint,  when many update users are writing
   audit trails under the JOB option.  This may be done  without  merging
   together  the  many  audit files that will exist under the JOB option.
   The proper individual audit file is selected by 1022 to do the backup.

   AUDIT FIX, like other backups, removes updates  done  since  the  last
   checkpoint.  Usually this will be only the update in progress when the
   interruption occurred.  The updates removed when  there  are  multiple
   users are the ones last done by the user in control of the data set at
   the moment of the system crash.



   10.6  ADMINISTERING RECOVERY

   The AUDIT RECOVERY command sets rules to control  who  can  recover  a
   damaged  data  set,  whether this recovery is automatic or manual, and
   what can be done with a damaged data set before a recovery is done.



   10.6.1  Who Can Recover A Data Set

   Any user having global update privileges may issue the  AUDIT  FORWARD
   or  AUDIT BACKUP command.  This performs a recovery unless the user is
   further restricted by the current rules of  an  AUDIT  RECOVERY  ALLOW
   clause.

   When a data set is undamaged, any update privileged user can recover a
   data  set.  Since there is no damaged condition, there can be no AUDIT
   RECOVERY ALLOW interlock (see later).

   Any user may trigger the automatic recovery of the data set  when  the
   AUDIT  RECOVERY MODE is AUTO.  The next user to open the data set will
   start the automatic recovery if the data set is damaged, provided  the
   user's job has write privileges to the physical data set file.
   THE AUDIT TRAIL                                             Page 10-11
   Revision 4


   10.6.2  Automatic Or Manual Recovery

   1022 takes no automatic action when the AUDIT RECOVERY MODE is MANUAL.
   Restrictions  given  in  the  ALLOW  clause  come into effect, and the
   recovery of the data set is left for  a  knowledgeable  user.   MANUAL
   mode  gives  the option of examining the data set and deciding what to
   do.  It may be desirable to write out information last  added  to  the
   data set before doing a recovery which will remove that information.

   The IGNORE DAMAGE command  releases  the  data  set  from  any  damage
   interlock and allows it to be processed normally.  The internal damage
   (if any) is not repaired, but the restrictions of the ALLOW clause are
   removed.   This  may  be  useful in rare cases where the administrator
   chooses to continue operating with a  damaged  data  set  rather  than
   recover the earlier state and lose the latest transactions.


   Quick recovery of the data set is desired when the AUDIT RECOVERY MODE
   is  AUTO.  A recovery is started when the next user opens the data set
   and has the physical right to modify the data set file.

   System 1022 first performs an AUDIT FIX command to  restore  the  data
   set to the last checkpoint.  Then, everything returns to normal if the
   damage is cleared.  If the data set still  records  damage  after  the
   simple backup, the conditions of the ALLOW clause remain in effect and
   manual intervention in the data set is required.



   10.6.3  Restricting A Damaged Data Set

   Restrictions on the use of a damaged data set are  set  by  the  ALLOW
   clause  of  the  AUDIT  RECOVERY  command.   Access can be unaffected,
   restricted  to  queries   only,   or   restricted   completely.    The
   restrictions  remain  unchanged  until a new AUDIT RECOVERY command is
   specified.  The restrictions are enforced whenever  the  data  set  is
   damaged.

   The owner of the data set is always  permitted  to  change  the  ALLOW
   restrictions,  so  a complete lockout is impossible.  An ALLOW NOTHING
   clause prevents any action on the data set until the owner changes the
   restrictions  or removes the damage condition.  Other actions, such as
   INFORM and OPEN, are not locked.
   THE AUDIT TRAIL                                             Page 10-12
   Revision 4


   10.7  RESOURCES USED BY AUDIT

   Maintaining an audit file uses extra resources.  For  the  query  user
   these  are  minimal.   When the data set is opened an entry is usually
   made which requires opening the audit file and  writing  once  to  the
   disk.   The  audit  file  is  then  released,  does  not occupy an I/O
   channel, and is not accessed again.  With the  NOREAD  clause  of  the
   AUDIT START command, no entry is made for readonly access.

   Each update request opens the audit file  and  makes  the  appropriate
   entries  when  the  audit  file  is not LOCKED open.  Then the file is
   closed, under the assumption that other jobs may need access.

   When an audit file is LOCKED open, the file is opened once and remains
   continuously  available  to  the  job.   Some  time  is  saved  by not
   reopening the file many times.  Additional time is saved because  1022
   can  retain  information  about  the  audit file that would ordinarily
   require a disk read after each open.  When  audit  is  in  effect  and
   UPDATE  ON is issued for the data set, the audit file is automatically
   LOCKED open during the updating.  The audit file for an ENQ  data  set
   is also and ENQ file.

   Maintaining the audit files will approximately double  the  number  of
   disk accesses in update operations.

   The backup operation  will  deallocate  any  blocks  added  since  the
   attained  checkpoint  when  backing  up a DMS file containing a single
   data set.  Roll forward never deallocates blocks.   If  multiple  data
   sets exist in the data set file, recovered blocks are not deallocated,
   resulting in "lost" blocks in the data set file.  The user  must  dump
   and rekey the data set if this extra space is unacceptable.



   10.8  DELETING AUDIT FILES

   Audit files will eventually become large since 1022  does  not  delete
   information  from them.  The user should delete all the files that are
   no longer needed for possible backups.

   There is no danger to the data set from deleting audit files.   System
   1022  automatically creates a fresh audit file starting at zero length
   when the old audit file is not found, after the user has  deleted  it.
   The  computer  system  does not allow the user to delete an audit file
   which is in use by the audit system.  The user may attempt  to  delete
   audit files at any time; nothing is harmed if the attempt fails.

   There will be many audit files when the JOB option is in effect.   The
   user may try to delete any of them, even while jobs are actively using
   them.  Again, if they are in active use the monitor  will  not  delete
   them, and the using jobs will not be affected.

   The result of audit file deletions is that the remaining  audit  files
   THE AUDIT TRAIL                                             Page 10-13
   Revision 4


   may  lack  the  information  to  backup  the  data  set  more than one
   checkpoint.  If all audit information is retained from a  given  time,
   then  any  checkpoint since that time may be reestablished by an AUDIT
   BACKUP.  Post-image audit trail files must be  retained  until  a  new
   copy of the data set is saved.



   10.9  AUDIT COMMANDS

   10.9.1  AUDIT START

   The AUDIT START command turns on the audit trail.  The format  of  the
   command is:

        AUDIT START [FILE  <file>] [PRE] [POST] [AUTO] [NOREAD]        ___

             [LOCK] [JOB] [BUFFERS n] [NOMSG]

        Where:

   <file>    Is the file-descriptor  for  the  audit  trail.   If  it  is
             omitted,  the  file  name  will  be  the same as that of the
             currently open data set file,  with  an  extension  of  DML.
             Sites with multiple disk structures and data sets that might
             be accessed by users  with  different  search  lists  should
             specify  a  structure  name for their audit trail file.  The
             DML file is created in the current or specified directory.

   PRE       Starts an audit trail that writes pre-images.  This  is  the
             default.

   POST      Starts an audit trail that writes post-images.

   PRE POST  Starts an audit  trail  that  writes  both  post-images  and
             pre-images.

   AUTO      Starts the audit trail automatically when the  current  data
             set  is  opened  in  the  future.  This condition remains in
             effect until  the  command  AUDIT  CLEAR  is  issued.   (See
             below.)

   NOREAD    Does not record readonly openings of  the  data  set;   used
             with AUTO.

   LOCK      Gives the user exclusive access to the audit file.

   JOB       Changes the DML extension to the user's job number.

   BUFFERS   Specifies the number of blocks used in buffering  the  audit
             trail.  The default is 2.

   THE AUDIT TRAIL                                             Page 10-14
   Revision 4


   NOMSG     Suppresses printing of the routine 1022 message  when  AUDIT
             START creates a new audit trail file.

   The default directory for the AUDIT trail file  is  the  same  as  the
   directory  for  the  data  set  file  to which it refers.  The default
   directory for this file is not the  connected  directory  (DEC-20)  or                           __ ___ ___  _________  _________  ________  __
   default  path  (DEC-10).   On  the DEC-10, audit trails may be written   _______  ____  ________
   into SFD's.

   Data set files must have the same name and directory during  LIST  and
   BACKUP  operations  that  they  had when the corresponding audit trail
   files were created.

   The specification of an AUDIT AUTO file remains the same when  a  data
   set  file  is moved to another directory.  The AUTO file will refer to
   the old directory unless a new AUDIT START AUTO command is given.

   The NOREAD option can increase efficiency by decreasing the number  of
   times 1022 writes to the audit trail file.  Without the NOREAD clause,
   the audit trail records every opening  of  the  data  set.   With  the
   NOREAD clause, opening a data set readonly is not recorded.

   The BUFFERS option can increase efficiency by decreasing the number of
   times  1022  writes  to the audit trail file.  A single data set audit
   trail is usually most efficient when its buffer setting is the same as
   the  data  set's  buffer  setting.   A  large  buffer setting does not
   compromise the integrity of the audit trail.  The buffers  are  always
   written to the audit trail before a change is applied to the data set.

   The INFORM AUDIT command displays the status of the  audit  trail  for
   the current data set.

   Note that if the audit trail  does  not  exist  when  an  AUDIT  START
   command is given, 1022 prints a warning message and creates the file.



   10.9.2  AUDIT LIST

   AUDIT LIST prints the audit file.  The form of the command is:

   THE AUDIT TRAIL                                             Page 10-15
   Revision 4


        AUDIT LIST [ALL] [FILE <file1>] [ON <file2>]        ___

             { [ SINCE <date-time>]                              }


                      {  FIRST {      <n>    }  }
             { [ FROM {  LAST  { [CHECKPOINT]}  } ] [PRE] [POST] }

                      { <check>                 }


             { [ TILL <date-time>]                               }


                      {  FIRST {      <n>    }  }
             { [ THRU {  LAST  { [CHECKPOINT]}  } ] [PRE] [POST] }

                      { <check>                 }

   Where:

   ALL         Prints  from  the  whole  audit  trail.   If  ALL  is  not
               specified then only entries pertaining to the current data
               set are printed.

   <file1>     Is the audit file to print.   Omitted  fields  within  the
               file  descriptor  are filled with the corresponding fields
               in DSK:dsname.DML, with the following two exceptions.  The
               user's  job number is inserted as the extension if the JOB
               option  was  specified  in  AUDIT  START.   Missing   file
               specification  fields  are defaulted to those of the AUDIT
               file if an AUDIT file is open.

   <file2>     Is the file descriptor on which the audit  trail  list  is
               written.   The  default is the user's terminal.  If the ON
               clause is used, the defaults for  any  unspecified  fields
               are DSK:dsname.LST.

   SINCE       Lists  only  those  entries  made  after   the   specified
               date-time.

   FROM        Lists  only  those  entries  made   from   the   specified
               checkpoint to the end of the audit trail.

   TILL        Lists only those entries made from the  beginning  of  the
               audit trail until the specified date-time.

   THRU        Lists only those entries made from the  beginning  of  the
               audit trail through the specified checkpoint.

   <date-time> Is a 1022 date-time descriptor.  (See Appendix C)

   THE AUDIT TRAIL                                             Page 10-16
   Revision 4


   CHECKPOINT  The list begins at the  last  checkpoint  (FROM)  or  goes
               through the last checkpoint (THRU).

   <n>         The command lists entries starting at the  nth  checkpoint
               from  the  end  (FROM) or going through the nth checkpoint
               from the end (THRU).  LAST 1 and LAST CHECKPOINT  are  the
               same.  FIRST 1 and FIRST CHECKPOINT are same.

   <check>     Is any checkpoint number or name.  The list begins  (FROM)
               or ends (THRU) at the named checkpoint.

   PRE         Lists pre-images;  the default.

   POST        Lists post-images.

   The AUDIT LIST command gives a "dump" of the information in the  audit
   trail  for  inspection,  perhaps  prior  to  an  AUDIT BACKUP or AUDIT
   FORWARD operation.  It does  not  produce  formatted  data  set  usage
   reports.   The  Host  Language  audit  interface  may be used for this
   purpose.  We do not recommend using AUDIT LIST to produce output for a
   downstream  process.   Future  formats  for  AUDIT  LIST  may  not  be
   compatible.  Compatibility is  assured  by  the  Host  Language  audit
   utility interface only.



   10.9.3  AUDIT BACKUP

   The AUDIT BACKUP command restores a data set to a previous state using
   pre-images.  Give an AUDIT LIST command with a SINCE or FROM clause to
   gain information about a backup  before  using  some  of  the  options
   below.  The format of the command is:

        AUDIT BACKUP [FILE <file>] [NOVERIFY] [NOMSG]        ___


                    {  FIRST {      <n>     }  }
             [ FROM {  LAST  { [CHECKPOINT] }  } ] 
                    { <check>                  }

   Where:

   <file>    Is the audit trail file name.

   NOVERIFY  Disables verification of  the  backup  process.   The  audit
             trail  is not checked for internal consistency or continuity
             of checkpoints.

   NOMSG     Disables printing of all routine 1022  messages  during  the
             backup.  Entries are listed as they are backed over.

   FROM      Is the same clause as in the AUDIT LIST command above.
   THE AUDIT TRAIL                                             Page 10-17
   Revision 4


   The backup operation  will  deallocate  any  blocks  added  since  the
   attained  checkpoint  when  backing  up a DMS file containing a single
   data set.  If multiple data sets exist in the data set file, recovered
   blocks are not deallocated, resulting in "lost" blocks in the data set
   file.  The user must dump and rekey the data set if this  extra  space
   is unacceptable.

   An AUDIT BACKUP without the FROM option backs the data set to a  point
   just  prior  to the first entry in the audit trail, prior to the first
   AUDIT START command.  This removes the AUTO option, if any, but leaves
   the  audit  trail  active.   The  user  should  reissue an AUDIT START
   command with the options he desires.



   10.9.4  AUDIT FORWARD

   The AUDIT FORWARD command restores a data  set  to  a  previous  state
   using  an archive copy of the data set and post-images.  Give an AUDIT
   LIST command with a POST clause  to  gain  information  about  rolling
   forward  before  using  some  of the options below.  The format of the
   command is:

        AUDIT FORWARD [FILE <file>] [NOVERIFY] [NOMSG]        ___


                    {  FIRST {      <n>     }  }
             [ THRU {  LAST  { [CHECKPOINT] }  } ] 
                    { <check>                  }

   Where:

   <file>    Is the audit trail file name.

   NOVERIFY  Disables verification of the recovery  process.   The  audit
             trail  is not checked for internal consistency or continuity
             of checkpoints.

   NOMSG     Disables printing of all routine 1022  messages  during  the
             recovery.  Entries are listed as they are applied.

   THRU      Is the same clause as in the AUDIT LIST command above.



   10.9.5  AUDIT MERGE

   Separate audit files maintained for the same data set must  be  merged
   together  before any recovery is done for that data set.  This is done
   with the following command:

        AUDIT MERGE <file1> [FROM] <file2> [<file3> ]...        ___
   THE AUDIT TRAIL                                             Page 10-18
   Revision 4


   Where:

   <file1>               Is the name of the resulting merged audit file.

   <file2>, <file3>, ... Are the names of the audit files to be merged.

   Note that 1022 generated checkpoint numbers may change after an  AUDIT
   MERGE command.

   We recommend that all merged audit files pertain to the same data set,
   but it is not required.

   Take care when recovering a data set  with  several  associated  audit
   files.  The recovery must be done using a single audit file containing
   all audit entries made since the roll back checkpoint or the beginning
   of  the  roll  forward audit trail.  Missing audit trail entries cause
   error messages and prevent any backup on the data set.



   10.9.6  AUDIT CHECKPOINT

   The  AUDIT  CHECKPOINT  command  generates  a  checkpoint  for   later
   restoring  the  data  set  to  its  current  state.  The format of the
   command is:

        AUDIT CHECKPOINT <check>        ___

   Where  <check>   Is  the  checkpoint  name,  a  maximum  of  10  ASCII
   characters  not beginning with a digit (0-9).  This name is used in an
   AUDIT LIST, AUDIT BACKUP, or AUDIT FORWARD command as described above.
   You  must  have  update  access  to  the  data  set  to give the AUDIT
   CHECKPOINT command.

   Checkpoints are automatically generated when the data  set  is  opened
   for  writing,  as  in a CHANGE, ADD, UPDATE ON, or UPDATE OFF command.
   System 1022  gives  numbers  to  these  checkpoints.   The  checkpoint
   numbers print in the output of an AUDIT LIST command.

   The audit trail will not contain 1022 checkpoints  between  UPDATE  ON
   and  UPDATE  OFF  commands.   The  user  must  insert  them with AUDIT
   CHECKPOINT if he wants checkpoints  in  the  middle  of  a  continuous
   update sequence.
   THE AUDIT TRAIL                                             Page 10-19
   Revision 4


   10.9.7  AUDIT COMMENT

   The AUDIT COMMENT command places comments into the audit  trail.   The
   command is:

        AUDIT COMMENT <delim> <string> <delim>        ___

   Where:

   <delim>   Is any non-blank delimiter character.

   <string>  Is  any  sequence  of  characters  (including   <RET>)   not
             containing a delimiter.
   Example:

        AUDIT COMMENT "WEEKLY PAYROLL UPDATES MADE 11AM 12/12/79"




   10.9.8  AUDIT CLEAR

   The AUDIT CLEAR command turns off the  AUTO  option  specified  in  an
   AUDIT START.  The command is:

        AUDIT CLEAR        ___

   with no options or arguments.  This command  does  not  turn  off  the
   audit trail; that happens when you close the data set.



   10.9.9  AUDIT RECOVERY

   System 1022 can automatically repair data set damage and limit  access
   to  damaged  data  sets.   The  AUDIT  RECOVERY  command specifies the
   automatic treatment of a damaged data set.

   The command is:

                              { AUTO   }
        AUDIT RECOVERY [ MODE {        } ]        ___
                              { MANUAL }

                          { QUERIES }
                  [ ALLOW { UPDATES } ] [NOMSG]
                          { NOTHING }

   Where:

   AUTO    Directs 1022 to automatically recover to  a  checkpoint  using
           the  audit  trail  that  was  in use when the damage occurred.
           This happens when the data set is next opened.
   THE AUDIT TRAIL                                             Page 10-20
   Revision 4


   MANUAL  Indicates that no automatic recovery will be done.  MANUAL  is
           the default mode.

   NOMSG   Suppresses informational messages ordinarily typed to the user
           who opens the damaged data set.


   The ALLOW clause specifies the type of access permitted to  a  damaged
   data set.

   ALLOW NOTHING  Prevents access of any kind to the damaged data set.

   ALLOW QUERIES  Prevents updates of any kind  to  the  data  set.   Any
                  attempt  to  write  to the data set will fail.  This is
                  the default.  Read access is permitted.

   ALLOW UPDATES  Permits access as if no damage existed.



   If no AUDIT RECOVERY command is given, the following is the default

        AUDIT RECOVERY MODE MANUAL ALLOW QUERIES

   Regardless of the specified ALLOW clause, the data set owner is always
   permitted to:

        A.  OPEN and read the data set.
        B.  Execute the following commands which modify the data set:

             AUDIT BACKUP
             AUDIT FIX
             AUDIT FORWARD
             AUDIT RECOVERY
             IGNORE DAMAGE



   10.9.10  AUDIT FIX

   AUDIT FIX returns the data set to its condition at  the  time  of  the
   last  checkpoint  in  the  audit  trail.   This is the least amount of
   backup which restores consistency to the data set.  The format of  the
   AUDIT FIX command is:

        AUDIT FIX [NOMSG]        ___

   This command is equivalent to:

        AUDIT BACKUP FILE <audit-file> FROM LAST CHECKPOINT
             [NOMSG]

   The name of the audit file in use when data set damage occurs  may  be
   THE AUDIT TRAIL                                             Page 10-21
   Revision 4


   obtained  with  the  INFORM AUDIT command.  Only pre-image checkpoints
   and user-generated checkpoints can be used by the AUDIT FIX  or  AUDIT
   BACKUP commands.

   AUDIT FIX does nothing if the data set is not damaged.  The  data  set
   is  damaged  if  an update sequence is interrupted.  A later update to
   the data set, after damage, establishes a later checkpoint.  AUDIT FIX
   always  stops at the last checkpoint.  Use the AUDIT BACKUP command to
   attain any earlier checkpoint, and check the data set damage  flag  to
   know when damage is removed.
   THE AUDIT TRAIL                                             Page 10-22
   Revision 4















                                 CHAPTER 11

                                  SECURITY





   11.1  ESTABLISHING DATA BASE SECURITY


   Within  System  1022,  only  the  data  set  owner  and   the   System
   Administrator  can  regulate other users' access to that data set with
   the ADMIT command.  Data set ownership is  defined  by  the  directory
   name  or project, programmer number under which the data set was first
   created or loaded.  ADMIT commands offer the data set owner  a  number
   of security options.

   The data set owner may password-protect a whole data set by opening it
   and then issuing the command

        ADMIT CLASS PASSWORD XYZ

   This bars anyone without the password (XYZ) from opening the data set.

   The data set owner may allow some users but not others to have  access
   to  the  data  set by opening the set, issuing one or more commands of
   the form:

        ADMIT <user-id>...

   This grants access to the user  whose  user-id  is  specified  in  the
   command while locking out everyone else (unless named in another ADMIT
   command).

   The data set owner may also control access to individual attributes in
   the  data set with the FOR clause of the ADMIT command and may specify
   the level of access--LOCKED, READONLY, or UPDATE--to those  attributes
   or to the data set as a whole.  For example:

        ADMIT CLASS PASSWORD XYZ RO FOR GROSS PASSWORD ABC UPDATE

   allows users who know the password (XYZ) to  open  the  data  set  for
   examination  and  grants  update privileges for the attribute GROSS to
   users who also know the password (ABC).  To gain the access  specified
   SECURITY                                                     Page 11-2
   Revision 3


   in a FOR clause that contains a password, the user must issue a PERMIT
   command after opening the data set.  In the present example, the  user
   must  issue  the following commands in order to have update status for
   the attribute GROSS:

        OPEN <data-set-descriptor> PASSWORD XYZ

        PERMIT GROSS PASSWORD ABC

   FOR clauses may be used in the same way in ADMIT <user-id> commands as
   they are in ADMIT CLASS PASSWORD commands.  For example:

        ADMIT <user-id> RO FOR GROSS UPDATE

   allows a user whose user-id matches the one specified in  the  command
   to  open the data set for examination and to update the values for the
   attribute GROSS.

   Finally, the data set owner may alter previously established  security
   by  issuing  additional  ADMIT  commands,  by  using  the  ADMIT CLEAR
   command, or by transferring ownership of  the  data  set  through  the
   ADMIT  OWNER  command.   All  of  these options are examined in detail
   below.

   Note that because System 1022 security operates  at  the  applications
   software level, the user's ability to read or update data set files is
   ultimately determined by the rules  of  the  operating  system's  file
   system.   In  other  words,  all access privileges granted or withheld
   within 1022 are subject to the file access protections assigned by the
   DECsystem-10 or DECSYSTEM-20 operating system.




   11.1.1  The ADMIT Command


   The data set owner establishes security by opening the  data  set  and
   issuing one or more ADMIT commands.  The ADMIT command gives specified
   users access to the data set while locking all others out.  The  ADMIT
   provisions  take  effect  the  next time anyone tries to open the data
   set.  The owner may issue ADMIT commands of  either  or  both  of  the
   following forms:

   1.  ADMIT CLASS PASSWORD <password> [ <access> ]

         [ FOR <attribute> [ <access> ] [ PASSWORD <password> ] ]...

   2.  ADMIT <user-id> [ <access> ] [ PASSWORD <password> ]

         [ FOR <attribute> [ <access> ] [ PASSWORD <password> ] ]...

   Commands of type 1 require  all  users  to  issue  the  password  when
   SECURITY                                                     Page 11-3
   Revision 3


   opening  the  data  set.  If a user fails to give the correct password
   when issuing the OPEN command, the error message

        (OP3) Wrong Password

   appears and the data set does not open.  If the user fails to give any
   password  at all and the user is not covered by the provisions of some
   other ADMIT command, a message appears  prompting  for  the  password.
   Commands  of  type  2 specify by user-id which users may open the data
   set.  Because "user-id" is defined differently on TOPS-10 and TOPS-20,
   ADMIT  <user-id>  on  TOPS-10  and  ADMIT  <user-id>  on  TOPS-20  are
   explained in separate sections below.

   In both forms of the ADMIT command, the  <access>  option  allows  the
   data  set owner to specify the degree of access that users may have to
   the data once they have opened the data set.  The possible degrees  of
   access are LOCKED (no access), READONLY (examination privileges only),
   and UPDATE (both read and write privileges),  which  is  the  default.
   The  owner  may  further  regulate access on an attribute-by-attribute
   basis with the FOR clause.

   The following abbreviations are allowed in ADMIT commands:

                       ADMIT       ADM

                       PASSWORD    PASS

                       LOCKED      LOCK

                       READONLY    RO

                       UPDATE      UPD

   There is no restriction on the number or  variety  of  ADMIT  commands
   that  the  data  set  owner  may issue.  For example, an owner (SMITH)
   might issue the following ADMIT commands for the same data set:

   1.  ADMIT CLASS PASSWORD XYZ READONLY

   2.  ADMIT <JONES-id> RO FOR GROSS UPDATE

   3.  ADMIT <SMITH-id> UPDATE

   Command 1 allows users with the password XYZ to open SMITH's data  set
   for examination only.  Command 2 allows JONES to open the data set for
   examination without having to specify a password and to have read  and
   write  privileges  for  the  attribute  GROSS.   Command 3 gives SMITH
   global UPDATE access without having to give a password.

   The security structure established by these commands takes effect  the
   next  time  anyone  tries  to  open the data set and remains in effect
   until SMITH changes it.  The various ways in which data set owners may
   change security are discussed below.
   SECURITY                                                     Page 11-4
   Revision 3


   11.1.1.1  The ADMIT CLASS PASSWORD Command


   This form of the ADMIT command allows the data set owner  to  restrict
   access  to the data by requiring users to give a password when opening
   the data set.  The syntax of the command is:

     ADMIT CLASS PASSWORD <password-1> [ <access-1> ]

      [ FOR <attribute> [ <access-2> ] [ PASSWORD <password-2> ] ]...

   where:

   <password-1> is an alphanumeric string of up to five  characters  that
   the  user  must  type  when issuing the OPEN command in order to to be
   able to open the data set.  A password may not  contain  any  reserved
|  characters.   If  you  specify a password of more than five characters
|  when giving an ADMIT command, System 1022 automatically  truncates  it
|  to its first five characters.

   <access> is the degree of  privilege  granted  to  users  and  may  be
   specified  as  LOCKED,  READONLY,  or  UPDATE.   UPDATE,  which is the
   default, gives the user read and write privileges.  READONLY gives the
   user  read  but not write privileges.  LOCKED gives the user no access
   to the data except as specified in a FOR clause.

   FOR clauses allow the owner to further restrict or broaden user access
   to  individual  attributes  in the data set, optionally specifying the
   degree of access and a password.  Again, the three degrees  of  access
   are  LOCKED,  READONLY,  and  UPDATE, with UPDATE as the default.  The
   password, if specified, must consist of no more than five alphanumeric
   characters, none of which may be reserved.

   When the data set owner specifies a password in a FOR clause, the user
   must  open  the  data  set and then issue a PERMIT command in order to
   gain access to the password-protected attribute.  The  PERMIT  command
   is discussed below.

   The following are examples of the ADMIT CLASS PASSWORD command:

        ADMIT CLASS PASS ABCD

           This allows only users with the password ABCD to open the data
           set.   Because  no particular access has been specified, users
           able to open the data set have UPDATE privileges by default.

        ADMIT CLASS PASS ABCD RO

           This allows only users with the password ABCD to open the data
           set for examination but not for update.

        ADMIT CLASS PASS ABCD LOCKED FOR GROSS RO
   SECURITY                                                     Page 11-5
   Revision 3


           This allows only users with the password ABCD to open the data
           set  and  have examination privileges for the attribute GROSS.
           The values for all the other attributes in the data  set  will
           print  out  as  **** with no error message if the user gives a
           PRINT ALL command.

        ADMIT CLASS PASS ABCD RO FOR GROSS LOCKED FOR NET PASS XYZ

           This allows only users with the password ABCD to open the data
           set  for  examination  of  all  attributes  but GROSS and NET.
           Users are granted no access to GROSS.   Those  users  who  can
           open  the  data set and also know the password XYZ may issue a
           PERMIT command after opening the data set to  gain  access  to
           the  attribute  NET,  for  which they have been granted UPDATE
           privileges by default.




   11.1.1.2  The ADMIT <user-id> Command On TOPS-10


   This form of the ADMIT command allows the data  set  owner  to  define
   access  privileges  for  individual users or user groups by specifying
   user-identification numbers.  The syntax of the command is:

     ADMIT <user-id> [ <access-1> ] [ PASSWORD <password-1> ]

      [ FOR <attribute> [ <access-2> ] [ PASSWORD <password-2> ] ]...

   where:

   <user-id> is a project, programmer number (ppn).  Either  or  both  of
   these numbers may be a wildcard (*).  The user may type either a comma
   or a space between project number, programmer number, and wildcards in
   issuing ADMIT <user-id> commands.  Thus,

        ADMIT 3,20

   is equivalent to

        ADMIT 3 20

   Commas  are  used  in  the  examples  in  this  chapter  for  clarity.
   Wildcarding is explained below.

   <access> is the degree of privilege granted  to  users  whose  user-id
   matches  the one specified in the command.  Access may be specified as
   LOCKED, READONLY, or UPDATE.  UPDATE, which is the default, gives  the
   user  read and write privileges.  READONLY gives the user read but not
   write privileges.  LOCKED gives the user no access to the data  except
   as specified in a FOR clause.
   SECURITY                                                     Page 11-6
   Revision 3


   <password> is an alphanumeric string of up to five characters that the
   user  must  type  when issuing the OPEN command in order to be able to
   open  the  data  set.   A  password  may  not  contain  any   reserved
|  characters.   If  you  specify a password of more than five characters
|  when giving an ADMIT command, System 1022 automatically  truncates  it
|  to its first five characters.

   FOR clauses allow the owner to further restrict or broaden user access
   to  individual  attributes  in the data set.  The owner may optionally
   specify the degree of access and a password.  Access  may  be  LOCKED,
   READONLY, or UPDATE, with UPDATE as the default.  The password, if one
   is  specified,  must  consist  of  no  more  than  five   alphanumeric
   characters, none of which may be reserved.

   When the data set owner has specified a password in a FOR clause,  the
   user  must  open the data set and then issue a PERMIT command in order
   to gain  access  to  the  password-protected  attribute.   The  PERMIT
   command is discussed below.

   To open the data set after the owner has  issued  an  ADMIT  <user-id>
   command, a user's user-id must match the one specified in the command.
   For example, if the owner issues the commands

        ADMIT 3,1 UPDATE

        ADMIT 3,20 RO

   only the user whose user-id is 3,1 may open the data set with read and
   write privileges, and only the user whose user-id is 3,20 can open the
   data set for examination only.  All other users--except the owner  and
   the  System  Administrator--are  barred from opening the data set.  If
   the owner has forgotten to issue an ADMIT <user-id> command  in  which
   the  owner's  user-id  is specified, the owner can still open the data
   set but will not be able to read any of the data.  The owner can still
   correct  the  oversight  by  issuing  a new ADMIT <user-id> command in
   which the specified user-id is the owner's, closing the data set,  and
   starting over again.

   The owner can grant a group of users access to the data set by issuing
   an  ADMIT  <user-id>  command in which the user-id contains a wildcard
   (*).  For example, the command

        ADMIT 3,* RO

   grants examination privileges to all users whose project number is  3,
   regardless  of programmer number, with the exception of any user whose
   user-id is specified  in  full  in  some  other  ADMIT  command.   For
   example,  suppose  that  the  data  set owner has issued the following
   commands:

   1.  ADMIT 3,1 UPDATE

   2.  ADMIT 3,* RO
   SECURITY                                                     Page 11-7
   Revision 3


   3.  ADMIT 3,20 RO FOR GROSS UPDATE

   All users whose project number is 3 are granted examination privileges
   except  for  the user whose ppn is 3,1 and the user whose ppn is 3,20.
   These two people are more precisely identified by  commands  1  and  3
   than by command 2.  Similarly, the command

   4.  ADMIT *,* LOCKED FOR GROSS RO

   applies to all users except those covered in commands 1, 2, or 3.  The
   rule  is  that  a  user's  access  privileges are defined by the ADMIT
   command that most precisely specifies that user's user-id:  a  ppn  is
   more  precise than a project number plus a wildcard or a wildcard plus
   a programmer number, and all are more precise than a wildcard  plus  a
   wildcard.

   The following are examples of the ADMIT <user-id> command:

        ADMIT 3,20

           This allows the user whose user-id is 3,20 to  open  the  data
           set.   Because  no  particular  access has been specified, the
           user has UPDATE privileges by  default.   If  no  other  ADMIT
           commands  have  been  issued,  user  3,20  is  the only person
           (besides the owner) with access to the data set.

        ADMIT 3,* RO PASS ZYX

           This allows any user whose project number is 3, who knows  the
           password  ZYX, and who is not more precisely identified in the
           <user-id> clause of some other ADMIT command to open the  data
           set for examination only.

        ADMIT *,* LOCKED FOR GROSS RO PASS ABC

           This allows all users not more specifically identified in  any
           other  ADMIT commands to open the data set but not to have any
           access to the data.  To gain examination  privileges  for  the
           attribute GROSS, a user who has opened the data set must issue
           a PERMIT command specifying the password ABC.




   11.1.1.3  The ADMIT <user-id> Command On TOPS-20


   This form of the ADMIT command allows the data  set  owner  to  define
   access  privileges  for  individual users or user groups by specifying
   user-identification numbers or directory strings.  The ADMIT <user-id>
   command  is  only  useful when files are password-protected at monitor
   level or when the System Administrator at your site has set  the  1022
   system  variable SYSADMCDIR to 1.  When SYSADMCDIR is set to 0, a user
   SECURITY                                                     Page 11-8
   Revision 3


   who connects to another user's  directory  with  the  TOPS-20  CONNECT
   command  assumes  all  owner rights to the files in that directory for
   the duration of the connection.  One of these rights is the  right  to
   alter  or  remove security provisions.  When SYSADMCDIR is set to 1, a
   user can still connect to another user's directory but does not assume
   owner privileges.  A user without owner rights is subject to any ADMIT
   provisions that the owner has established for the data set.

   The syntax of the ADMIT <user-id> command is:

     ADMIT <user-id> [ <access-1> ] [ PASSWORD <password-1> ]

      [ FOR <attribute> [ <access-2> ] [ PASSWORD <password-2> ] ]...

   where:

   <user-id> is a device plus a <directory string>  or  else  a  project,
   programmer  number  (ppn).   Either  or both of these numbers may be a
   wildcard (*).  With a <directory  string>,  the  device  need  not  be
|  specified;   PS:   is  the default.  Both the device and the directory
|  string may contain the wildcard *.
|  
|  At sites running a common file system with multiple public structures,
|  the  ADMIT  list for a data set on one PS:  applies to users logged in
|  on other PS:   structures  unless  the  dataset  owner  specifies  the
|  particular  PS:   structure  to  which  the security provisions are to
|  apply in the ADMIT command.  Thus, the command
|  
|       ADMIT <JOE> RO
|  
|                or
|  
|       ADMIT PS:<JOE> RO
|  
|  gives the user logged into <JOE> on any PS:  (PS1:, PS2:, or the like)
|  readonly access to the data set.  The command
|  
|       ADMIT PS1:<JOE> RO
|  
|  gives the user logged into <JOE> on PS1:  (but not PS2:  or the  like)
|  readonly access to the data set.

   A directory name may be a user name.  The <directory string> is  given
   in  angled brackets in all ADMIT commands.  The user may type either a
   comma or a  space  between  project  number,  programmer  number,  and
   wildcards in issuing ADMIT <user-id> commands.  Thus,

        ADMIT 4,20

   is equivalent to

        ADMIT 4 20
   SECURITY                                                     Page 11-9
   Revision 3


   Commas are used in the examples given in  this  chapter  for  clarity.
   Wildcarding is explained below.

   <access> is the degree of privilege granted  to  users  whose  user-id
   matches  the one specified in the command.  Access may be specified as
   LOCKED, READONLY, or UPDATE.  UPDATE, which is the default, gives  the
   user  read and write privileges.  READONLY gives the user read but not
   write privileges.  LOCKED gives the user no access to the data  except
   as specified in a FOR clause.

   <password> is an alphanumeric string of up to five characters that the
   user  must  type  when issuing the OPEN command in order to be able to
   open  the  data  set.   A  password  may  not  contain  any   reserved
|  characters.   If  you  specify a password of more than five characters
|  when giving an ADMIT command, System 1022 automatically  truncates  it
|  to its first five characters.

   FOR clauses allow the owner to further restrict or broaden user access
   to  individual  attributes  in the data set, optionally specifying the
   degree of access snd a password.  Again, the  degrees  of  access  are
   LOCKED,  READONLY,  and  UPDATE,  with UPDATE as the default;  and the
   password, if specified, must consist of no more than five alphanumeric
   characters, none of which may be reserved.i

   When the data set owner has specified a password in a FOR clause,  the
   user  must  open the data set and then issue a PERMIT command in order
   to gain  access  to  the  password-protected  attribute.   The  PERMIT
   command is discussed below.

   To open the data set after the owner has  issued  an  ADMIT  <user-id>
   command, a user's user-id must match the one specified in the command.
   Suppose, for example, that a data set owner  (SMITH)  has  issued  the
   following commands:

   1.  ADMIT <SMITH> UPDATE

   2.  ADMIT <JONES> RO

   The security structure of the data set is now defined so that SMITH is
   the  only  user  who  can  open  the  data  set  with  read  and write
   privileges, and JONES is the only user who can open the data  set  for
   examination  only.   If  the  System  Administrator has set the system
   variable SYSADMCDIR to 1, then no other users besides SMITH and  JONES
   can  open  the  data set.  If SYSADMCDIR is still set to 0, anyone who
   connects to SMITH's directory has SMITH's access privileges as owner.

   Note that if SMITH forgot to issue command 1, SMITH as the owner would
   still  be  able to open the data set but would not be able to read any
   of the data.  If an owner forgets to issue an ADMIT <user-id> in which
   the  owner's  <user-id>  is  specified,  the  owner  may  correct  the
   oversight by opening the data  set,  issuing  a  new  ADMIT  <user-id>
   command  in  which  the owner's user-id is specified, closing the data
   set, and starting over again.
   SECURITY                                                    Page 11-10
   Revision 3


   SMITH might have elected to specify the user-id in each command  as  a
   ppn  rather  than  as  a  directory  string.   Directory  strings  are
|  preferred because they are unique, while the same  ppn  can  designate
|  different users on different structures.
|  
|  User access privileges are defined by  the  ADMIT  command  that  most
|  precisely  specifies  the  user's user-id:  a full directory string is
|  more precise  than  a  directory  string  ending  in  a  wildcard;   a
|  directory  string  (with or without a wildcard) is more precise than a
|  ppn;  a ppn is more precise than a wildcard plus a  programmer  number
|  or  a project number plus a wildcard;  and all are more precise than a
|  wildcard plus a wildcard.

   The following are examples of the ADMIT <user-id> command:

        ADMIT <LOPEZ>

           This allows the user whose directory string is <LOPEZ> to open
           the  data  set.   Because  no  particular degree of access was
           specified, this user has update privileges by default.  If  no
           other  ADMIT  commands  have  been  issued  and if the TOPS-20
           CONNECT command has been disabled, LOPEZ is  the  only  person
           (besides the owner) with access to the data set.

        ADMIT 4,103 RO PASS XYZ

           This allows and  user  whose  ppn  is  4,103,  who  knows  the
           password  XYZ,  and  whose  ppn  or  directory string does not
           appear in full  in  the  <user-id>  clause  of  another  ADMIT
           command to open the data set for examination only.
|  
|       ADMIT *:<LOPEZ>
|  
|          This allows the user whose directory string is <LOPEZ> to have
|          update  access  on  all  devices  on  which there is a <LOPEZ>
|          directory.

        ADMIT <MAN*> LOCKED FOR GROSS RO PASS ABC

           This allows all users whose directory strings begin  with  the
           characters MAN and who are not more specifically identified in
           any other ADMIT commands to open the data set but not to  have
           any  access  to  the data.  To gain examination privileges for
           the attribute GROSS, a user who has opened the data  set  must
           issue a PERMIT command specifying the password ABC.
   SECURITY                                                   Page 11-10A
   Revision 3


   11.1.2  Altering Security


   The owner may wish to change the established security structure of the
   data  set to allow new users access to the data or to limit or broaden
   the access previously allowed to others.   The  owner  may  alter  the
   structure in a variety of ways:

           by writing the ADMIT provisions to a  command  file  and  then
           editing them;

           by issuing new  ADMIT  commands  to  supplement  or  supercede
           previous ones;

           by issuing the ADMIT CLEAR command in one or  another  of  its
           forms;

           by issuing the ADMIT OWNER command;  or

           by dumping all the data to a new data set and then issuing new
           ADMIT commands:  security provisions, like key tables, are not
           transfered when dumping from one data set to another.

   It is always a good idea to issue an INFORM ADMIT  command  to  review
   the  existing security structure before altering that structure in any
   way.




   11.1.2.1  Editing ADMIT Provisions At Monitor Level


   The procedure for adding, deleting, or modifying ADMIT  provisions  at
   monitor level is for the owner to open the data set and then issue the
   following commands:
   SECURITY                                                   Page 11-10B
   Revision 3






























                        [ Thid page intentionally left blank ]
   SECURITY                                                    Page 11-11
   Revision 3


        1.  INFORM ON <file-descriptor> ADMIT

        2.  ADMIT CLEAR

        3.  EDIT <file-descriptor>

        4.  USE <file-descriptor> or

            @ <file-descriptor>

   The first of these commands writes the  data  set's  ADMIT  provisions
   into  a  file that the owner names in issuing the command.  The second
   command  removes  all  ADMIT  provisions  from  the  data  set.   EDIT
   temporarily  transfers  control  to a text editor with which the owner
   then edits the file created by command 1.   Exiting  from  the  editor
   returns  the  owner  to  1022,  and  command 4 enters the edited ADMIT
   provisions into the data set, establishing the new security structure.




   11.1.2.2  Adding ADMIT Commands On TOPS-10


   The simplest way to grant a new user access to a restricted  data  set
   is  for  the  owner  to  add  a  new ADMIT command to those previously
   issued.   For  example,  suppose  that  an  owner,  SMITH  (3,1),  has
   protected a data set with the commands

        ADMIT CLASS PASS XYZ LOCKED FOR GROSS RO

        ADMIT 3,* RO

        ADMIT 3,20 RO FOR GROSS UPDATE

        ADMIT 3,1 UPDATE

   SMITH can grant the appropriate degree of access to a new user,  FRANK
   (3,75),  by  opening  the  data  set and issuing a command such as the
   following:

        ADMIT 3,75 RO FOR GROSS UPDATE

   which would allow FRANK to examine all attribute values and to  update
   those  for  GROSS.   The  addition of this new command would in no way
   alter the effect of the other ADMIT  commands  that  SMITH  had  given
   previously.

   It is, however, possible to alter  the  effect  of  previously  issued
   ADMIT  commands  by  issuing  a  new  ADMIT  whose password or user-id
   specification matches that of an  old  command.   For  example,  SMITH
   might issue the following new command:
   SECURITY                                                    Page 11-12
   Revision 3


        ADMIT CLASS PASS XYZ RO

   This would allow users with the password XYZ to open the data set  for
   examination  (where  formerly  password  holders  were only allowed to
   examine the values for the attribute GROSS and no others).  Similarly,
   if SMITH issues the new command

        ADMIT 3,20 LOCKED FOR GROSS RO

   the user whose ppn is  3,20  can  now  only  examine  values  for  the
   attribute GROSS and no longer has update privileges.  The rule is that
   when two ADMIT commands specify the same password or user-id, the more
   recently issued command cancels the older one.




   11.1.2.3  Adding ADMIT Commands On TOPS-20


   The simplest way to grant a new user access to a restricted  data  set
   is  for  the  owner  to  add  a  new ADMIT command to those previously
   issued.  For example, suppose that an owner (SMITH)  has  protected  a
   data set with the commands:

        ADMIT CLASS PASS XYZ LOCKED FOR GROSS RO

        ADMIT 4,* RO

        ADMIT <JONES> RO FOR GROSS UPDATE

        ADMIT <SMITH> UPDATE

   SMITH can grant the appropriate degree of access to a new user (FRANK)
   by opening the data set and issuing a command such as the following:

        ADMIT <FRANK> RO FOR GROSS UPDATE

   which would allow FRANK to examine all of the attribute values and  to
   update  those for GROSS.  The addition of this new command would in no
   way alter the effect of the other ADMIT commands that SMITH had  given
   previously.

   Instead of specifying FRANK's  directory  name,  SMITH  could  specify
   FRANK's  ppn.   We  recommend using directory names wherever possible,
   however.

   Under certain circumstances, new ADMIT commands can alter the  effects
   of  previously  issued  ones.   If  a  new  ADMIT  command specifies a
   password, directory name, or ppn that  is  identical  to  a  password,
   directory  name,  or ppn in a previously issued ADMIT command, the new
   command replaces the old one.  For  example,  SMITH  might  issue  the
   following new commands:
   SECURITY                                                    Page 11-13
   Revision 3


        ADMIT CLASS PASS XYZ RO

        ADMIT 4,* RO FOR GROSS UPDATE

        ADMIT <JONES> LOCKED FOR GROSS RO

   The first of these new commands grants increased access privileges  to
   users  with  the  password  (XYZ).   The  second  increases the access
   privileges of those users whose project number is 4.  The last reduces
   JONES's  access  to  the  data.   SMITH's access remains unchanged, as
   would that of any other user whose directory name or ppn was specified
   in any other previous ADMIT command.

   Note that it is not possible to override an  old  ADMIT  command  that
   specifies a directory name with a new ADMIT command that specifies the
   ppn that translates that directory name.  For example, suppose that  a
   user  has the directory name <JONES> and the ppn 4,20.  If SMITH tried
   to restrict JONES's access privileges with the command

        ADMIT 4,20 LOCKED FOR GROSS RO

   instead of with the command

        ADMIT <JONES> LOCKED FOR GROSS RO

   JONES would continue to be covered under the  provisions  of  the  old
   command

        ADMIT <JONES> RO FOR GROSS UPDATE

   The reason for this is that System 1022 gives precedence to  directory
   names  over  ppns  as  a  means of identification.  As a result, it is
   possible to override an old ADMIT command that specifies a ppn with  a
   new ADMIT command that specifies the directory name that is translated
   by that ppn, but this is not recommended.

   The safest way to update the security structure as it  applies  to  an
   individual  user  is  to  issue  the  INFORM  ADMIT  command, note the
   existing  ADMIT  provisions  that  apply  to  that  user,  issue   the
   appropriate  ADMIT <user-id> CLEAR command, and then issue a new ADMIT
   <user-id> command,  specifying  the  user's  directory  name  and  the
   appropriate degree of access.




   11.1.2.4  The ADMIT CLEAR Command


   Only the data set owner can delete existing ADMIT  commands  with  the
   ADMIT CLEAR command.  The ADMIT CLEAR command has three forms:

   1.  ADMIT CLEAR
   SECURITY                                                    Page 11-14
   Revision 3


   2.  ADMIT CLASS PASSWORD <password> CLEAR

   3.  ADMIT <user-id> CLEAR

   An ADMIT CLEAR command of type 1 deletes all previous ADMIT provisions
   from  the  data  set,  removing  all  restrictions on access for other
   users.  The data set owner may issue new ADMIT commands to establish a
   new security structure after issuing the ADMIT CLEAR command.

   An ADMIT CLEAR command of type 2 cancels the ADMIT provisions  of  any
   previous  ADMIT CLASS PASSWORD command in which the specified password
   is identical to the one given in the ADMIT CLASS  PASSWORD  <password>
   CLEAR command.  For example, the command

        ADMIT CLASS PASSWORD XYZ CLEAR

   cancels the previously issued command

        ADMIT CLASS PASSWORD XYZ

   Note that the command

        ADMIT CLASS PASSWORD XYZ CLEAR

   also clears the more complex command

        ADMIT CLASS PASSWORD XYZ LOCKED FOR GROSS RO PASSWORD ABC

   Note also that if a data set is protected  by  a  single  ADMIT  CLASS
   PASSWORD  <password>  command  and  no  other ADMIT commands have been
   given, an ADMIT CLASS PASSWORD <password> CLEAR in which the  password
   matches the one in the ADMIT CLASS PASSWORD <password> command has the
   effect  of  locking  all  users  (except  the  owner  and  the  System
   Administrator) out of the data set.  To remove the ADMIT provisions in
   order to grant access to all users, the ADMIT CLEAR command should  be
   given.

   An ADMIT CLEAR command of type 3 cancels the ADMIT provisions  of  any
   previous  ADMIT  <user-id> command in which the specified <user-id> is
   identical to the one given in the ADMIT <user-id> CLEAR.  Thus,

        ADMIT 4,* CLEAR

   cancels the command

        ADMIT 4,*

   but not the command

        ADMIT 4,103

   ADMIT commands of type 3 are useful when the  owner  wants  to  change
   part  of  the security structure while leaving the rest intact.  ADMIT
   SECURITY                                                    Page 11-15
   Revision 3


   <user-id> CLEAR on  TOPS-10  and  ADMIT  <user-id>  CLEAR  on  TOPS-20
   operate differently, so the two are considered separately below.




   11.1.2.4.1  ADMIT <user-id> CLEAR On TOPS-10


   The ADMIT <user-id> CLEAR command allows the data set owner  to  alter
   individual elements of the security structure.  For example, the owner
   might issue the following ADMIT commands:

   1.  ADMIT 3,25 RO

   2.  ADMIT 3,30 RO FOR GROSS UPDATE

   3.  ADMIT 3,22 UPDATE

   If the owner then issues the command

   4.  ADMIT 3,30 CLEAR

   command 2 will be canceled, and the user whose user-id is 3,30 will be
   barred  from opening the data set (because none of the remaining ADMIT
   provisions apply to that user).  This would not be so if the  security
   structure included the following command:

   5.  ADMIT 3,* RO

   Before the owner issued command 4, user 3,30's access privileges  were
   defined  by  command  2 (which identified the user more precisely than
   command 5).  Now that command 2 has been canceled, 3,30 is covered  by
   command  5.   If  the  owner  wants to exclude 3,30 from access to the
   data, the owner should either issue a new command  explicitly  barring
   3,30:

   6.  ADMIT 3,30 LOCKED

   or else cancel command 5 by issuing the command

   7.  ADMIT 3,* CLEAR

   and then issue new ADMIT commands to allow access to the desired users
   on a user-by-user basis.

   Note:  if the data set  is  protected  by  a  single  ADMIT  <user-id>
   command, an ADMIT <user-id> CLEAR in which the user-id matches the one
   in the ADMIT <user-id> command has the effect  of  locking  all  users
   (except  the  owner and the System Administrator) out of the data set.
   To remove ADMIT provisions in order to grant access to all users,  the
   ADMIT CLEAR command should be given.
   SECURITY                                                    Page 11-16
   Revision 3


   11.1.2.4.2  ADMIT <user-id> CLEAR On TOPS-20


   The ADMIT <user-id> CLEAR command allows the data set owner  to  alter
   individual elements of the security structure.  For example, the owner
   might issue the following ADMIT commands:

   1.  ADMIT <JONES> RO

   2.  ADMIT <FRANK> RO FOR GROSS UPDATE

   3.  ADMIT <SMITH> UPDATE

   If the owner then issues the command

   4.  ADMIT <FRANK> CLEAR

   command 2 is canceled, and FRANK is barred from opening the  data  set
   (because none of the remaining ADMIT provisions apply to FRANK).  This
   would  not  be  so  if  the  security  structure  included  any  ADMIT
   provisions that referenced FRANK's ppn.  For example, if the owner had
   previously issued the command

   5.  ADMIT 4,* RO

   FRANK would be able to  open  the  data  set  for  examination,  since
   FRANK's ppn matches the specification of command 5.  (Before the owner
   issued command 4, FRANK's access privileges were defined by command 2,
   which  more precisely identifies the user than command 5).  Similarly,
   if the owner had previously issued the command

   6.  ADMIT 4,30 RO FOR GROSS LOCKED

   and had neglected to cancel it with an ADMIT 4,30 CLEAR, overriding it
   instead  with  command  2,  the cancellation of command 2 by command 4
   would bring command 6 back into effect, and  FRANK  would  still  have
   access to the data.

   To avoid such situations,  we  recommend  that  data  set  owners  use
   directory  names  instead  of  ppns whenever possible in issuing ADMIT
   commands and that they issue an INFORM ADMIT command to see  what  the
   current ADMIT provisions are before altering the security structure.

   If the owner wants to bar a user from opening the data set, the  owner
   must either cancel all existing ADMIT provisions covering that user by
   issuing one or more ADMIT <user-id> CLEAR commands or must issue a new
   ADMIT  <user-id> to lock the user out.  In the example just given, the
   owner would have to issue the following commands:

   7.  ADMIT 4,* CLEAR

   8.  ADMIT 4,30 CLEAR
   SECURITY                                                    Page 11-17
   Revision 3


   in addition to command 4 and  would  then  have  to  issue  new  ADMIT
   <user-id>  commands  to  grant access to the users formerly covered by
   rule 5.  Alternatively, the owner could simply issue the command

   9.  ADMIT <FRANK> LOCKED

   Note:  if the data set  is  protected  by  a  single  ADMIT  <user-id>
   command,  an  ADMIT <user-id> CLEAR in which the <user-id> matches the
   one in the ADMIT <user-id> command has the effect of locking all users
   (except the owner) out of the data set.  To remove ADMIT provisions in
   order to grant access to all users, the ADMIT CLEAR command should  be
   given.




   11.1.2.5  The ADMIT OWNER Command


   This command allows the data set owner to transfer  ownership  of  the
   data  set  to another user, thereby conferring all owner privileges on
   that user.  The syntax of the command is:

        ADMIT <user-id> OWNER

   where:

   <user-id> is a full ppn (on TOPS-10) or a full ppn or directory string
   (on TOPS-20).  No wildcarding is allowed in the ADMIT OWNER command.

   This command, like all other ADMIT commands,  takes  effect  the  next
   time  anyone  tries  to open the data set.  For example, if a data set
   owner, SMITH (ppn 4,30), wants to transfer ownership of the  data  set
   to LOPEZ (ppn 4,40), the procedure is as follows:

   1.  SMITH opens the data set

   2.  SMITH issues the command

             ADMIT 4,40 OWNER or, on TOPS-20,

             ADMIT <LOPEZ> OWNER

   3.  SMITH closes the data set

   4.  SMITH may then choose to copy the data set to LOPEZ's area.   This
   last  step is optional but has the double advantage of making the data
   set easier for LOPEZ to use while removing clutter from SMITH's files.

   SECURITY                                                    Page 11-18
   Revision 3


   11.1.3  The PERMIT Command


   The PERMIT command allows the user who has opened the data set to gain
   access   for   a   single   session   to  attributes  that  have  been
   password-protected in the FOR clause of an ADMIT command.  The  syntax
   of the command is:

     PERMIT <attribute-1> PASSWORD <password-1> [ ACCESS READONLY ]

      [ FOR <attribute-2> PASSWORD <password-2> [ ACCESS READONLY ] ]...

   where:

   <attribute> is an attribute that has been  password-protected  in  the
   FOR clause of an ADMIT command and

   <password> is the password for the protected attribute.

   ACCESS READONLY, which may be abbreviated ACC RO, allows the  user  to
   examine  the  attribute  but not to update it even though the original
   ADMIT  command  may  have  granted  the  user  both  read  and   write
   privileges.   This  option  might  be  used if a user wanted to insure
   against inadvertently altering data during an inspection session.

   The  FOR  clause  allows  the   user   to   gain   access   to   other
   password-protected  attributes without having to issue multiple PERMIT
   commands.  Again, the provisions of a  PERMIT  hold  for  one  session
   only:   to gain access to password-protected attributes, the user must
   issue a new PERMIT command each time the data set is opened.

   PERMIT may be abbreviated PER, and PASSWORD may be abbreviated PASS.

   The following are examples of the PERMIT command:

        PERMIT LAST_NAME PASSWORD CCC

           This allows the user who has  opened  the  data  set  to  gain
           access  to  the  password-protected  attribute LAST_NAME.  The
           user gains the degree of access that was specified in the  FOR
           clause  of  the  original  ADMIT  command.   The user has this
           access as long as the data set stays open.

        PERMIT FIRST_NAME PASSWORD ABC FOR AGE PASSWORD DEF

           This allows the user who has  opened  the  data  set  to  gain
           access  to  the  password-protected  attributes FIRST_NAME and
           AGE.

   The PERMIT command  has  a  further  function:   if  you  have  update
   privileges  for  all  the  attributes in a data set, you can open that
   data set in such a way as to restrict your access to readonly for some
   attributes while maintaining update access for the others by issuing a
   SECURITY                                                    Page 11-19
   Revision 3


   PERMIT command with the clause  ACCESS  READONLY.   This  use  of  the
   PERMIT  command does not require a password and is more common in host
   language calls than in interactive 1022.

   For example:

        PERMIT LAST_NAME ACC RO

           This  command  limits  the  user's  access  to  the  attribute
           LAST_NAME to readonly for the current session.
   SECURITY                                                    Page 11-20
   Revision 3















                                 CHAPTER 12

                  PC INTERFACE: CREATING DIF AND WKS FILES



|  12.1  INTRODUCTION
|  
|  Enhancements to the INIT and PRINT commands under version 117B  enable
|  the  user  to  create files in Data Interchange Format (DIF) and Lotus
|  1-2-3 worksheet (WKS) format from within 1022 and to write  1022  data
|  directly to them *.  These files can then be down-loaded to a personal
|  computer with any of the standard communications  protocols  (such  as
|  Kermit) or accessed
|  with an integration tool (such as Mobius) for spreadsheeting or  other
|  PC  applications  **.  DIF files created from within 1022 are in 8-bit
|  ASCII format, and WKS files created from  within  1022  are  in  8-bit
|  binary format.  Care should therefore be taken when down-loading these
|  files to make sure that your communication protocol expects  an  8-bit
|  file rather than a standard TOPS-10 or TOPS-20 7-bit file.
|  
|  
|  
|  12.2  DIF FILES
|  
|  12.2.1  The INIT DIF Command
|  
|  The DIF option of the INIT command lets you create an 8-bit ASCII  DIF
|  file  from  within 1022.  A DIF file may be seen as a table of data in
|  which vectors and tuples correspond, respectively, to the columns  and
|  rows  of  a standard spreadsheet grid.  Each tuple (row) of a DIF file
|  is a uniform number of vectors  (columns)  wide.   Tuples  are  either
|  filled  with data or padded out with blanks.  A 1022 DIF file can have
|  up to 2^18-1 columns (vectors) and 2^18-1 rows (tuples).   The  syntax
|  of the INIT DIF command is:
|  
|       INIT DIF [ COL <c> ] [ ROW <r> ]
|  
|  .............
|  * DIF is a trademark of Software  Arts  Products  Corporation.   Lotus
|  1-2-3 is a registered trademark of Lotus Development Corporation.
|  
|  ............
|  ** Mobius  is  a  trademark  of  FEL  Computing,  a  division  of  FEL
|  Industries.
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-2
   Revision 4


|         [ NCOLS <n> ] <channel number> <file name>
|  
|  where:
|  
|  COL <c>         Directs 1022 to begin printing data at column  <c>  of
|                  the  DIF file when the first PRINT ON <channel number>
|                  command is given (see below).  <c>  is  an  alphabetic
|                  string   representing  a  spreadsheet  column  in  the
|                  sequence A,B,C,...Z,AA,AB...  within the range of A to
|                  NWTL.  The default is A.  When a letter greater than A
|                  is specified in the COL clause, 1022 prints blanks  in
|                  each  of  the  columns from A to column <c-1> and then
|                  begins printing data at column <c>.
|  
|  ROW <r>         Directs 1022 to begin printing data at row <r> of  the
|                  DIF  file  when  the  first  PRINT ON <channel number>
|                  command is given.  <r> is a positive integer between 1
|                  and  2^18-1.   The  default  is  1.   When  an integer
|                  greater than 1 is specified in the  ROW  clause,  1022
|                  fills each row of the file from 1 to <r-1> with blanks
|                  before printing data at row <r>.
|  
|  NCOLS <n>       Specifies the number of columns that the DIF  file  is
|                  to  have  in addition to any included as blanks as the
|                  result of a COL specification greater than A.  <n>  is
|                  a  positive integer between 1 and 2^18-1.  The default
|                  is 100.
|  
|                  System 1022 enforces the NCOLS limit  by  padding  out
|                  the  row  with  blanks  when  more  columns  have been
|                  specified than are needed to  hold  the  data  and  by
|                  truncating  any  print  list  that is too long for the
|                  number of columns specified.  In the  latter  case,  a
|                  warning  is  issued.   It is strongly recommended that
|                  you use the NCOLS option to limit the size of your DIF
|                  file for greatest efficiency.
|  
|  channel number  Is the number of the channel on which the DIF file  is
|                  to be created.  The number is between 1 and 8.
|  
|  file name       Is the name of the DIF file.  The default extension is
|                  .DIF.
|  
|  For example:
|  
|       INIT DIF 2 MYFILE
|  
|         This command creates the file MYFILE.DIF  on  channel  2.   The
|         file  will  be  100 vectors (columns) wide, and 1022 will begin
|         printing data at cell A1 (column A, row 1) when the first PRINT
|         ON  2  command  is given.  Rows only partially filled with data
|         will be padded out to 100 columns with blanks.
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-3
   Revision 4


|       INIT DIF COL B NCOLS 20 2 MYFILE
|  
|         This command creates the file MYFILE.DIF  on  channel  2.   The
|         file  will  be  21  vectors  wide.   When  the first PRINT ON 2
|         command is given, 1022 will write a blank in column A of row  1
|         and  then begin printing data at column B of row 1, padding out
|         any unfilled columns in the row with blanks.   Each  succeeding
|         PRINT  ON  2  command  will  write  a  blank in column A, begin
|         printing data at column B, and pad  out  any  unfilled  columns
|         with blanks.
|  
|  
|  
|  
|  12.2.2  Printing To A 1022 DIF File
|  
|  Once you have created a DIF file on a specified channel with the  INIT
|  DIF  command,  you  direct  1022  data  to that file with the PRINT ON
|  <channel number> command.  System 1022 data  types  are  automatically
|  converted  to  DIF  data  types.   Most of the conventional 1022 print
|  formats and defaults can be used to format the data written to the DIF
|  file.
|  
|  
|  
|  12.2.2.1  Data Type Conversion
|  
|  The DIF file standard  recognizes  only  two  data  types:   text  and
|  numeric.   Numeric  data  is represented by ASCII digit strings.  Text
|  data is represented by ASCII  character  strings  enclosed  in  double
|  quotation  marks.   When  1022  data  is  printed  to  a DIF file, its
|  representation as a string is essentially the same as it would  be  if
|  it  were  the output of a regular 1022 PRINT command.  Whether a given
|  string is interpreted as text or numeric is determined by an automatic
|  translation  between  1022 and DIF data types.  This translation takes
|  the following form:
|  
|            1022 Data Type --> DIF Data Type             ____ ____ ____     ___ ____ ____
|  
|            Integer            Numeric
|            Double Integer     Numeric
|            Real               Numeric
|            Date               Text
|            Text               Text
|  
|  Note the conversion of the 1022 Date type to  DIF  text.   This  means
|  that a 1022 date will appear as a text string in the DIF file and will
|  therefore not be able  to  be  used  in  any  calculations.   If  your
|  application  needs  a computational date, you can write one to the DIF
|  file with the 1022 command:
|  
|       PRINT ON <channel number> $INT(date-item)
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-4
   Revision 4


|  This will return the number of days since 1/1/1800  in  integer  form,
|  which  may  or  may  not  correspond  to  the  way in which the target
|  spreadsheet or application calculates computational dates.  If it does
|  not,  you can offset the $INT result by the appropriate amount to make
|  up the difference.
|  
|  
|  
|  12.2.2.2  Print Formats
|  
|  Most of the conventional 1022 print formats can be used in writing  to
|  a  DIF  file  with PRINT ON <channel number> commands.  The 1022 print
|  formats that are not supported in writing to DIF files are $, $3,  $4,                    ___
|  S, T, C, and L.
|  
|  With only two exceptions (X and /),  format  statements  in  PRINT  ON
|  <channel number> commands directed to DIF files produce text and digit
|  strings that are essentially the same as the ones normally produced by
|  1022  PRINT  commands.  PRINT ON <channel number> commands in which no
|  format statement is included assume the  customary  1022  defaults  (G
|  format).   The  default formats for Date, Text, Integer, and Real data
|  are illustrated in the example in the following section.
|  
|  Ordinarily, the X specification  in  a  1022  print  format  statement
|  generates a blank.  In a PRINT ON <channel number> command directed to
|  a DIF file, the X causes a vector (column) to be written as  a  blank.
|  Thus,  if  you  had  created  a DIF file with the standard defaults on
|  channel 2, the command
|  
|       PRINT ON 2 LAST_NAME FIRST_NAME FMT G 2X G END
|  
|  would print the value of the attribute LAST_NAME in  column  A,  print
|  blanks  in  columns  B  and  C,  and  print the value of the attribute
|  FIRST_NAME in column D.
|  
|  Similarly, while the / specification in a PRINT  command  generates  a
|  blank  line, in a PRINT ON <channel number> directed to a DIF file a /
|  causes a tuple (row) to be filled with blanks.  Thus, the command
|  
|       PRINT ON 2 LAST_NAME FIRST_NAME FMT 2A / END
|  
|  would print the value of LAST_NAME  in  column  A  and  the  value  of
|  FIRST_NAME  in column B of tuple (row) n and would fill the next tuple
|  (row n+1) with blanks before writing any more data to the file.
|  
|  
|  
|  12.2.2.3  Example
|  
|  A university administration  maintains  two  System  1022  data  sets,
|  STDNTS.DMS and WRKRS.DMS.  STDNTS.DMS contains information about every
|  currently enrolled student, including the grade point average (GPA) of
|  each  student.   WRKRS.DMS  contains  information  about every student
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-5
   Revision 4


|  employed by  the  university,  including  the  number  of  hours  each
|  employee  has worked during the past month (MTOT) and the total number
|  of hours each student has worked up to the beginning  of  the  present
|  month  (TOTH).   Every  student  is  uniquely identified by his or her
|  student-identification number (ID).  ID  is  an  attribute  common  to
|  STDNTS and WRKRS.
|  
|  The description files for the two data sets look like this:
|  
|                                STDNTS.DMD
|  
|       ATTRIBUTE STUDENT_ID ABBREV ID INTEGER KEYED COL 1 6
|       ATTRIBUTE GRADE_POINT_AVERAGE ABBREV GPA REAL COL 7 10
|  
|                                WRKRS.DMD
|  
|       ATTRIBUTE LAST_NAME ABBREV LN TEXT KEYED COL 1 15
|       ATTRIBUTE FIRST_NAME ABBREV FN TEXT COL 16 30
|       ATTRIBUTE STUDENT_ID ABBREV ID INTEGER KEYED COL 31 36
|       ATTRIBUTE YEAR_OF_BIRTH ABBREV YOB DATE COL 37 42
|       ATTRIBUTE HOURS_THIS_MONTH ABBREV MTOT REAL COL 43 48
|       ATTRIBUTE RATE_OF_PAY ABBREV RATE REAL COL 49 52
|       ATTRIBUTE HOURS_TO_DATE ABBREV TOTH REAL COL 53 58
|  
|  Periodically, someone at the university monitors the academic standing
|  of all student employees by running a PL1022 program (WARNEM.DMC) that
|  extracts information from STDNTS.DMS and WRKRS.DMS and writes it to  a
|  DIF  file (WARNEM.DIF) that is then down-loaded to a personal computer
|  and read into a spreadsheet.
|  
|  WARNEM.DMC and a sample of  its  output  (WARNEM.DIF)  are  reproduced
|  below.
|  
|                                WARNEM.DMC
|  
|       !WARNEM.DMC locates the student employees whose GPA's
|       !have fallen below 3.5 and writes their names, ID's,
|       !current GPA's, and total hours worked to date to
|       !the file WARNEM.DIF.
|  
|       OPEN STDNTS WRKRS.
|       JOIN STDNTS WRKRS VIA ID.
|       DBSET WRKRS.
|       FIND ALL.
|       SORT LN.
|       LET SYSIFTYPE 1.
|       INIT DIF NCOLS 5 2 WARNEM.DIF.  !We only need 5 columns
|                                       !to hold the data
|       PL START.
|       PRINT ON 2 SYSDATE.
|       REPEAT
|       GETREC LEAVE.
|       IF 1.GPA LT 3.5 THEN
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-6
   Revision 4


|       PRINT ON 2 LN FN ID 1.GPA MTOT+TOTH.
|       ENDIF.
|       UNTIL 1 EQ 2.  !Or until we run out of records
|       PL END.
|       RELEASE 2.
|  
|  
|                      WARNEM.DIF
|  
|                      TABLE
|                      0,1
|                      ""
|                      VECTORS
|                      0,00000005
|                      ""
|                      TUPLES
|                      0,00000006
|                      ""
|                      DATA
|                      0,0
|                      ""
|                      -1,0
|                      BOT
|                      1,0
|                      "11/19/1985"
|                      1,0
|                      ""
|                      1,0
|                      ""
|                      1,0
|                      ""
|                      1,0
|                      ""
|                      -1,0
|                      BOT
|                      1,0
|                      "AKHMAJIAN      "
|                      1,0
|                      "ARAM           "
|                      0,22446
|                      V
|                      0, 3.2500000
|                      V
|                      0, 460.00000
|                      V
|                      -1,0
|                      BOT
|                      1,0
|                      "GINGOLD        "
|                      1,0
|                      "SETH           "
|                      0,22296
|                      V
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-7
   Revision 4


|                      0, 3.0000000
|                      V
|                      0, 80.000000
|                      V
|                      -1,0
|                      BOT
|                      1,0
|                      "JONES          "
|                      1,0
|                      "ALBA           "
|                      0,22441
|                      V
|                      0, 3.0000000
|                      V
|                      0, 263.00000
|                      V
|                      -1,0
|                      BOT
|                      1,0
|                      "LENK           "
|                      1,0
|                      "MARGARET       "
|                      0,22223
|                      V
|                      0, 3.0000000
|                      V
|                      0, 320.00000
|                      V
|                      -1,0
|                      BOT
|                      1,0
|                      "NICHOLS        "
|                      1,0
|                      "JOSHUA         "
|                      0,22004
|                      V
|                      0, 3.2500000
|                      V
|                      0, 230.00000
|                      V
|                      -1,0
|                      EOD
|  
|  
|  
|  
|  If WARNEM.DIF were  then  read  into  a  spreadsheet,  it  would  look
|  something like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-8
   Revision 4


|  
|           A           B         C         D         E         F  
|  1    11/19/1985
|  2    AKHMAJIAN     ARAM       22446     3.25      460.00
|  3    GINGOLD       SETH       22296     3.00       80.00
|  4    JONES         ALBA       22441     3.00      263.00
|  5    LENK          MARGARET   22223     3.00      320.00
|  6    NICHOLS       JOSHUA     22004     3.25      230.00
|  7
|  8
|  9
|  10
|  
|  
|  
|  
|  12.2.2.4  Data-Positioning Information
|  
|  When writing to a DIF file, 1022 uses three internal counters to  keep
|  track  of  the tuple (row) and vector (column) to which it is printing
|  or is about to print.  One of these counters points to the tuple (row)
|  to which 1022 is printing or is about to print.  Another points to the
|  vector (column) to which 1022 is printing or is about to  print.   And
|  the  third  points  to the vector (column) to which 1022 will begin to
|  print data (as opposed to blanks) when a  PRINT  ON  <channel  number>
|  command is given.
|  
|  The user can ascertain the current position of  each  of  these  three
|  pointers  by  printing  the  current  value  of  each  of three system
|  variables:  SYSPCROW, SYSPCCOL, and SYSPCRESET.  SYSPCROW(n) points to
|  the  row (tuple) to which 1022 is printing or will begin printing when
|  the next PRINT ON <n> command is given.  And SYSPCCOL(n) points to the
|  column  (vector) to which 1022 is printing or will begin printing when
|  the next PRINT ON <n> command is given.  SYSPCRESET(n) points  to  the
|  column  (vector)  to which 1022 will begin printing data when the next
|  PRINT ON <n> command is given.
|  
|  SYSPCROW and SYSPCCOL are set by  default  to  0  when  the  INIT  DIF
|  command  is  given.   This means that 1022 will begin printing at cell
|  A1,  that  is,  at  tuple  1,  vector  1.   (SYSPCROW,  SYSPCCOL,  and
|  SYSPCRESET  are  all "zero-origin," so that the value of each variable
|  is  always  one  less  than  the  row  or  column  to  which   it   is
|  pointing.)  If  no  COL  clause  is specified in the INIT DIF command,
|  SYSPCRESET will also be set to 0 by  default.   Otherwise,  SYSPCRESET
|  has the value determined by the argument of the COL clause.  The value
|  of SYSPCROW(n) is incremented when each PRINT ON <n> command  finishes
|  executing.   A  /  print  format  statement  also  causes the value of
|  SYSPCROW(n) to be incremented during the execution of a PRINT  ON  <n>
|  command.   The  value  of SYSPCCOL(n) is incremented as a PRINT ON <n>
|  command executes and is reset to 0 when execution is completed.  An  X
|  format  statement also causes SYSPCCOL(n) to be incremented during the
|  execution of a PRINT ON <n> command.
   PC INTERFACE: CREATING DIF AND WKS FILES                     Page 12-9
   Revision 4


|  For example, suppose that the following two commands have been given:
|  
|       INIT DIF COL C ROW 3 2 MYFILE
|       PRINT ON 2 FIRST_NAME LAST_NAME FMT A X A /
|  
|  The command
|  
|       PRINT SYSPCROW(2)
|  
|  will return the value 4, since 1022 has printed two rows of blanks  as
|  a result of the ROW clause in the INIT command, has printed FIRST_NAME
|  and LAST_NAME on the third row, and  has  filled  the  next  row  with
|  blanks as a result of the / format statement, so the next row to which
|  1022 will print is row 5.
|  
|  The command
|  
|       PRINT SYSPCCOL(2)
|  
|  will return a value of 0, since 1022 always begins printing at  column
|  A, even if it is only printing blanks.
|  
|  The command
|  
|       PRINT SYSPCRESET(2)
|  
|  will return a value of 2 because the COL clause  specified  that  1022
|  was to begin printing data at column C.
|  
|  Another way of finding out the  tuple  and  vector  (row  and  column)
|  coordinates  of  the  cell  to  which 1022 is currently pointing is to
|  print the  value  of  the  system  function  $SYSPCPOS.   $SYSPCPOS(n)
|  returns  the ASCII representation of the cell to which SYSPCROW(n) and
|  SYSPCCOL(n) are currently pointing.  If the command
|  
|       PRINT $SYSPCPOS(2)
|  
|  were given immediately after the INIT and PRINT ON 2 commands  in  the
|  present example, the result would be A5.
|  
|  
|  
|  12.3  WKS FILES
|  
|  12.3.1  The INIT 123 Command
|  
|  You can create a WKS file from within 1022 with the INIT 123  command.
|  The INIT 123 command allows you to create a WKS format file with up to
|  2^16-1 columns and 2^16-1 rows.  The WKS files produced  by  the  1022
|  INIT  123 command are in Lotus 1-2-3 version 1A format.  The syntax of
|  the INIT 123 command is:
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-10
   Revision 4


|                                        { [ RWISE ] }
|       INIT 123 [ COL <c> ] [ ROW <r> ] {           }
|                                        { [ CWISE ] }
|  
|         [ [ NRANGE <name> <c1> <r1> <c2> <r2> ]... ]
|  
|           <channel number> <file name>
|  
|  where:
|  
|  COL <c>         Directs 1022 to begin printing at column  <c>  of  the
|                  WKS  file  when  the  first  PRINT ON <channel number>
|                  command is given (see below).  <c>  is  an  alphabetic
|                  letter  (A,  B,  C...Z)  or  or  string  of alphabetic
|                  letters (AA,  AB,  AC...AAA,  AAB...)  representing  a
|                  spreadsheet column within the range of A to CRXP.  The
|                  default is A.
|  
|  ROW <r>         Directs 1022 to begin printing at row <r> of  the  WKS
|                  file  when the first PRINT ON <channel number> command
|                  is given.  <r> is a positive  integer  between  1  and
|                  2^16-1.  The default is 1.
|  
|  RWISE           Directs 1022 to print to the WKS file top  to  bottom,
|                  filling  the  cells  of  a  single  column, row by row
|                  (rowwise),  with  each  PRINT  ON   <channel   number>
|                  command,  instead  of  printing left to right, filling
|                  each of the  cells  of  each  row,  column  by  column
|                  (columnwise).   This  option  is  especially useful in
|                  writing keyboard macros (see below).
|  
|  CWISE           Directs 1022 to print to the WKS file left  to  right,
|                  filling  the  cells  of a single row, column by column
|                  (columnwise), with  each  PRINT  ON  <channel  number>
|                  command.  CWISE is the default.
|  
|  NRANGE          Allows you to specify a Named Range in  the  WKS  file
|                  that you are creating:
|  
|                    <name>      Is the character string that  identifies
|                                the Named Range.  A name may be up to 15
|                                characters.   Names   longer   than   15
|                                characters  are  automatically truncated
|                                with a warning.
|                    <c1> <r1>   Are the column and row coordinates  that
|                                define the beginning of the Named Range.
|                                <c1> is  an  alphabetic  letter  (A,  B,
|                                C...Z)   or   or  string  of  alphabetic
|                                letters  (AA,  AB,   AC...AAA,   AAB...)
|                                representing a spreadsheet column within
|                                the range of  A  to  CRXP.   <r1>  is  a
|                                positive  integer  between 1 and 2^16-1.
|                                <c1> and <r1> must  be  separated  by  a
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-11
   Revision 4


|                                space.
|                    <c2> <r2>   Are the column and row coordinates  that
|                                define the end of the Named Range.  <c2>
|                                is an alphabetic letter (A, B, C...Z) or
|                                or string of alphabetic letters (AA, AB,
|                                AC...AAA,   AAB...)    representing    a
|                                spreadsheet column within the range of A
|                                to CRXP.  <r2>  is  a  positive  integer
|                                between  1  and  2^16-1.   <c2> and <r2>
|                                must be separated by a space.
|  
|                  You can specify as many Named Ranges as you wish.
|  
|  channel number  Is the number of the channel on which the WKS file  is
|                  to be created.  The number is between 1 and 8.
|  
|  file name       Is the name of the WKS file.  The default extension is
|                  .WKS.
|  
|  For example:
|  
|       INIT 123 2 MYFILE
|  
|         This command creates the file MYFILE.WKS  on  channel  2.   The
|         first  PRINT  ON  2 command will start writing 1022 data to the
|         file at cell A1.
|  
|       INIT 123 COL B 2 MYFILE
|  
|         This command creates the file MYFILE.WKS  on  channel  2.   The
|         first  PRINT  ON  2 command will start writing 1022 data to the
|         file at cell B1.
|  
|       INIT 123 COL J RWISE NRANGE \0 J 1 J 12 2 MYMAC
|  
|         This command creates the file MYMAC.WKS on channel 2.  The  COL
|         clause  directs  1022 to begin printing at cell J1 of the file.
|         The RWISE clause directs 1022 to  print  to  the  file  top  to
|         bottom  rather than left to right, that is, to direct output to
|         the cells in column J, row by row, with the first  PRINT  ON  2
|         command.   Subsequent PRINT ON 2 commands will direct output to
|         the cells in succeeding columns, row by  row,  top  to  bottom.
|         The  NRANGE  clause  specifies  that the file is to contain the
|         Named Range "\0" and that the range is to  consist  of  rows  1
|         through 12 of column J.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-12
   Revision 4


|  12.3.2  Printing To A WKS File
|  
|  Once you have created a WKS file on a specified channel with the  INIT
|  123  command,  you  direct  1022  data  to that file with the PRINT ON
|  <channel number> command.  System 1022 data  types  are  automatically
|  converted  to  Lotus  data types.  Most of the conventional 1022 print
|  formats, as well as the new "L" specifications, can be used to  format
|  the data written to a WKS file.  Three new system variables (SYSPCCOL,
|  SYSPCRESET, and SYSPCROW) and a new system function ($SYSPCPOS)  allow
|  you to control the positioning of the data in a WKS file.
|  
|  
|  
|  12.3.2.1  Data Type Conversion
|  
|  When 1022 data  is  printed  to  a  WKS  file,  1022  data  types  are
|  automatically  translated  into Lotus data types.  The results of this
|  translation vary according  as  L  specifications,  conventional  1022
|  print format statements, or unformatted print statements appear in the
|  PRINT ON <channel number> commands used to  write  to  the  WKS  file.
|  When  L  specifications  or  no  print format statements appear in the
|  PRINT ON <channel number> commands that write to  the  WKS  file,  the
|  following translations between data types are automatically made:
|  
|       1022 Data Type -->  Lotus Data Type        ____ ____ ____      _____ ____ ____
|  
|       Integer             Integer or Real.  If the 1022  integer  value
|                           is  greater  than +32767 or less than -32767,
|                           it is converted to  a  real.   Otherwise,  it
|                           remains an integer.
|  
|       Double Integer      Integer or real.  If the 1022 double  integer
|                           value  is  greater  than  +32767 or less than
|                           -32767,  it   is   converted   to   a   real.
|                           Otherwise, it remains an integer.
|  
|       Real                Real.
|  
|       Date                Integer or Real.  System 1022 stores  a  date
|                           as  a  binary integer equalling the number of
|                           days since 1/1/1800 (1/2/1800  =  1).   Lotus
|                           1-2-3  stores  a  date  as  a  binary integer
|                           equalling the number of days since 12/31/1899
|                           (1/1/1900   =   1).   When  a  1022  date  is
|                           translated   to   a    Lotus    date,    1022
|                           automatically  does  the necessary arithmetic
|                           to perform  the  conversion  correctly.   If,
|                           after  this  conversion,  the resulting Lotus
|                           integer is larger than 32767, it is converted
|                           to  a  real.   System 1022 defaults the Lotus
|                           display format of a date to (Lotus) D1.
|  
|       Text                Label  (Text).   Lotus  limits  the   maximum
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-13
   Revision 4


|                           length   of   a   Label  to  240  characters,
|                           including a Label Prefix  and  a  terminating
|                           null,  both  of which are automatically added
|                           to the string by 1022 during the  process  of
|                           translation.  The Label Prefix that 1022 adds
|                           is a single quotation  mark  (').   Any  1022
|                           text  expression  or  literal longer than 238
|                           characters will be truncated with  a  warning
|                           to  238  characters when it is written to the
|                           WKS file.
|  
|  When conventional 1022 print formats (A, I, F, G, and so on) are  used
|  in  printing to a WKS file, all 1022 data types are converted to Lotus
|  Labels (Text), regardless of the original 1022 data  type.   The  same
|  constraints  on  length  and  composition  that  apply to Lotus Labels
|  derived from 1022 Text  types  via  PRINT  ON  commands  containing  L
|  specifications  or  unformatted print statements apply in this case as
|  well.
|  
|  
|  
|  12.3.2.2  Print Formats
|  
|  In directing 1022 output to a WKS file  with  the  PRINT  ON  <channel
|  number>  command, you can control the format in which the data will be
|  represented by using a combination of format statements and  defaults.
|  A  special  set of specifications ("L formats") has been introduced to
|  facilitate this operation.  When no print  formats  are  specified,  L
|  formats, rather than the conventional 1022 G formats, are the default,
|  since it is through L formatting that binary data translation  between
|  1022  and Lotus 1-2-3 is enabled.  Most of the conventional 1022 print
|  formats can also be  used.   The  1022  print  formats  that  are  not                                                                      ___
|  supported in writing to WKS files are $3, $4, S, T, and C formats.
|  
|  Two 1022 data sets will be referred to in the examples that illustrate
|  the different print formats in the sections that follow.  The first of
|  these is STDNTS.DMS, and the second is WRKRS.DMS.  Both are maintained
|  by   a   university.   STDNTS.DMS  contains  information  about  every
|  currently enrolled student, including the grade point average (GPA) of
|  each  student.   WRKRS.DMS  contains  information  about every student
|  employed by  the  university,  including  the  number  of  hours  each
|  employee  has worked during the past month (MTOT) and the total number
|  of hours each student has worked up to the beginning  of  the  present
|  month  (TOTH).   Every  student  is  uniquely identified by his or her
|  student-identification number (ID).  ID  is  an  attribute  common  to
|  STDNTS and WRKRS.
|  
|  The description files for the two data sets look like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-14
   Revision 4


|                                STDNTS.DMD
|  
|       ATTRIBUTE STUDENT_ID ABBREV ID INTEGER KEYED COL 1 6
|       ATTRIBUTE GRADE_POINT_AVERAGE ABBREV GPA REAL COL 7 10
|  
|                                WRKRS.DMD
|  
|       ATTRIBUTE LAST_NAME ABBREV LN TEXT KEYED COL 1 15
|       ATTRIBUTE FIRST_NAME ABBREV FN TEXT COL 16 30
|       ATTRIBUTE STUDENT_ID ABBREV ID INTEGER KEYED COL 31 36
|       ATTRIBUTE YEAR_OF_BIRTH ABBREV YOB DATE COL 37 42
|       ATTRIBUTE HOURS_THIS_MONTH ABBREV MTOT REAL COL 43 48
|       ATTRIBUTE RATE_OF_PAY ABBREV RATE REAL COL 49 52
|       ATTRIBUTE HOURS_TO_DATE ABBREV TOTH REAL COL 53 58
|  
|  
|  
|  12.3.2.2.1  L Format
|  
|  You use L ("Lotus") format statements in a PRINT ON  <channel  number>
|  command  to  enable  the  conversion  of 1022 data types to Lotus data
|  types and to write 1022 data to a WKS file so that each item
|  will be displayed in the appropriate Lotus  version  1A  format.   The
|  form of an L format specification is
|  
|            (<r>)L(<m>).(<n>)
|  
|  where:
|  
|  <r>     Is an integer specifying a repeat count.  The default is 1.
|  
|  <m>     Is an integer specifying the Lotus format  type  (see  below).
|          The default is 12.
|  
|  <n>     Is an integer specifying the number of decimal  places  to  be
|          displayed (where n is between 1 and 15).  The default is 2 for
|          Lotus formats 1-5.
|  
|  In the case of an unformatted print statement in a PRINT  ON  <channel
|  number>  command that directs output to a WKS file, the default format
|  is L.
|  
|  The Lotus format types and their numbers are as follows:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-15
   Revision 4


|       Value of <m>        Lotus Display Format        _____ __ ___        _____ _______ ______
|  
|                 1         Fixed point
|                 2         Scientific notation
|                 3         Currency ($)
|                 4         Percent
|                 5         Comma
|                 6         +/- (bar graph)
|                 7         General
|                 8         Date (DD-MMM-YY)
|                 9         Date (DD-MMM)
|                 10        Date (MMM-YY)
|                 11        Text
|                 12        Default.    That   is,   both    no    format
|                           specification  and  a  plain  L specification
|                           with no following <m> default to L12.  L12 is
|                           the  global  format established for the 1-2-3
|                           worksheet, the sole exception being that  the
|                           default for a 1022 date is (Lotus) D1.
|  
|  The following command file  (WKS2.DMC)  and  its  output  (WRKRS2.WKS)
|  illustrate the use of L formats:
|  
|       OPEN WRKRS.
|       FIND ALL.
|       INIT 123  2 WRKRS.WKS.
|       PRINT ON 2 SYSDATE FMT L8 END. 
|       PRINT ON 2 "Last name" "First name" "Student ID" "YOB" - 
|        "Hours"  "Wage"  FMT 6L END.
|       PRINT ON 2 LN FN ID YOB MTOT RATE  -
|         FMT  3L L10 L1.1 L3  END. 
|       RELEASE 2.
|  
|  When WRKRS2.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-16
   Revision 4


|  A1: (D1) 31333                                                READY
|  
|          A          B           C         D         E         F        
|  1    12-Dec-85
|  2    First name   Last name  Student ID  YOB       Hours   Wage   
|  3    ARNOLDS      SARAH          22034   Feb-63      44.5    $3.50  
|  4    AKHMAJIAN    ARAM           22446   May-63      60.0    $3.50     
|  5    BARLOW       ELIZABETH      22330   Mar-63      40.0    $3.50     
|  6    GINGOLD      SETH           22296   Jul-63      20.0    $3.00      
|  7    ARMONICO     LESTRO         21502   Jun-62      80.0    $4.00  
|  8    MCMAHON      JEAN           22929   Oct-63      40.0    $3.50
|  9    NICHOLS      JOSHUA         22004   Mar-63      55.0    $3.50
|  10   LENK         MARGARET       22223   Apr-63      35.0    $3.50
|  11   JONES        ALBA           22441   Dec-62      20.0    $3.50
|  12
|  13
|  14
|  15
|  
|  
|  The following example illustrates the default case.  The command  file
|  (WKS1.DMC)  reads 1022 data of type Date, Text, Integer, and Real from
|  the data set WRKRS.DMS and writes it to a WKS file (WRKRS1.WKS)  using
|  PRINT  ON  <channel  number>  commands  in which there are unformatted
|  print statements:
|  
|       OPEN WRKRS.
|       FIND ALL.
|       INIT 123 2 WRKRS1.WKS.
|       PRINT ON 2 SYSDATE.
|       PRINT ON 2 "Last name" "First name" "Student ID" "YOB" -
|        "Hours" "Wage".
|       PRINT ON 2 LN FN ID YOB MTOT RATE.
|       RELEASE 2.
|  
|  When WRKRS1.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-17
   Revision 4


|  A1: (D1) 31333                                                READY
|  
|          A          B           C         D         E         F       
|  1    12-Dec-85
|  2    First name   Last name  Student ID  YOB       Hours   Wage   
|  3    ARNOLDS      SARAH          22034   15-Feb-63    44.5    3.5 
|  4    AKHMAJIAN    ARAM           22446   01-May-63      60    3.5    
|  5    BARLOW       ELIZABETH      22330   06-Mar-63      40    3.5    
|  6    GINGOLD      SETH           22296   13-Jul-63      20      3     
|  7    ARMONICO     LESTRO         21502   22-Jun-62      80      4
|  8    MCMAHON      JEAN           22929   15-Oct-63      40    3.5
|  9    NICHOLS      JOSHUA         22004   22-Mar-63      55    3.5
|  10   LENK         MARGARET       22223   16-Apr-63      35    3.5
|  11   JONES        ALBA           22441   12-Dec-62      20    3.5
|  12
|  13
|  14
|  15
|  
|  
|  
|  
|  
|  12.3.2.2.2  Other Formats
|  
|  12.3.2.2.3  Other Formats
|  
|  12.3.2.2.3.1  X, /, And $ Formats
|  
|  X, /, and $ format statements produce different results  depending  on
|  whether  the  output  of  the  PRINT  command  in which they appear is
|  directed to a columnwise WKS file, a rowwise WKS file, or  a  standard
|  7-bit ASCII file.
|  
|  When  1022  is  writing  to  a  standard  7-bit  ASCII  file,   an   X
|  specification  generates  a blank, a / specification generates a blank
|  line, and a $ suppresses the automatic <RET> that normally  occurs  at
|  the  end  of  a print list.  When you specify a $ format, 1022 directs
|  the output of the next PRINT command to the  same  line  as  the  last
|  instead of to a new line.
|  
|  When 1022 writes to a columnwise WKS file, the items in the print list
|  are  written  left  to  right,  one item to a cell, along a row.  An X
|  specification causes a cell in the current row to be skipped, and a  /
|  specification   causes  a  row  to  be  skipped.   A  $  specification
|  suppresses the end-of-list (EOL) action  that  normally  signals  1022
|  when  writing  to  a  columnwise  file to reset the column counter and
|  begin writing to the next row when the next PRINT ON <channel  number>
|  command  is  given.   When  you  specify  a $ format, 1022 directs the
|  output of the next PRINT ON <channel number> command to the next  cell
|  in current row instead of to the initial cell in the next row.
|  
|  When 1022 writes to a rowwise WKS file, the items in  the  print  list
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-18
   Revision 4


|  are  written  top  to  bottom,  one item to a cell, in a column.  An X
|  specification causes a cell in the current column to be skipped, and a
|  /  specification  causes  a  column  to be skipped.  A $ specification
|  suppresses the end-of-list (EOL) action  that  normally  signals  1022
|  when  writing  to  a  rowwise  file to reset the row counter and begin
|  writing to the next column when the next  PRINT  ON  <channel  number>
|  command  is  given.   When  you  specify  a $ format, 1022 directs the
|  output of the next PRINT ON <channel number> command to the next  cell
|  in  the  current  column  instead  of  to the initial cell in the next
|  column.
|  
|  The following table summarizes the results  of  X,  /,  and  $  format
|  statements  when  printing  to  standard  7-bit,  columnwise  WKS, and
|  rowwise WKS files.
|  
|  
|                                          Format
|                  ------------------------------------------------------
|                  |        X        |        /       |        $        |
|                  ------------------------------------------------------
|   7-Bit          |Inserts a space. |Inserts a blank |Suppresses <RET>.|
|    ASCII File    |                 |line.           |Next PRINT writes|
|                  |                 |                |to same line.    |
|                  ------------------------------------------------------
|   CWISE          |Skips a cell in  |Skips a row.    |Suppresses <EOL> |
|    WKS File      |the current row  |                |action. Next     |
|                  |                 |                |PRINT writes to  |
|                  |                 |                |same row.        |
|                  ------------------------------------------------------
|   RWISE          |Skips a row.     |Skips a cell in |Suppresses <EOL> |
|    WKS File      |                 |the current     |action. Next     |
|                  |                 |column.         |PRINT writes to  |
|                  |                 |                |to same column.  |
|                  ------------------------------------------------------
|  
|  
|  
|  The following command file (GPHRS1.DMC) and  its  output  (GPHRS1.WKS)
|  illustrate the use of X, /, and $ formats when writing to a columnwise
|  WKS file from within 1022.
|  
|                                GPHRS1.DMC
|  
|        !GPHRS1.DMC reads the names, student ID's, and grade point
|        !averages of the student workers and calculates the total
|        !number of hours that each has worked to date. This 
|        !information, which is drawn from the data sets WRKRS.DMS
|        !and STDNTS.DMS, is then written columnwise to a worksheet
|        !file, GPHRS1.WKS.
    
|  OPEN WRKRS STDNTS.
|  DBSET WRKRS.
|  FIND ALL.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-19
   Revision 4


|  SORT LN.
|  INIT 123  2 GPHRS1.WKS.
|  PRINT ON 2 SYSDATE FMT 2X  L8 //  END.  !Skip two cells, print date  
|  PRINT ON 2 "Last name" "First name" -   !in C1, then skip two rows.  
|    "Student ID" "GPA" "Total Hours" -    !Print in cells A4-E4, then  
|     FMT 5L / END.                        !skip a row. Next PRINT will   
|  PL START.                               !start writint at cell A6.
|  REPEAT
|  GETREC LEAVE.                      !Get ready to print on new row.
|  PRINT ON 2 LN FN ID FMT 3L $  END. !Print LN, FN, ID and hold row.
|  MAP TO STDNTS VIA ID.              !Go get corresponding record in
|  SORT LN.                           !other data set and print GPA
|  GETREC LEAVE.                      !on same row and hold row.
|  PRINT ON 2 GPA FMT  L1 $  END.     !Then go back to original record
|  DBS WRKRS.                         !in the first data set and print 
|  P ON 2  MTOT+TOTH FMT  L1 END.     !total hours on same row.
|  UNTIL 1 EQ 2.                      !Or until we run out of records.
|  PL END.
|  RELEASE 2.
|  
|  
|  When GPHRS1.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
|  
    
|  A1:                                                           READY
|  
|          A          B           C         D         E         F     
|  1                            12-Dec-85
|  2
|  3
|  4    First name   Last name  Student ID  GPA      Total Hours
|  5
|  6    AKHMAJIAN    ARAM           22446      3.25     460.00
|  7    ARMONICO     LESTRO         21502      3.50     560.00
|  8    ARNOLDS      SARAH          22034      3.50     371.00
|  9    BARLOW       ELIZABETH      22330      3.75     400.00
|  10   GINGOLD      SETH           22296      3.00      80.00
|  11   JONES        ALBA           22441      3.00     263.00
|  12   LENK         MARGARET       22223      3.00     320.00
|  13   MCMAHON      JEAN           22929      4.00     295.50
|  14   NICHOLS      JOSHUA         22004      3.25     230.00
|  15
|  
|  
|  The following command file (GPHRS2.DMC) and  its  output  (GPHRS2.WKS)
|  illustrate  the  use  of X, /, and $ formats when writing to a rowwise
|  WKS file from within 1022.
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-20
   Revision 4


|                                GPHRS2.DMC
|  
|        !GPHRS2.DMC reads the names, student ID's, and grade point
|        !averages of the student workers and calculates the total
|        !number of hours that each has worked to date. This 
|        !information, which is drawn from the data sets WRKRS.DMS
|        !and STDNTS.DMS, is then written rowwise to a worksheet
|        !file, GPHRS2.WKS.
|  
|  OPEN WRKRS STDNTS.
|  DBSET WRKRS.
|  FIND ALL.
|  SORT LN.
|  INIT 123 RWISE  2 GPHRS2.WKS.
|  PRINT ON 2 SYSDATE FMT ////  L8 2X  END.  !Skip four columns, print 
|  PRINT ON 2 "Last name" "First name" -     !date in E1, then skip two 
|   "Student ID" "GPA" "Total Hours" -       !rows. Print in cells A4-A8,  
|   FMT 5L / END.                            !then skip a column. Next
|  PL START.                                 !PRINT starts writing at C4.
|  REPEAT
|  GETREC LEAVE.                      !Get ready to print in new column.
|  PRINT ON 2 LN FN ID FMT 3L $  END. !Print LN, FN, ID and hold column.
|  MAP TO STDNTS VIA ID.              !Go get corresponding record in
|  SORT LN.                           !other data set and print GPA
|  GETREC LEAVE.                      !in same column and hold column.
|  PRINT ON 2 GPA FMT  L1 $  END.     !Then go back to original record
|  DBS WRKRS.                         !in first data set and print 
|  P ON 2  MTOT+TOTH FMT  L1 END.     !total hours in same column.
|  UNTIL 1 EQ 2.                      !Or until we run out of records.
|  PL END.
|  RELEASE 2.
|  
|  
|  When GPHRS2.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-21
   Revision 4


|  A1:                                                        
|  
|          A         B         C         D         E         F    
|  1                                              12-Dec-85
|  2
|  3
|  4    Last name            AKHMAJIAN  ARMONICO   ARNOLDS    BARLOW        
|  5    First name           ARAM        LESTRO    SARAH      ELIZABETH       
|  6    Student ID               22446       21502     22034       22330      
|  7    GPA                       3.25        3.50      3.50        3.75     
|  8    Total Hours             460.00      560.00    371.00      400.00    
|  9
|  10
|  11
|  12
|  13
|  14
|  15
|  
|  
|  
|  
|  12.3.2.2.3.2  Other 1022 Formats
|  
|  PRINT commands that direct output to WKS files can contain  statements
|  specifying  1022  print  formats  other  than L, X, /, and $.  Each of
|  these writes the 1022 data item to the WKS file as a Lotus Label (text
|  value).   Thus,  in  the  following  example,  the  values of the 1022
|  attributes LN (Text),  FN  (Text),  ID  (Integer),  YOB  (Date),  MTOT
|  (Real),  and  RATE (Real) are all written to WRKRS.WKS as text values.
|  As such, none can be used for computation.
|  
|  The following command file (WKS3.DMC) is essentially  a  copy  of  the
|  file  WKS2.DMC  that  was  used  to  illustrate  L  formats in Section
|  12.3.2.2.1 above but with the L formats changed to non-L formats.
|  
|                                 WKS3.DMC
|  
|  OPEN WRKRS.
|  FIND ALL.
|  INIT 123  2 WRKRS.WKS.
|  PRINT ON 2 SYSDATE FMT D1 END. 
|  PRINT ON 2 "Last name" "First name" "Student ID" "YOB" -
|   "Hours"  FMT 5A END.
|  PRINT ON 2 LN FN ID YOB MTOT RATE  -
|    FMT  2A I D2 G F$1.2  END. 
|  RELEASE 2.
|  
|  
|  When WRKRS.WKS is loaded into Lotus 1-2-3 and the  column  widths  are
|  adjusted, it looks like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-22
   Revision 4


|  A1: 'December 12, 1985
|  
|  
|          A           B             C           D           E             
|  1    December 12, 1985
|  2    First name   Last name  Student ID  YOB           Hours          
|  3    ARNOLDS      SARAH      22034       Feb-15-1963    44.500000
|  4    AKHMAJIAN    ARAM       22446       May-01-1963    60.000000
|  5    BARLOW       ELIZABETH  22330       Mar-06-1963    40.000000
|  6    GINGOLD      SETH       22296       Jul-13-1963    20.000000
|  7    ARMONICO     LESTRO     21502       Jun-22-1962    80.000000
|  8    MCMAHON      JEAN       22929       Oct-16-1963    40.000000
|  9    NICHOLS      JOSHUA     22004       Mar-22-1963    55.000000
|  10   LENK         MARGARET   22223       Apr-16-1963    35.000000
|  11   JONES        ALBA       22441       Dec-12-1962    20.000000
|  12
|  13
|  14
|  15
|  
|  
|  
|  
|  12.3.2.3  Example
|  
|  The following example illustrates the way in which a user might use  a
|  keyboard macro to format a WKS file created from within 1022.
|  
|  Using the WRKRS.DMS and STDNTS.DMS data sets, someone at a  university
|  periodically  monitors  the academic standing of all student employees
|  by running a PL1022 program  (WARNWK.DMC)  that  extracts  information
|  from STDNTS.DMS and WRKRS.DMS and writes it to a WKS file (WARNEM.WKS)
|  that is then down-loaded to a personal computer and  read  into  Lotus
|  1-2-3 for spreadsheeting.
|  
|  WARNWK.DMC is as follows:
|  
|       !WARNWK.DMC locates the student employees whose GPA's
|       !have fallen below 3.5 and writes their names, ID's,
|       !current GPA's, and total hours worked to date to
|       !the file WARNEM.WKS.
|  
|       OPEN STDNTS WRKRS.
|       JOIN STDNTS WRKRS VIA ID.
|       DBSET WRKRS.
|       FIND ALL.
|       SORT LN.
|       LET SYSIFTYPE 1.
|       INIT 123 2 WARNEM.WKS.
|       PL START.
|       PRINT ON 2 SYSDATE FMT X L10 / END.
|       PRINT ON 2 "Last Name" "First Name" "Student ID" -
|        "GPA" "Hours"  FMT 5L / END.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-23
   Revision 4


|       REPEAT
|       GETREC LEAVE.
|       IF 1.GPA LT 3.5 THEN                      !Alternate data set 
|       PRINT ON 2 LN FN ID 1.GPA MTOT+TOTH -     !reference to joined  
|         FMT 3A 2L1 END.                         !d/s gives  us GPA. LN,
|       ENDIF.                                    !FN, ID will be text.
|       UNTIL 1 EQ 2.
|       PL END.
|       RELEASE 2.
|  
|  
|  If WARNEM.WKS were then loaded into Lotus 1-2-3, it  would  look  like
|  this:
|  
|  A1:                                                         READY
|  
|           A         B         C         D         E         F        
|  1                Nov-85
|  2    
|  3    Last NameFirst NamStudent IGPA         Hours
|  4
|  5    AKHMAJIANARAM     22446         3.25     460.00 
|  6    GINGOLD  SETH     22296         3.00      80.00
|  7    JONES    ALBA     22441         3.00     263.00
|  8    LENK     MARGARET 22223         3.00     320.00
|  9    NICHOLS  JOSHUA   22004         3.25     230.00
|  10
|  11
|  12
|  13
|  14
|  15
|  
|  
|  The user would presumably then adjust the column widths with a  series
|  of   1-2-3   /Worksheet   Column   Set   commands   before   beginning
|  spreadsheeting  activities.    Alternatively,   instead   of   loading
|  WARNEM.WKS  directly  into  1-2-3,  the user could execute the command
|  file MACRO.DMC, which produces the file MACRO.WKS.  When MACRO.WKS  is
|  loaded into 1-2-3, it formats and loads WARNEM.WKS.
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-24
   Revision 4


|                                MACRO.DMC
|  
|       !MACRO.DMC produces the file MACRO.WKS, which
|       !contains a keyboard macro that sets the column
|       !widths for the worksheet WARNEM.WKS, which
|       !is then loaded with the Lotus File Combine command.
|  
|       INIT 123  COL J RWISE -     !Macro commands have to be in 
|         NRANGE \0  J 1 J 12 -     !single column; J is free; \0  
|           2 MACRO.WKS.            !executes immediately.
|       PRINT ON 2 "{goto}A1~" -    
|            "/WCS15~" -         !Make column A 15 characters wide.
|            "{goto}B1~" -
|            "/WCS15~" -         !Make column B 15 characters wide.
|            "{goto}C1~" -
|            "/WCS12~" -         !Make column C 12 characters wide.
|            "{goto}D1~" -
|            "/WCS5~" -          !Make column D 5 characters wide.
|            "{goto}E1~" -
|            "/WCS8~" -          ! Make column E 8 characters wide.
|            "{goto}A1~" -
|            "/FCCEWARNEM~".     !Load WARNEM.WKS.
|       RELEASE 2.
|  
|  
|  When MACRO.WKS is loaded into Lotus 1-2-3, it looks like this:
|  
|  A1:                                                        READY
|                A             B            C        D     E         
       
|  1                            Nov-85       
|  2
|  3     Last Name      First Name     Student ID  GPA  Hours
|  4
|  5     AKHMAJIAN      ARAM           22446       3.25  460.00
|  6     GINGOLD        SETH           22296       3.00   80.00
|  7     JONES          ALBA           22441       3.00  263.00
|  8     LENK           MARGARET       22223       3.00  320.00
|  9     NICHOLS        JOSHUA         22004       3.25  230.00
|  10
|  11
|  12
|  13
|  14
|  15
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-25
   Revision 4


|  12.3.2.4  Data-Positioning Options
|  
|  When writing to a WKS file, System 1022 keeps track  of  the  cell  to
|  which  it  is about to print by means of three internal counters.  One
|  of these points to the row on which 1022 is printing or  is  about  to
|  print;   another  points to the column on which 1022 is printing or is
|  about to print;  and the third points to the column (in  a  columnwise
|  file) or the row (in a rowwise file) to which 1022 will begin to print
|  at the beginning of the next PRINT ON <channel number> command.
|  
|  The user can assign initial values to these counters with the COL  and
|  ROW  clauses of the INIT 123 command and can manipulate these counters
|  in either of two additional ways in order to  direct  1022  output  to
|  specific rows and columns of a WKS file.
|  
|  One way of controlling data positioning is to use  the  X,  /,  and  $
|  formats  described  above  in  section  12.3.2.2.3.1.  In a columnwise
|  file, an X has the effect of incrementing the counter that  points  to
|  the  column  to  which 1022 is about to print;  a / increments the row
|  counter;  and a $ keeps the row counter from being incremented.  In  a
|  rowwise  file,  X  increments the row counter, / increments the column
|  counter, and $ keeps the column counter from being incremented.
|  
|  A second way  to  control  data  positioning  is  to  use  the  system
|  variables  SYSPCROW, SYSPCCOL, and SYSPCRESET.  SYSPCROW points to the
|  row to which 1022 is printing or is about to print.   SYSPCCOL  points
|  to  the  column  to which 1022 is printing or is about to print.  In a
|  columnwise file, SYSPCRESET points to the column to  which  1022  will
|  begin  printing  when  it  executes a PRINT command;  and in a rowwise
|  file, SYSPCRESET points to the row at which 1022 will  begin  printing
|  when it executes a PRINT command.
|  
|  In a columnwise file, SYSPCROW, SYSPCCOL, and SYSPCRESET are  all  set
|  by  default  to 0 when the INIT 123 command is given.  This means that
|  unless instructed otherwise, 1022 will begin printing to the WKS  file
|  at  cell A1.  (All three of these variables are "zero-origin," so that
|  the value of the variable is always one less than the row or column to
|  which  it is pointing.) At the end of each PRINT command, the value of
|  SYSPCROW is automatically incremented by 1, and SYSPCCOL is  reset  to
|  the  value  of  SYSPCRESET, so that the next PRINT command will direct
|  output to the next row, starting at column  A.   To  make  1022  start
|  printing at a column other than column A, assign the appropriate value
|  to SYSPCRESET and SYSPCCOL.
|  
|  In a rowwise file, SYSPCROW, SYSPCCOL, and SYSPCRESET are all  set  by
|  default  to  0  when  the  INIT 123 command is given.  This means that
|  unless instructed otherwise, 1022 will begin printing to the WKS  file
|  at  cell  A1.  At the end of each PRINT command, the value of SYSPCCOL
|  is automatically incremented by 1, and SYSPCROW is reset to the  value
|  of  SYSPCRESET,  so  that the next PRINT command will direct output to
|  the next column, starting at row 1.  To make 1022 start printing at  a
|  row  other  than row 1, assign the appropriate value to SYSPCRESET and
|  SYSPCROW.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-26
   Revision 4


|  To make 1022 skip rows and columns when printing to a  WKS  file,  you
|  can assign values to SYSPCROW, SYSPCCOL, and SYSPCRESET.  For example,
|  if you are writing to a columnwise WKS file on channel 2 and you  want
|  to  make  1022  begin each succeeding print row at column C, you could
|  give the following commands:
|  
|       LET SYSPCRESET(2) 2.
|  
|       LET SYSPCCOL(2) 2.     or     LET SYSPCCOL(2) SYSPCRESET(2).
|  
|  If you were about to print on row 4 and wanted to skip to row  5,  you
|  could issue the following command:
|  
|       LET SYSPCROW(2) 4.
|  
|  The system function $SYSPCPOS(n) returns the ASCII  representation  of
|  the  cell  to  which SYSPCROW(n) and SYSPCCOL(n) currently point.  For
|  example, if SYSPROW(2) is 3 and SYSPCCOL(2) is 5, the command
|  
|       PRINT $SYSPCPOS(2)
|  
|  will return the value F4.
|  
|  The following examples illustrate more fully the  ways  in  which  the
|  system  variables  SYSPCROW,  SYSPCCOL,  and  SYSPCRESET work.  In the
|  first example, the command file GPHRS3.DMC uses  values  for  SYSPCROW
|  and  SYSPCCOL  instead  of  X,  /,  and  $ formats to produce the same
|  columnwise  output  as  the  GPHRS1.DMC  described  above  in  section
|  6.3.2.2.2.1.    The   second  example  uses  SYSPCROW,  SYSPCCOL,  and
|  SYSPCRESET to produce  the  same  rowwise  output  as  the  GPHRS2.DMC
|  described in that section.
|  
|                                GPHRS3.DMC
|  
|        !GPHRS3.DMC reads the names, student ID's, and grade point
|        !averages of the student workers and calculates the total
|        !number of hours that each has worked to date. This
|        !information, which is drawn from the data sets WRKRS.DMS
|        !and STDNTS.DMS, is then written columnwise to a worksheet
|        !file, GPHRS3.WKS.
|  
|  OPEN WRKRS STDNTS.
|  DBSET WRKRS.
|  FIND ALL.
|  SORT LN.
|  INIT 123  2 GPHRS3.WKS.          !SYSPCCOL, SYSPCROW, SYSPCRESET 
|  LET SYSPCCOL(2) 2.               !all = 0. Reset SYSPCCOL; go to C1 to
|  PRINT ON 2 SYSDATE FMT L8  END.  !start printing. END resets SYSPCCOL 
|  LET SYSPCROW(2) 3.               !to 0, adds 1 to SYSPCROW. Go to A4;  
|  PRINT ON 2 "Last name" "First name" - !print some more. END of command 
|   "Student ID" "GPA" "Total Hours" -   !puts us at A5 by resetting
|   FMT 5L  END.                    !SYSPCCOL to 0, adding 1 to SYSPCROW.
|  LET SYSPCROW(2) 5.               !Go to A6 to print some more.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-27
   Revision 4


|  PL START.
|  REPEAT
|  GETREC LEAVE.
|  PRINT ON 2 LN FN ID FMT 3L END.    !END sends us to next row.
|  LET SYSPCROW(2) SYSPCROW(2)-1.     !Put us back on row we were just on.
|  LET SYSPCCOL(2) 3.                 !Get ready to print at column 4.
|  MAP TO STDNTS VIA ID.
|  SORT LN.
|  GETREC LEAVE.                      !Get corresponding record from other 
|  PRINT ON 2 GPA FMT  L1  END.       !d/s. Print GPA. END puts us on next 
|  DBSET WRKRS.                       !row. Go back to first data set.
|  LET SYSPCROW(2) SYSPCROW(2)-1.     !Put us back on row we were just on.
|  LET SYSPCCOL(2) 4.                 !Get ready to print at column 5.
|  PRINT ON 2 MTOT+TOTH FMT L1 END.   !Print value and go to next row.
|  UNTIL 1 EQ 2.                      !Or we run out of records.
|  PL END.
|  RELEASE 2.
|  
|  
|  When GPHRS3.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
|  
|  A1:                                                           READY
|  
|          A          B           C         D         E         F     
|  1                            12-Dec-85
|  2
|  3
|  4    First name   Last name  Student ID  GPA      Total Hours
|  5
|  6    AKHMAJIAN    ARAM           22446      3.25     460.00
|  7    ARMONICO     LESTRO         21502      3.50     560.00
|  8    ARNOLDS      SARAH          22034      3.50     371.00
|  9    BARLOW       ELIZABETH      22330      3.75     400.00
|  10   GINGOLD      SETH           22296      3.00      80.00
|  11   JONES        ALBA           22441      3.00     263.00
|  12   LENK         MARGARET       22223      3.00     320.00
|  13   MCMAHON      JEAN           22929      4.00     295.50
|  14   NICHOLS      JOSHUA         22004      3.25     230.00
|  15
|  
|  
|                                GPHRS4.DMC
|  
|       !GPHRS4.DMC reads the names, student ID's, and grade point
|       !averages of the student workers and calculates the total
|       !number of hours that each has worked to date. This
|       !information, which is drawn from the data sets WRKRS.DMS
|       !and STDNTS.DMS, is then written rowwise to a worksheet
|       !file, GPHRS4.WKS.
|  
|  OPEN WRKRS STDNTS.
|  DBSET WRKRS.
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-28
   Revision 4


|  FIND ALL.
|  SORT LN.
|  INIT 123 RWISE 2 GPHRS4.WKS.   !SYSPCCOL, SYSPCROW, SYSPCRESET all = 0.
|  LET SYSPCCOL(2) 3.             !Get ready to print at D1.
|  PRINT ON 2 SYSDATE FMT L8 END. !END sends us to next column (E1).
|  LET SYSPCCOL(2) 0.             !Put us at column 1.
|  LET SYSPCRESET(2) 2.           !Start each new PRINT at row 3.
|  LET SYSPCROW(2) 2.             !Start the next PRINT at row 3.
|  PRINT ON 2 "Last name" "First name" -  !END of this command will put us
|    "Student ID" "GPA" "Total Hours" -   !at row 3 (because we reset 
|    FMT 5L END.                          !SYSPCRESET) of the next column.
|  LET SYSPCCOL(2) 2.              !Get ready to print at column 3.
|  PL START.
|  REPEAT
|  GETREC LEAVE.                      
|  PRINT ON 2 LN FN ID FMT 3L END. !END puts us at row 3 of next column.
|  MAP TO STDNTS VIA ID.              
|  LET SYSPCCOL(2) SYSPCCOL(2)-1.  !Put us back on column we were just on.
|  LET SYSPCROW(2) 5.              !Get ready to print at row 6.
|  SORT LN.
|  GETREC LEAVE.
|  PRINT ON 2 GPA FMT L1 END.      !END puts us at row 3 of next column.
|  LET SYSPCCOL(2) SYSPCCOL(2)-1.  !Put us back on column we were just on.
|  LET SYSPCROW(2) 6.              !Get ready to print at row 7.
|  DBSET WRKRS.
|  PRINT ON 2 MTOT+TOTH FMT L1 END.
|  UNTIL 1 EQ 2.                   !Or until we run out of records.
|  PRINT $SYSPCPOS(2).             !See where next PRINT would start.
|  PL END.
|  RELEASE 2.
|  
|  
|  When GPHRS4.WKS is loaded into Lotus 1-2-3 and the column  widths  are
|  adjusted, it looks like this:
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-29
   Revision 4


|  A1:                                                        READY
|  
|          A         B         C         D         E         F        
|  1                                              12-Dec-85
|  2
|  3
|  4    Last name            AKHMAJIAN  ARMONICO   ARNOLDS    BARLOW        
|  5    First name           ARAM        LESTRO    SARAH      ELIZABETH       
|  6    Student ID               22446       21502     22034       22330      
|  7    GPA                       3.25        3.50      3.50        3.75     
|  8    Total Hours             460.00      560.00    371.00      400.00    
|  9
|  10
|  11
|  12
|  13
|  14
|  15
|  
   PC INTERFACE: CREATING DIF AND WKS FILES                    Page 12-30
   Revision 4















                                 APPENDIX A

                      SYSTEM 1022 FILE NAME EXTENSIONS



        EXTENSION                DESCRIPTION        _________                ___________


|          DIF    An 8-bit ASCII file in  Data  Interchange  Format.
|                 This  is  the default extension for a file created
|                 with the INIT DIF command.
|  
|  
|          DMA    A  source  file  containing  a  PL1022  or  report
|                 program suitable for input to the COMPILE command.
|                 This is the first default extension for  an  input
|                 file to the COMPILE command.
|  
|  
|          DMC    A  command  file  which   contains   System   1022
|                 commands.   This  is  the second default extension
|                 for an input file to the COMPILE command.


           DMD    A Description file.  It contains statements  which
                  describe a data set structure, and is used to load
                  a data set.


           DME    A file of record  numbers  pointing  to  data  set
                  records  which had errors while loading a data set
                  or in 1022 utilities.


           DMF    An error file written by System  1022  at  PERFORM
                  time  containing  the specification for the source
                  file from which the DMX  file  was  compiled,  the
                  version of 1022 under which the file was compiled,
                  and diagnostic error messages.


           DMH    A file containing System 1022 HELP messages.
   SYSTEM 1022 FILE NAME EXTENSIONS                              Page A-2
   Revision 4


           DMI    An input data file containing  the  data  used  to
                  load a new data set.


           DML    An AUDIT information file containing block  images
                  and data needed to restore a data set.


|          DMM    In the Large Data Sets Module, an  auxiliary  file
|                 of  a multifile data set that holds records or key
|                 tables.


           DMS    A 1022 data set file which holds the  information,
                  and  usually  the data, which makes up a data set.
                  We speak of this as the data set.


           DMV    A file written by the  System  1022  SAVE  command
                  containing SYSIDs which locate a group of records.


           DMX    A file written by the System 1022 COMPILE command.
                  A  DMX  file  contains a compiled PL1022 or report
                  program whose execution may be  initiated  by  the
                  System 1022 PERFORM command.
|  
|  
|          TMP    A scratch file that System  1022  creates  at  the
|                 beginning  of  each  session  for  use in building
|                 selection sets.
|  
|  
|          WKS    An 8-bit binary  file  in  Lotus  1-2-3  worksheet
|                 format.   This is the default extension for a file
|                 created with the INIT 123 command.












                                 APPENDIX B

                         SYSTEM 1022 RESERVED WORDS



   The following keywords are used in System 1022 commands.  These  words
   can not be used as attribute names or variables.

|       ALL            END            NBEG           TEXT
|       AND            EQ             NBEGINS        TEXTL
|       ANY            EQUAL          NBET           TEXTR
|       ASC            EQUALS         NBETWEEN       TO
|       ASCENDING      EQV            NCONT          TOT
|                                     NCT            TOTALS
|       BEG            FALSE          NE             TRUE
|       BEGINS         FILE           NEQ               
|       BET            FMT            NOMSG          UP
|       BETWEEN        FORMAT         NOREUSE        USING
|       BUFFER                        NOT               
|       BY             GE             NUL            VIA
|                      GT             NULL              
|       CONST                                        XOR
|       CONT           INT            ON                
|       CONTAINS       INTEGER        OR             $___
|       CORE                                         
|       CT             KEY            REAL              
|                                     REMOVE         
|       DATE           LAST           REUSE             
|       DBL            LE                               
|       DES            LT             SQ                
|       DESCENDING                    SQRT              
|       DINT           MAX            STDEV             
|       DOUBLE         MEAN           SYS___
|       DOWN           MIN
   SYSTEM 1022 RESERVED WORDS                                    Page B-2
   Revision 4















                                 APPENDIX C

                            1022 TIME DESCRIPTOR



   A System 1022 time specification has the following forms:

                FORM                              Example
                ----                              -------
              { HHMM     }                         1100PM
              { H:M:S    }                         2:5:0
              { H:M:SS   }    { AM }               2:5:05AM
              { H:MM:S   }  [ {    } ]             8:45:1AM
              ( H:MM:SS  }    { PM }               3:30:29
              { HH:MM    }                         20:00
              { HH:MM:SS }                         10:15:08PM

    
   Where:

   HH  - Is the time in hours,
         with value 0 to 24 when AM or PM is omitted,
         with value 0 to 12 when AM or PM is present.

   MM - Is the number of minutes, with value 0 to 59.

   SS - Is the number of seconds, with value 0 to 59.

   1022 TIME DESCRIPTOR                                          Page C-2
   Revision 4















                                 APPENDIX D

                                SEGMENTATION



   System 1022 is a segmented system on TOPS-10 systems.  It does not run
   as a segmented program on TOPS-20.  This appendix defines segmentation
   and describes how this affects 1022 performance.  The system variables
   SYSNOSEG  and  SYSNOSEGP  control segmentation;  the user or data base
   administrator may set the segmentation for greatest efficiency on  his
   or her computer.

   The System  1022  program  is  made  up  of  executable  units  called
   segments,  sections,  or overlays.  Each segment contains instructions
   for executing functions which fall naturally together.  A new  segment
   is  read  into computer memory when 1022 does a task which the current
   segment cannot do.  For  example,  the  user  types  commands  to  one
   segment  which  reads  them,  but  a  different  segment  executes the
   commands.

   Segmentation uses less computer memory than is needed to hold  all  of
   1022 at once.  Smaller jobs usually run more often under the scheduler
   of the computer operating system,  making  them  more  responsive.   A
   small  memory  size  reduces the chance that a System 1022 application
   will not run under the memory limitations found on some computers.

   Segmentation also has disadvantages.  Reading a new segment  from  the
   disk  or  drum requires time.  The overhead from this reading is large
   when a user program loop executes commands which require two different
   segments.   The  overhead  of  running in a larger memory size is then
   less than the switching of segments.

   System 1022 avoids segmentation overhead by grouping common  run  time
   functions  together.   All common PL1022 actions are in one segment so
   that no switching is necessary.  However, some commands can be used in
   a  PL1022  procedure  that  require a different segment.  Segmentation
   overhead is large when these are included in a small  loop.   The  SET
   command is an example.

   Segmentation overhead is  usually  not  a  problem  in  host  language
   systems.   All DBcalls are implemented in the resident segment, except
   for  DBEXEC.   DBEXEC  calls  the  interactive  system  by   switching
   segments.   A  host  language  application incurs visible segmentation
   overhead only when many DBEXEC calls are used for very short tasks.
   SEGMENTATION                                                  Page D-2
   Revision 4


   Segmentation overhead may not appear at all  on  machines  with  large
   memory  configurations.  TOPS-10 often permits idle segments to remain
   in core, with the result that segment switching requires  no  disk  or
   drum I/O.

   Segmentation is usually a disadvantage on a  machine  with  a  virtual
   memory  (VM)  monitor.  The VM operating system should be able to keep
   needed core size low while accessing all parts  of  a  large  program.
   Therefore, System 1022 runs as a non-segmented program on TOPS-20 (see
   below).

   Observe segmentation with the following techniques.  See  the  segment
   changes  as  they  occur  by  typing  the  monitor  command "SET WATCH
   VERSION" before running  System  1022  under  TOPS-10.   Each  segment
   change  will  be reported.  You can also estimate segment I/O overhead
   by sampling  the  execution  state  of  the  program  you  run.   Type
   control-T  during  execution  to  see what state the program is in.  A
   process which is often in I/O WAIT for a file with  extension  EXE  or
   SHR is probably being slowed by segmentation.

   The system variables SYSNOSEG and SYSNOSEGP control  the  segmentation
   of System 1022 on TOPS-10.  System 1022 runs in segments when SYSNOSEG
   is 0.  1022 runs as one large program  when  SYSNOSEG  is  set  to  1.
   SYSNOSEG  is  0 by default for TOPS-10 users.  SYSNOSEGP controls 1022
   segmentation systemwide.  When SYSNOSEGP is -1, the value of  SYSNOSEG
   controls  this.  When SYSNOSEGP is 1, 1022 runs unsegmented.  SYSNOSEG
   can be set by users;  SYSNOSEGP can be set only by the DBA.   You  can
   use  these  to control segmentation if the default is not efficient on
   TOPS-10.  On TOPS-20 SYSNOSEG and SYSNOSEGP have no effect.












                                 APPENDIX E

                         SYSTEM 1022 ERROR MESSAGES



   The following is a complete list of  the  error  messages  printed  by
   System  1022.  The error conditions are coded by an error type number,
   and, within each type, an error  code  number.   These  identification
   numbers are returned to a host language program on an error trap.
|  
|  The System 1022 error messages are listed here in the following order:
|  
|            TYPE 1:   Command Scanner Errors (CS)
|            TYPE 2:   FIND and SAVE Errors (FI)
|            TYPE 3:   File Damaged Errors (FD)
|            TYPE 4:   OPEN Errors (OP)
|            TYPE 5:   Miscellaneous Errors (MI)
|            TYPE 6:   Format or Print Output Errors (FO)
|            TYPE 7:   Update Errors (UP)
|            TYPE 8:   SORT Errors (SO)
|            TYPE 9:   I/O Errors (IO)
|            TYPE 10:  Fatal System Errors (SY)
|            TYPE 11:  Out of Core Errors (CO)
|            TYPE 12:  PL1022 Errors (PL)
|            TYPE 14:  Host Language Errors (HL)
|            TYPE 15:  LOAD and APPEND Errors (LD)
|            TYPE 16:  TRANSACT Errors (TR)
|            TYPE 18:  AUDIT Errors (AU)
|            TYPE 19:  Debugging Errors (DB)
|            TYPE 20:  SPSS Interface Errors (SP)
|            TYPE 21:  COMPILE/PERFORM Errors (CP)






   E.1  TYPE 1:  COMMAND SCANNER ERRORS (CS)

   CS1    RELATIONAL FOLLOWS ARITHMETICAL OR LOGICAL
          In FIND commands, one relational follows another in an  illegal
          pattern.   Note:   "OR  GT 30" is legal, but "EQ OR", "XOR GT",
          are illegal.
   SYSTEM 1022 ERROR MESSAGES                                    Page E-2
   Revision 4


   CS2    LOGICAL FOLLOWS LOGICAL
          The presence of a logical (e.g. AND) requires that a new  value
          or  attribute  begin.   Here, another logical follows, which is
          meaningless.  Note "OR EQ 30" is legal, "OR AND" is not.

   CS3    VALUE WAS REQUIRED
          Syntax required that  a  value  follow  (like  after  GT),  but
          something else was found.

   CS4    ILLEGAL AUDIT COMMAND KEYWORD
          The word following AUDIT is not a valid audit subcommand.   The
          legal  audit subcommands are:  START, LIST, BACKUP, CHECKPOINT,
          CHECK, COMMENT, MERGE, CLEAR, RECOVERY, and FIX.

   CS5    DATE-TIME SPECIFICATION REQUIRED HERE
          The word following SINCE in an audit command  is  not  a  legal
          date-time specification.  (See Appendix C).

   CS6    CHECKPOINT, CHECK, OR AN INTEGER REQUIRED HERE
          In the AUDIT  BACKUP  and  LIST  commands  FROM  LAST  must  be
          followed  by  either the keyword CHECKPOINT (abbreviated CHECK)
          or an integer specifying the number of checkpoints to go back.

   CS7    OVER PUSHED AN @FILE LEVEL (10 IS MAX)
          An @file-descriptor reference calls in the 21th nested file  in
          command reading, probably due to a "loop" in the references.

   CS8    CHECKPOINT NAME REQUIRED HERE
          Either no checkpoint name has been specified or the name is not
          acceptable.

   CS9    AUDIT MERGE ILLEGAL IN PL1022 SEGMENT
          The audit merge command is restricted from use within a  PL1022
          segment, between PL START and PL END.

   CS10   ILLEGAL WITHOUT AUDIT FILE OPEN
          The  given  audit  command  cannot  be  executed   without   an
          accessible audit file to operate on.

   CS12   ARITHMETIC OVERFLOW IN NUMBER, OR NON NUMERIC CHAR
          A numeric input  is  illegal,  either  because  it  contains  a
          non-digit character, or because it is too large to be stored.

   CS13   OUT OF ROOM IN INSIDE COMMAND BUFFER
          1022 has a  very  large  capacity  to  hold  commands,  but  an
          extremely long one might not fit.

   CS14   KEYWORD NOTHING, QUERIES, OR UPDATES REQUIRED HERE
          One of these three keywords must follow the word ALLOW  in  the
          AUDIT RECOVERY command.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-3
   Revision 4


   CS15   UNEXPECTED LEFT OR RIGHT PAREN
          A parenthesis has cut off the ending of a descriptive group.

   CS16   MORE RIGHT THAN LEFT PARENS
          The parentheses are unbalanced.   We  know  immediately,  since
          there  can  never  legally  be  more  closing  parentheses than
          opening ones.

   CS17   MORE RIGHT THAN LEFT PARENS IN A BASIC SELECTOR GROUP
          The parentheses may not be totally out of balance, but they are
          unbalanced since the last attribute group started.

   CS18   NEEDED AN ATTRIBUTE NAME
          The user has omitted the name of an attribute where the command
          syntax  requires  one.   Check  to make sure that all attribute
          values are preceded by the appropriate attribute names.

   CS19   UNBALANCED PARENS IN AN ATTRIBUTE GROUPING
          The parentheses don't match in describing  the  last  attribute
          group.

   CS20   UNBALANCED PARENS IN A COMMAND
          The parentheses don't match taken as a whole in the command.

   CS21   HIT A NULL PAREN GROUP IE ( )
          1022 doesn't allow meaningless null groups in FIND commands.

   CS22   A NOT FOLLOWS AN ARITHMETIC RELATIONAL
          In a command like 'FIND AGE EQ NOT 30', the 'NOT'  follows  the
          relator  'EQ'.  This is a confusing use of a logical at a point
          where 1022 expects only an arithmetic  expression.   'FIND  AGE
          NOT 30', or 'FIND AGE NOT EQ 30' are legal.

   CS23   EXPRESSIONS NESTED TOO DEEPLY
          More than 10 intermediate values have to be saved at  the  same
          time to decode the FIND command.  This is highly unlikely, like
          having a true 10 level parenthetical expression which cannot be
          expressed in fewer parenthetical groups.

   CS24   INVALID COMMAND
          The command word typed does not match or is not a  long  enough
          abbreviation for a System command.

   CS25   INVALID ATTRIBUTE FOR SPECIFIED DATA SET
          In a MAP command, the attribute named in the TO data set or the
          one  to  be  matched  in the TO data set is not an attribute in
          that data set or it is not KEYED and therefore cannot  be  used
          in the MAP.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-4
   Revision 4


   CS26   BAD # COMMAND
          The item #<word> does not match any immediate command.

   CS27   ILLEGAL FILE COMMAND KEYWORD
          A file subcommand must immediately  follow  the  FILE  command:
          TYPE  (abbreviated  TYP),  RENAME  (REN), COPY (COP), or DELETE
          (DEL).

   CS28   PERIOD EXPECTED HERE
          There are no more parts to the command,  but  another  word  is
          encountered.   The  usual  cause  of  this  problem is that the
          optional keywords are out of sequence.

   CS29   VALUE BUFFER OVERFLOW
          A single word is more than 250 characters long, and is too  big
          for  the  word  buffer.  Text between double-quotes counts as a
          single word to 1022.

   CS30   KEYWORD DAMAGE EXPECTED HERE
          The IGNORE command must be  followed  by  the  keyword  DAMAGE.
          This is the only option.

   CS31   DATA SET NOT OPEN
          This command requires that  a  data  set  be  open  for  it  to
          operate.   Usually  this means it is meaningless without a data
          set open.

   CS32   SAVE FILE NOT ALLOWED IN SEARCH
          The "FILE file-descriptor"  option is only allowed  in  a  FIND
          command, not in SEARCH.

   CS33   BAD FILE OR DEVICE SPECIFICATION
          A  file-descriptor  has  illegal  form,  or  contains   illegal
          characters.

   CS34   ON CLAUSE HIT TWICE IN PRINT COMMAND
          There are two attempts to specify an output device in one PRINT
          command.

   CS35   TOO MANY ATTRIBUTES IN A SORT DESCRIPTION
          The SORT command has a limit of 20 sort expressions at the same
          time.

   CS36   OUT OF ROOM IN A BUFFER
          One of the internal data areas has expanded, and  there  is  no
          more room.  This happens when too little core is available.

|  CS37   TEXT ATTRIBUTE REQUIRED FOR CONTAINS OR BEGINS OR MATCHES
|         In a relational expression, the relational  operator  CONTAINS,
|         NCONTAINS,  BEGINS,  NBEGINS,  MATCHES,  or  NMATCHES  must  be
|         followed by an attribute of the data type TEXT.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-4A
   Revision 4


          CS38   ILLEGAL OR REPEATED PARAMETER
          A parameter (usually a reserved word) is specified incorrectly,
          out of range, or is repeated twice.

   CS39   TOTALS LIST NOT AT END
          In a PRINT command, a print list containing totals functions or
          identified  as  the  totals  list  is followed by another print
          list, or what looks like one in some way.

   CS40   ON CLAUSE IN ILLEGAL POSITION
          The ON clause must be the first thing encountered  in  a  PRINT
          command.

   CS41   UNEXPECTED RESERVED WORD
          1022 has encountered a reserved  word  too  soon.   Usually,  a
          required value has been left out.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-4B
   Revision 4



























                     [ This page intentionally left blank ]
   SYSTEM 1022 ERROR MESSAGES                                    Page E-5
   Revision 4


   CS42   FILENAME TOO LONG (3 CHARACTERS MAXIMUM)
          A tempcore filename may not contain more than three characters.

   CS43   FUNCTION HAS NO EXPRESSION
          In a PRINT command, a totals list  function  has  no  following
          expression to evaluate.

   CS44   USER ID OR KEYWORD CLASS REQUIRED HERE
          ADMIT   must   be   followed   by   the   keyword   CLASS,    a
          project-programmer number, or a user directory name.

   CS45   TEXT IN ARITHMETIC EXPRESSION
          An arithmetic expression  can  contain  arithmetic  attributes,
          values, and variables, but no text or text valued items.

   CS46   INCOMPLETE COMMAND
          A command has terminated too soon;  the termination leaves  the
          command incomplete.

   CS47   UNEXPECTED OPERATOR OR RIGHT PAREN
          In evaluating an expression, 1022 has seen  either  an  illegal
          character,  or  an  arithmetic  operator  or parenthesis in the
          wrong place.

   CS49   UNBALANCED PARENTHESES
          Unbalanced  parentheses  have  been  found  in  an   arithmetic
          expression.  Usually this is noticed on the next word following
          the expression.

   CS50   UNRECOGNIZED WORD
          The last word read can't be decoded to mean anything.

   CS51   DATA NOT OF EXPECTED TYPE
          The user has typed an expression or data  to  compare  with  an
          attribute  or  variable which is not of the same type (numeric,
          text) as that attribute.  For example, 1022 expected a  number,
          and the user typed text.

   CS52   UNEXPECTED LEFT PAREN
          A left parenthesis cuts off part of the current command clause.

   CS53   UNIMPLEMENTED DATA TYPE
          Report this to Software House.

   CS54   NULL TOTALS CLAUSE
          The user has started a totals list in a PRINT command, and then
          just ended it with nothing inside.

   CS55   NOT AN INTEGER
          1022 expected an integer parameter, and didn't get one.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-6
   Revision 4


   CS56   OUT OF LEGAL RANGE
          A number supplied by the user is not in the right  value  range
          for the particular purpose of the command.

   CS57   COMMAND OUT OF CONTEXT (EG.  REPORTS)
          Certain commands can only be used in some contexts, in a report
          section,  or  PL1022 program section.  Others are only legal in
          the interactive mode, outside these  sections.   The  user  has
          supplied  a  command  which  is  legal,  but not in the current
          section.  It is difficult to decide what the user intended, and
          since  the  command  might  be legal in many other sections, no
          attempt is made to  decide  what  section  the  command  should
          appear in.

   CS58   NO PRINT IN REPORT
          A simple REPORT program is required to have a PRINT command for
          purposes of syntax.  It can be a null PRINT command, but it has
          to be included.  See REPORTS.

   CS59   CHARACTER NOT ALLOWED HERE
          A general message when a confusing special character appears at
          the wrong place.

   CS60   ATTRIBUTE AS VALUE NOT ALLOWED IN FIND
          Value expressions in a SEARCH command are unrestricted and  may
          contain  attributes,  (SEARCH SALARY EQ BONUS+30).  But in FIND
          commands, the value expressions cannot contain attribute names;
          all  values  must  be independent of a particular record of the
          data base.

   CS61   ATTRIBUTE REFERENCED TWICE
          The same attribute is named twice in a command list.

   CS62   UNKEYED ATTRIBUTE
          An unkeyed attribute has been  specified,  usually  in  a  FIND
          command where all attributes for selection must be keyed.

   CS63   VALUE TOO LARGE
          Either the numeric value of a user  entry  is  larger  than  is
          allowed  for  a  particular  attribute, or a text string is too
          long.  This usually happens with integer attributes  that  have
          limited ranges.

   CS65   NEEDED LOGICAL OR ATTRIBUTE
          The syntax of the command led 1022 to expect  a  new  attribute
          group, either started by a logical or an attribute name.

   CS66   FILE NOT FOUND
          The user specified a file-descriptor for a file that can not be
          found.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-7
   Revision 4


   CS67   TEXT LENGTH (AN INTEGER) REQUIRED HERE
          The user has not given a text length in a DEFINE command.

   CS68   NOT IN REPORT
          The user tried to execute a command, like REPORT END, which  is
          legal only if 1022 is in a REPORT program.

   CS69   EXTRA WORD IN COMMAND
          The requirements of the command have been  met,  but  there  is
          still  something  left over.  For safety, this is flagged as an
          error.

   CS70   ATTRIBUTE PROTECTED FROM ADD OR CHANGE
          An attempt has been made to change an attribute which can't  be
          changed  by the user.  These are Date of Change, Date of Entry,
          Integer of Identification, and possibly others.

   CS71   ILLEGAL OCTAL PPN
          The user has supplied a number which is to be interpreted as  a
          user's  project-programmer  number, or a generic PPN containing
          *.  Either the format is illegal, or the numbers are not octal.

   CS72   EXPECTED A RESERVED WORD
          Syntax required a choice be indicated by a reserved  word,  but
          it doesn't match any ones legal at this point.

   CS73   TECO EXPECTS TEXT ATTRIBUTE
          The TECO ATT command can only be used on text attributes.

   CS74   NOT IN PL1022 SEGMENT
          The user has tried to do something which requires  being  in  a
          PL1022  segment.  In particular, trying PL END without being in
          PL1022 will give this message.

   CS76   ERRORS SEEN, PL1022 OR REPORT EXECUTION STOPPED
          The scan of a PL1022 or REPORT segment is  continued  past  any
          errors  in  the segments so that more than one syntax error can
          be detected on each scan.  At the end, this informational error
          message  indicates  that the segment is not runnable because of
          errors found.

   CS77   BAD RELATIONAL EG. EQ GT
          The command format required the specification of a  relational,
          but the word did not match one.

   CS78   CANNOT KEY TEXT GT 80 CHARS
          The user has requested key tables to be generated  for  a  text
          attribute with a length greater than 80 characters.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-8
   Revision 4


   CS79   NOT A DATA SYMBOL
          The last word encountered may already be defined  as  a  label,
          but  it  is  not  a data symbol, i.e. not a user variable.  The
          symbol must be defined as a variable before  being  used.   The
          same  name  can  be  used  for  a  variable and a label without
          confusion.

   CS80   VARIABLE MUST START WITH LETTER
          The user has attempted to define a variable that doesn't  start
          with a letter (i.e. A to Z).

   CS81   INVALID DATA SET SPECIFIED
          The data set specified for a DBSET command is not open;   or  a
          numeric data set identifier is out of range.

   CS82   MULTIPLE MATCH TO DATA SET NAME
          The data set name specified in a  DBSET  command  matches  more
          than one open data set.

   CS83   ALREADY DEFINED - CAN'T REDEFINE
          The user is trying to define the same  label  again.   This  is
          illegal, since 1022 can't change the assignments in midstream.

   CS84   COMMAND NOT ALLOWED IN GROUP2 REPORT SECTION
          A REPORT has  an  internal  syntax  which  must  be  respected.
          Report  statements  which belong in the Main Print group cannot
          be used once the Totals On Change group has begun.  This  error
          happens  when the user is not clear about what can go where, or
          has mis-inserted a new statement.

   CS86   HEADING OR FOOTING INSIDE MAIN REPORT SECTION
          Heading and Footing must appear  before  the  first  On  Change
          control  group  starts.   Here  the  group has started when the
          Heading or Footing is encountered.

   CS87   UNAUTHORIZED COMMAND -- ADMIT PROTECTED
          Due to the ADMIT protection on the data base, this  command  is
          not  allowed.   This  error message appears, for example, if an
          ADD command is tried  on  a  data  base  with  global  READONLY
          protection  or  if an INFORM ADMIT command is issued by someone
          other than the data base owner..

   CS88   UNAUTHORIZED ATTRIBUTE -- ADMIT PROTECTED
          The ADMIT protection on this attribute  prevents  using  it  in
          this command.  There is no password to give, so the restriction
          cannot be removed in this user area.

   CS89   UNAUTHORIZED ATTRIBUTE, NEED PASSWORD
          Due to the ADMIT protection of the  data  base,  the  attribute
          requires a password before the user can access it.

   SYSTEM 1022 ERROR MESSAGES                                    Page E-9
   Revision 4


   CS90   ALREADY AN ATTRIBUTE IDENTIFIER
          The new name or abbreviation given in a MODIFY command attempts
          to duplicate an already existing attribute identifier.

   CS91   TOTALS FUNCTION NOT ALLOWED HERE
          Incorrect use of a totals function (TOT MIN MAX MEAN)  such  as
          in a subscript.

   CS92   FUNCTION REQUIRES LEADING PARENTHESIS
          Functions that have more than one argument require  parentheses
          around their argument lists.

   CS93   CAN'T NEST TOTALS FUNCTIONS
          The user has written a total of a total.

   CS94   INVALID PRINT ASSIGNMENT CONSTRUCTION
          This is incorrect use of the EQ operator in a PRINT statement.

   CS95   INITIAL SECTION MUST START REPORT WHEN USED
          In a general report, where SECTION commands are  used,  SECTION
          INITIAL must immediately follow the REPORT START command.

   CS96   SECTION INITIAL MUST BE THE FIRST STATEMENT IN A COMPLEX REPORT
          In a report that uses SECTION commands, SECTION INITIAL must be
          the first section.

   CS97   VALUE CANNOT BE USER ASSIGNED
          The user cannot assign a value to a reserved  system  variable,
          or   to   an  attribute,  using  a  LET  or  EVALUATE  command.
          Attributes may be assigned values using the CHANGE command.

   CS98   REPORT SECTION OUT OF SEQUENCE
          A SECTION command is missing, or out  of  order,  in  a  report
          program.

   CS99   NOT ALLOWED IN NEW REPORTS
          The USING command is an obsolete feature in sectioned reports.

   CS100  GENERAL INTERNAL ERROR -- PLEASE REPORT
          This is printed for many "impossible" internal conditions.  The
          situation  which  causes the error should be noted and reported
          as a System bug.

   CS101  I/O ERROR IN READING
          A data error occurred in reading or writing a file.

   CS102  NOT CALLED FROM HOST LANGUAGE
          A HOST command returns control to a host language program,  but
          no host language program is in use.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-10
   Revision 4


   CS103  CONTINUATION LABEL NOT PROVIDED
          The DBEXEC subroutine was called with a command  that  required
          line  continuation, but the optional line continuation argument
          was not provided.

   CS104  NO ATTRIBUTES QUALIFY FOR COMMAND
          A command is meaningless because there are no keyed  attributes
          in the data base to act on.

   CS105  SOS CANNOT BE USED TO CHANGE ATTRIBUTES
          Unlike TECO, the SOS editor is not  interfaced  into  the  1022
          logic  for changing the value of an attribute.  SOS can only be
          used for editing files on the disk.

   CS106  INDIRECT FILE COULD NOT BE PROCESSED
          The  requested  indirect  file,  one   referenced   by   an   @
          construction or in a USE command, can not be located.

   CS107  ONLY DOUBLE INTEGER SUPPORTED
          The only double precision data type supported by 1022 is double
          precision integer.

   CS108  VARIABLE NAME REQUIRED HERE
          A variable name must be specified here.  Usually, the  user  is
          trying to define a reserved word as a variable.

   CS109  REPEATED, UNKNOWN, OR ILLEGAL CLAUSE
          A general error message which may be given  when  (1)  a  valid
          clause  word  is  mistakenly used twice, (2) the clause word is
          unknown to the command where it is used,  or  (3)  this  clause
          word  does not combine with the other options already specified
          for this command.

   CS110  NO INPUT DATA SPECIFIED
          A LOAD, TRANSACT, APPEND, or similar command does not name  the
          input data file.

   CS111  APPEND-TRANSACT FROM SET EXCLUDES DESC CLAUSE
          When an APPEND or TRANSACT is done from another data  set,  the
          structure  is  contained  in  the data set, and the user cannot
          supply a different one.

   CS112  NO OUTPUT CLAUSE SPECIFIED
          A general message given when  the  user  does  not  specify  an
          output file or data set in a command that requires one.

   CS113  BUNDLED DATA SETS CANNOT HAVE A DATA FILE
          When DUMPing to a standard,  bundled  data  set,  the  data  is
          contained  in  that  data  set.  A separate data file cannot be
          associated with this form of data  set,  but  the  data  clause
          appeared in the command.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-11
   Revision 4


   CS114  NO LOCATOR LIST SPECIFIED
          A TRANSACT command uses locators to compare transaction records
          with  master  records.   This  command did not give any locator
          list.

   CS116  SYNC OPTION REQUIRES SORTED TRANSACTIONS
          The SYNC option in the TRANSACT  command  requires  the  SORTED
          option at the same time.

   CS117  DATA CLAUSE REQUIRES DESC CLAUSE
          When doing transactions from a data file, the DESC clause  must
          be given so that 1022 may properly read the data.

   CS118  DESC CLAUSE IS REQUIRED
          The CREATE command requires that a DESC clause be included.

   CS119  TYPES INCOMPATIBLE
          An arithmetic operation or  assignment  requires  a  conversion
          which  is  not  permitted.   This  only  occurs  if there is no
          reasonable interpretation for the operation or assignment,  for
          example DATE * DATE or assigning a text string to an integer.

   CS120  '(' REQUIRED HERE
          A subscript or parameter list was expected here.

   CS121  ')' REQUIRED HERE
          After recognizing all  required  subscripts  to  an  array,  or
          parameters  to  a  function, a terminating right parenthesis is
          required.  Usually this error is caused by omitting  the  right
          parenthesis or specifying too many subscripts or parameters.

   CS122  ARGUMENT OF ILLEGAL TYPE
          The argument to a system function is not of an acceptable type.
          For example, MIN (text-attribute).

   CS123  UNRECOGNIZED SYMBOL OR RESERVED WORD
          The symbol appearing  here  is  not  acceptable  as  either  an
          attribute,  variable,  or  operator.   The most common cause of
          this error is a mistyped variable name or operator.

   CS124  INTERNAL INCONSISTENCY IN GVLD - PLEASE REPORT
          An internal 1022 error has been  detected.   While  this  error
          should  never occur it is provided for added user security.  If
          encountered, exit 1022 and start over.  In addition, report the
          problem  to the 1022 system maintainer.  No damage to your data
          base is implied by this error.

   CS125  SYSTEM FUNCTION NOT PERMITTED HERE
          A value may not be assigned to a system function.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-12
   Revision 4


   CS126  TOTALS FUNCTION NOT PERMITTED HERE
          A Totals function may not be used in a LET statement.  Use  the
          EVALUATE statement for this purpose.

   CS127  ',' REQUIRED HERE
          A subscript or parameter is not delimited properly.

   CS128  ILLEGAL VARIABLE NAME
          An attempt has been made to define  a  variable  name  starting
          with  SYS, or identical to a system function name.  These names
          are reserved for use by 1022.

   CS130  TOO MANY DIMENSIONS (MAXIMUM 7)
          Too many dimensions  have  been  specified.   1022  supports  a
          maximum of seven dimensions.

   CS131  ARRAY BOUNDS MUST BE INTEGERS
          The bounds specified for an array must be integer constants.

   CS132  ARRAY BOUND OUT OF LEGAL RANGE
          The integer array bound is too large or small.

   CS133  LOWER BOUND GREATER THAN UPPER BOUND
          The lower bound must be less than or equal to the  upper  bound
          in an array definition.

   CS134  VARIABLE PREVIOUSLY DEFINED DIFFERENTLY
          A variable name may only be redefined if its new definition  is
          identical to the previous definition.

   CS135  CHECKPOINT DESIGNATOR REQUIRED HERE
          Either a checkpoint name or number is required.

   CS136  KEYWORD INTEGER REQUIRED HERE
          The keyword INTEGER is required following the  keyword  DOUBLE.
          This permits other double data types in the future.

   CS137  INVALID USER NAME
          The user name does not exist.

   CS138  DBSET - DATA SET NOT OPEN IN PL1022 SEGMENT
          A DBSET command does not name an open data set.

   CS139  STRING TOO LONG
          The string given as an argument was too  long.   Refer  to  the
          explanation  of  the  command  in  the  manual  for the maximum
          permitted length.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-13
   Revision 4


   CS140  QUOTED STRING EXPECTED HERE
          A string enclosed by quotation marks is the required item.

   CS141  ILLEGAL CONVERSION OF CONSTANT REQUIRED
          The type of the variable given as an argument to CONST was  not
          compatible  with  the type of value required.  Most frequently,
          this is caused by CONST ( <text variable> )  where  an  integer
          was required.  In such a case, use the @= construction.

   CS142  IMPROPER CONSTANT SUBSCRIPT SPECIFICATION
          The subscripts (indices) to an  array  argument  to  the  CONST
          function  are not correctly specified.  This error may indicate
          too many subscripts, too few  subscripts,  an  illegally  typed
          subscript,   or   an   illegal   character   in  the  subscript
          specification.

   CS143  CONSTANT SUBSCRIPT OUT OF BOUNDS
          The subscript (index) of an array used as an  argument  to  the
          CONST  function  is  not  within  the bounds specified for that
          array.

   CS144  ILLEGAL REFERENCE WITHOUT DATA SET OPEN
          A reference to SYSID is made without a data set OPEN.  This  is
          meaningless.

   CS145  UNTERMINATED LITERAL ENDS COMMAND FILE
          A  quoted  string  continues  across  a  command  file   level.
          Usually, this error is a missing quote in the command file.

   CS146  UNTERMINATED REPORT OR PL1022 SEGMENT ENDS COMMAND FILE
          A PL1022 or REPORT program is started but not terminated within
          a command file.

   CS147  BOTH FROM AND SINCE CLAUSES MAY NOT BE SPECIFIED
          The FROM and SINCE clauses in an  AUDIT  command  are  mutually
          exclusive  since  they  are  alternate  methods of specifying a
          point in the audit trail.

   CS149  NOT AN UNBUNDLED DATA SET
          The RELOCATE DATA command only has  meaning  for  an  unbundled
          data set.

   CS151  BACK SELECTION FAILURE IN PTPBLK - PLEASE REPORT
          This is an internal error message which is only issued when  an
          inconsistency  is  detected.   No  damage  to  the  data set is
          implied by this  message.   However,  QUIT  1022  and  restart.
          Please report this message to your 1022 maintainer.

   CS152  UNTERMINATED PL1022 SEGMENT IN A REPORT
          A PL START within a REPORT does not have a matching PL END.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-14
   Revision 4


   CS153  FILENAME EXPECTED HERE
          A filename is required here and the  supplied  word  is  not  a
          filename.

   CS154  OUTSIDE PL1022 SEGMENT TERMINATES IN A REPORT
          A PL END without a matching PL START is seen within the REPORT.

   CS155  REQUIRED CLAUSE OMITTED
          A required clause or keyword is omitted.   Consult  the  manual
          for a full description of the syntax of the command.

   CS156  PASSWORD REQUIRED AFTER ADMIT CLASS
          An admit command that sets up  a  user  class  must  include  a
          password for that class.

   CS157  TRANSACT OR APPEND TO SAME DATA SET NOT ALLOWED
          In order to transact or append from a data set to itself,  open
          the  data  set twice and transact or append one data set to the
          other.

   CS158  BOOLEAN VALUE NOT PERMITTED HERE
          The user has inserted a logical expression (such as AGE LT  65)
          where one is not allowed (such as immediately after ELSE).

   CS159  BOOLEAN VALUE REQUIRED HERE
          The user has neglected to include a complete logical expression
          (such   as  AGE  LT  65)  as  required  in  an  IF,  WHILE,  or
          REPEAT...UNTIL statement.

   CS160  ILLEGAL CONTROL STRUCTURE (MISSING END OR UNTIL)
          The user has neglected to close an  IF--THEN(--ELSE)  or  WHILE
          statement with END or a REPEAT statement with UNTIL.

   CS161  ELSEIF OR ELSE NOT ALLOWED HERE
          ELSEIF and ELSE may only occur as parts  of  an  IF  statement.
          The syntax is:
          IF <Boolean expression> THEN <commands>
          [ELSEIF <Boolean expression> THEN <commands>]
          [ELSE <commands>]
          END[IF]

   CS162  END NOT ALLOWED HERE
          The user has attempted to employ the terminator END other  than
          to close an IF--THEN(--ELSE) or WHILE statement.

   CS163  PL1022 BACK SELECTION FAILURE - PLEASE REPORT
          The user has been unable to return to an original open data set
          after  cycling  through  all  open  data  sets.  This should be
          reported to Software House.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-15
   Revision 4


   CS164  END OR UNTIL ILLEGAL OUTSIDE OF STRUCTURED COMMANDS
          The user has employed the terminator END  or  UNTIL  without  a
          preceding initiator (IF, WHILE, or REPEAT).

   CS165  THEN REQUIRED HERE
          THEN has been omitted from an IF or ELSEIF statement containing
          a command block.  The syntax is:
          IF <Boolean expression> THEN <commands>
          [ELSEIF <Boolean expression> THEN <commands>]...
          END[IF].

   CS166  DO REQUIRED HERE
          DO has been omitted from a WHILE statement.  The syntax is:
          WHILE <Boolean expression> DO <commands>
          END[WHILE].

   CS167  COMMAND NOT ALLOWED IN PL1022 OR REPORT
          The user has attempted to issue a  command  (such  as  COLLECT)
          that  is  allowed  in  interactive  1022 but not in a PL1022 or
          report program.

   CS168  INCORRECT BLOCK TERMINATOR
          The user has either attempted to close an IF, WHILE, or  REPEAT
          statement  with  the  wrong  terminator  or  else has failed to
          include a terminator where one is required by the syntax.

   CS169  COMMAND ONLY ALLOWED IN PL1022 OR REPORT
          The user has attempted to issue a command (such as LEAVE)  that
          is  only  allowed  in  a  PL1022  or  report program and not in
          interactive 1022.

   CS170  FEATURE HAS NOT BEEN PURCHASED BY YOUR SITE
          The user has attempted to issue a command  (such  as  ADMIT  or
          AUDIT  START)  that  is  part  of  an optional feature (such as
          ADMIT/PERMIT security or AUDIT trails) which  the  user's  site
          has  not  purchased.   Your  site  administrator should contact
          Software Hous e to obtain the feature.

   CS171  ILLEGAL JOIN NAME
          A join name must begin with a letter and  may  not  be  a  1022
          reserved word.

   CS172  CONFLICTS WITH EXISTING JOIN DEFINITION
          The user has either attempted to assign a non-unique name to  a
          join  relation or else has tried to join two data sets that are
          already joined.  Issue the INFORM JOIN command to see which  is
          the case.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-16
   Revision 4


   CS173  MAP TO SAME DATA SET NOT ALLOWED
          A MAP may only occur between two open data sets with  different
          names,  namely,  the  current  (source) data set and the target
          data set.  To MAP to the same data set, open  that  set  twice,
          each  time  giving it a different alias.  If you do not wish to
          MAP t o the same data set, use the DBSET command  to  establish
          the desired source set and then MAP to the desired target set.

   CS174  MAP OR JOIN BY SYSID IS ILLEGAL FOR COLLECTIONS
          The user has attempted to join  or  map  between  two  or  more
          collections via SYSID.  This is not allowed in System 1022.

   CS175  AMBIGUOUS ATTRIBUTE NAME
          The user has attempted to reference an attribute common to  two
          or  more  open  data sets, neither of which is the current one.
          To allow such referencing, SYSAMBATTR must be set to 1.

   CS176  NO JOINS EXIST
          The user has issued an ENABLE JOIN or DISABLE JOIN command when
          no joins have been previously defined.

   CS177  DOUBLE PRECISION ATTRIBUTES MAY NOT BE KEYED
          The user has attempted to key an attribute whose data  type  is
          DOUBLE INTEGER.  This is not allowed in System 1022.

   CS178  REFERENCE TO AN ELEMENT OF A COLLECTION ILLEGAL
          Data sets serving as constituents of a collection can  only  be
          referenced or accessed as part of that collection.

   CS179  ATTEMPT TO COLLECT A JOINED DATASET
          Joined data sets may not form part of a collection.  To collect
          the  desired  data  sets, issue a CLEAR JOIN command and then a
          COLLECT command.

   CS180  ATTEMPT TO COLLECT INCOMPATIBLE DATASETS
          All data sets in a collection must be identical in structure.

   CS181  ATTEMPT TO COLLECT A DATASET ALREADY IN COLLECTION
          A collection or a data set already  in  a  collection  may  not
          serve  as  a  constituent  of  another  collection.   To form a
          collection of the desired data  sets,  use  the  CLEAR  COLLECT
          command and issue a new COLLECT command.

   CS182  COLLECTION NAME ALREADY IN USE
          The user has attempted  to  name  a  collection  by  using  the
          internal  name,  file  name,  or alias of some open data set or
          collection.  Collection names must be unique.

   CS183  COLLECTION NAME TOO LONG
          Collection names may not be more than 25 characters long.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-17
   Revision 4


   CS184  COMMAND NOT ALLOWED WHEN DBSET TO A COLLECTION
          Certain commands (such as KEY and VALUES) may not be applied to
          collections.   To  use these commands, you must issue the CLEAR
          COLLECT command and then access each data set separately.

   CS185  COLLECTION NAME SYNTAX ERROR
          The user has attempted to name a collection using one  or  more
          disallowed  characters.   Collection  names  must  contain only
          letters, numerals, or underscores.

   CS186  COLLECTION NAME DOES NOT EXIST
          The user has attempted to reference a nonexistent collection or
          has  used the wrong name in attempting to reference an existing
          collection.  An INFORM COLLECT command will yield the names  of
          existing collections.

   CS187  NO HELP AVAILABLE FOR THIS TOPIC
          The user has either typed the incorrect keyword or keywords for
          a  HELP  topic or has requested HELP on a topic for which there
          is no message on line.

   CS188  HELP FILE--1022.DMH--UNAVAILABLE
          The System Administrator has failed to put 1022.DMH in the same
          area  as  1022.   Please  report  this  message  to your System
          Administrator.

   CS189  HELP FILE--1022.DMH--NOT IN PROPER FORMAT
          A validation check has shown that the file named  1022.DMH  has
          not  been  properly  installed.   Please report this message to
          your System Administrator.

   CS190  INVALID 1022.DMH FILE VERSION NUMBER
          The 1022.DMH version number is not the same as the current 1022
          version  number.   Please  report  this  message to your System
          Administrator.

   CS191  1022.DMH HELP FILE IS DAMAGED
          The 1022.DMH file is damaged.  The System Administrator  should
          reprocess HELP22.TXT.

   CS192  EXPECTED A RESERVED WORD OR ATTRIBUTE
          In  issuing  the  TRANSACT  command,  the  user  has   omitted,
          misspelled,   or   otherwise  misspecified  an  attribute  name
          following the LOCATOR keyword.

   CS193  COULD NOT OPEN PERFORM FILE
          System 1022 was unable to open the file specified in a  PERFORM
          command, usually because the file does not exist.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-18
   Revision 4


   CS194  COMMAND NOT ALLOWED IN COMPILED 1022
          An illegal  command  has  been  included  in  the  source  file
          specified  in a COMPILE command.  See the "COMPILE and PERFORM"
          section of Chapter 8.

   CS195  FIRST COMPILED COMMAND DID NOT INITIATE PL1022
          The opening command in the source file specified in  a  COMPILE
          command  is  other than one of the required ones (PL1022 START,
          REPORT START, WHILE, REPEAT, or IF).

   CS196  1022 VERSION SKEW IN PERFORM--PLEASE RECOMPILE
          Either the major version of System  1022  has  changed  between
          COMPILE  time  and  PERFORM  time,  or  a  change between minor
          versions of the system has  introduced  incompatibilities  that
          make  it impossible to PERFORM the file in its present compiled
          form.  The user should recompile the source file.

   CS197  PREMATURE EOF IN PERFORM FILE
          PERFORM has encountered an EOF in the input file before reading
          in all the necessary information for execution.  This indicates
          that the file has been truncated or otherwise damaged since  it
          was compiled.  The user should COMPILE the source file.

   CS198  OUT OF CORE--PERFORM COMMAND
          More memory is needed to execute the PERFORM command.

   CS199  FORMAT ERROR IN PERFORM FILE--PLEASE RECOMPILE
          The user has attempted to PERFORM a file that has  either  been
          damaged  since  it  was  compiled  or  is  not an output of the
          COMPILE command.  The user should COMPILE the source file.

   CS200  NO DATA SETS FOUND OPEN DURING PERFORM
          The user has attempted to PERFORM a file containing a  compiled
          program  that references one or more data sets but no data sets
          are presently open.  A diagnostic message in the  corresponding
          DMF  error file lists the data set(s) that need to be opened be
          fore PERFORM can execute the program.

   CS201  NON-RECOVERABLE  PERFORM  ERROR  (DATA  SET   MATCHING)--PLEASE
          REPORT
          The user should not encounter this message, as it  indicates  a
          System  1022 bug.  If this message appears, please report it to
          Software House.

   CS202  NON-RECOVERABLE PERFORM ERROR (REF. TBL.)--PLEASE REPORT
          The user should not encounter this message, as it  indicates  a
          System  1022 bug.  If this message appears, please report it to
          Software House.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-19
   Revision 4


   CS203  ERRORS SEEN IN PERFORM ENVIRONMENT CHECK
          PERFORM  has  encountered  an  error  in  either  the  variable
          environment or the data set environment, or both.  A diagnostic
          message in the  corresponding  DMF  error  file  indicates  the
          specific nature of the problem.

   CS204  AMBIGUOUS HELP KEYWORD
          The user has abbreviated a keyword by typing a character string
          with which more than one keyword begins.

   CS205  ERROR CREATING COMPILE OUTPUT FILE
          System 1022 was unable to open the specified output file  of  a
          COMPILE  command.   The diagnostic I/O system message preceding
          this message indicates the nature of the problem.

   CS206  ZERO-LENGTH COMPILE SOURCE FILE
          The source file specified in a COMPILE command is a  null  file
          and so cannot be compiled.

   CS207  SPECIFIED ATTRIBUTE CAN NOT BE ADDITIVE
          The user has attempted to change the nonadditive  status  of  a
          date,  text, or integer of identification attribute to additive
          with the MODIFY $ATTRIBUTE command.  This is not allowed.
|  
|  CS208  ILLEGAL REFERENCE TO CURRENT DATA SET ATTRIBUTE
|         The user has tried to use an attribute name in the current data
|         set as an argument in an ADD command.  This is not allowed.
|  
|  CS209  ILLEGAL REFERENCE TO A JOINED ATTRIBUTE
|         The user has tried to use an  attribute  name  in  a  data  set
|         joined  to  the  current  one as an argument in an ADD command.
|         This is not allowed.
|  
|  CS210  ILLEGAL DEVICE IN PC INIT
|         INIT 123 and INIT DIF require output to a file.  Output to  the
|         terminal is not allowed.
|  
|  CS211  ILLEGAL COL DESCRIPTOR
|         The column descriptors in COL and NRANGE clauses  of  the  INIT
|         123  and INIT DIF commands must be alphabetic strings.  For 123
|         files, such a string must be within the range  of  A  to  CRXP.
|         For  DIF  files, such a string must be within the range of A to
|         NWTL.
|  
|  CS212  ILLEGAL ROW DESCRIPTOR
|         The row descriptors in the ROW and NRANGE clauses of  the  INIT
|         123  and  INIT  DIF command must be positive integers.  For 123
|         files, such an integer must be between 1 and 2^16-1.   For  DIF
|         files, such an integer must be between 1 and 2^18-1.
|  
|  CS214  ILLEGAL NCOLS ARGUMENT
|         The NCOLS keyword in an INIT DIF command  requires  a  positive
|         integer argument.  This integer must be between 1 and 2^18-1.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-20
   Revision 4


|  CS215  KEYWORD ALL NOT ALLOWED WITH LOCK ON USERLOCK
|         The LOCK ON USERLOCK command requires a  string  of  up  to  25
|         characters  as its argument.  ALL is not allowed as an argument
|         for the LOCK ON USERLOCK command.







   E.2  TYPE 2:  FIND AND SAVE ERRORS (FI)


   FI1    ATTRIBUTE NOT KEYED
          An attribute in a FIND command is not a keyed  attribute.   All
          attributes used in a FIND command must be keyed.

   FI2    SAVE CMD OR FILECLAUSE OPEN OR ENTER ERROR
          System 1022 received a monitor error attempting to do the  open
          or  enter  for  a  SAVE  command,  or  the  FILE part of a FIND
          command.

   FI3    FILECLAUSE FILE NOT FOUND
          The file specified in the FILE part of a FIND command  was  not
          found.

   FI4    ATTRIBUTE TOO LONG FOR MAPPING
          The attribute in the source data set must not be  greater  than
          80 characters in length.

   FI5    MAP TO SAME DATA SET NOT ALLOWED
          A MAP must be between two open data sets.  In order to  MAP  to
          the same data set, OPEN the data set twice.

   FI6    NOT A DMV FILE FOR CURRENT DATA SET
          The DMV file specified by a FIND FILE command was not  for  the
          current data set.
|  
|  FI7    ERROR IN FIND COMMAND
|         A FIND command has failed to execute because  of  data  set  or
|         disk damage.
|  
|  FI8    UNIMPLEMENTED ATTRIBUTE CONVERSION FOR MAP COMMAND
|         The user has specified attributes of incompatible data types in
|         the  VIA  clause  of  a  MAP  command.  The attributes in a VIA
|         clause should be of compatible data types.
|  
|  FI9    ERROR IN MAP COMMAND
|         A MAP command has failed to execute because of data set or disk
|         damage.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-21
   Revision 4


   E.3  TYPE 3:  FILE DAMAGED ERRORS (FD)

   FD3    FILE DAMAGED -- END OF FILE REACHED
          The data set file is damaged.  An internal pointer  directed  a
          read past the end of the file.

   FD4    FILE DAMAGED--INDEX CHECK
          The data in the keyed attribute tables does not  correspond  to
          the data in the records of the file.

   FD5    FILE DAMAGED -- RECORD RETRIEVAL ERROR
          The data file  or  data  portion  of  the  data  set  has  been
          truncated or damaged in some way.

   FD6    FILE DAMAGED -- KEY TABLE
          The data set is damaged as determined by the  LOAD,  APPEND  or
          TRANSACT command.

   FD8    FILE DAMAGED - INDEX CHECK ON VALUE DELETION
          System 1022 detected a difference  between  the  keys  and  the
          record  value  of  an  attribute for a particular record.  This
          error comes from the CHANGE command and indicates file  damage.
          You  can  usually  correct  this  error by rekeying the damaged
          attribute.







   E.4  TYPE 4:  OPEN ERRORS (OP)

   OP1    DEVICE NOT AVAILABLE OR NOT DISK
          The device specified in an OPEN command does not exist,  or  is
          not a disk device.  All data base files must reside on disk.

   OP2    DATA SET NOT FOUND
          The data set file requested in the OPEN command is not found on
          disk.

   OP3    WRONG PASSWORD
          The user has given the wrong 1022 password  necessary  to  open
          the data set file.

   OP4    NOT A 1022 DATA BASE FILE
          The file requested in an OPEN  command  was  not  generated  by
          System 1022 to be a data set file.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-22
   Revision 4


   OP5    UNAUTHORIZED ACCESS
          The user is not on the 1022 ADMIT list for the  specified  data
          set file.

   OP6    PASSWORD NEEDED
          A password must be  given  to  open  the  data  set  file.   No
          password is provided in the OPEN command.

   OP7    DATA BASE FILE PROTECTED
          The operating system file protection on the data set file  does
          not allow the user to open it for reading.

   OP8    OUT OF IO CHANNELS
          There are not enough software IO channels available to open the
          specified  data  sets.   The  user  must either close some data
          sets, or, if in a host  language  program,  close  some  files.
          There are a maximum of 15 channels available to the user.  Each
          open data set file requires one channel.  Each sorted data  set
          requires another channel.

   OP9    DATA SET INCOMPATIBLE
          The data set that the user is attempting to  open  was  created
          with  a  version of 1022 which is incompatible with the version
          being run.  Please refer to the BACKTO command which may remove
          this incompatibility.

   OP10   INTERNAL DATA SET NOT FOUND
          An   OPEN   command    has    been    specified    for    <data
          set-name> IN <file>,  and  <file>  contains no data set by that
          name.

   OP11   PROTECTION FAILURE IN OPEN FROM PL1022 SEGMENT
          An attempt was made to open a data set  at  runtime  which  was
          more  highly  protected  than  the  data set used at scan time.
          Such an open is  prohibited  since  it  would  permit  security
          violations.

   OP13   INCONSISTENT ENQ/NOENQ FILE STATUS DURING OPEN
          One user has attempted to open a file as ENQ while another user
          has attempted to open the same file as NOENQ.

   OP14   DATASET ALIAS ALREADY IN USE
          An alias may not be identical to the internal name or alias  of
          any  other open data set, including the one to which it refers.
          An INFORM BASE command will show the internal names and aliases
          of all open data sets.

|  OP15   AUXILIARY FILE NOT FOUND OR HAS INVALID DATASET ID
|         In attempting to reference or access  an  auxiliary  file,  the
|         user  has  not  correctly  specified  the  name of the data set
|         containing that file;  or else the user has  tried  to  open  a
|         multi-file  data  set of which one of the constituent auxiliary
|         files is mis sing.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-23
   Revision 4


   OP16   ALIAS NOT ALLOWED FOR MULTI-DATA SET OPEN
          In issuing the OPEN command, the user has attempted  to  assign
          an  alias to a DMS file containing multiple data sets.  This is
          not allowed because the same alias would be  assigned  to  more
          than  one  open  data set, which is illegal in 1022.  Open each
          data set in the DMS file individually and assign each  its  own
          alias.
|  
|  OP17   DATASET INCOMPATIBILITY EXISTS IN THE ADMIT ENTRIES
|         The user running version                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 have read privileges to the whole  data  set,
          and may not DUMP the data set.

   MI12   CONVERSION NOT IMPLEMENTED
          Report this to Software House.

   MI13   CAN'T WRITE TMPFILE
          The TMPFILE command could not write to TMPCORE or to disk.

   MI14   FILE COMMAND ABORTED DUE TO ERRORS
          An I/O, enter, lookup, or rename error occurred during  a  FILE
          TYPE,  COPY,  RENAME,  or  DELETE  command.   A  detailed error
          message has already printed;  this error is provided for  error
          trapping and batch use.

   MI15   SYSID ILLEGAL HERE
          The user may not add or change a SYSID.

   MI16   DBSET - DATA SET NOT OPEN IN PL1022 SEGMENT
          Data sets must  be  opened  at  compile  time  rather  than  at
          runtime.

   MI17   CANNOT RESTORE 113 COMPATIBILITY FOR THIS DATA SET
          The data set contains incompatible features;  it has  an  audit
          trail,  is  part  of  a multi-data set file, or is an unbundled
          data set, which are not in V113, and prevent compatibility.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-25
   Revision 4


   MI18   REFERENCE TO NON-EXISTENT DATA SET IN REPORT -- FILE CLOSED
          A REPORT references a data set which has  been  closed  in  the
          report, making the report impossible to complete.

   MI19   CAN'T FIND SYS:EDIT.EXE
          The user has issued the command, EDIT, on TOPS-20.  System 1022
          could  not  find  either  EDITOR:   or  EDIT.EXE.  You may have
          redefined SYS to  something  other  than  the  area  containing
          EDIT.EXE.  If not, check with your system administrator to find
          out the location of EDIT.

   MI20   ERROR SETTING UP FORK FOR EDITOR
          The user has issued the command, EDIT, on TOPS-20.  System 1022
          could not obtain the process to run SYS:EDIT.EXE.  Contact your
          system administrator.  This is probably caused by  insufficient
          monitor resources.

   MI21   PUSH COMMAND MUST BE ISSUED UNDER TOPS-20 OPERATING SYSTEM
          The PUSH command is illegal for TOPS-10.

   MI22   CANNOT FIND <SYSTEM>EXEC.EXE
          The file EXEC.EXE is not found in response to the PUSH command.
          This error is unlikely to occur since EXEC.EXE should always be
          in the system area.

   MI23   PUSH COMMAND ILLEGAL WITH A DATA SET IN UPDATE MODE
          The PUSH command is illegal when any  data  set  is  in  update
          mode.

   MI24   VERSION SKEW BETWEEN 1022 AND TE1400
          The user has attempted  to  edit  an  attribute  in  a  current
          version of 1022 using a non-current version of TECO.

   MI25   BAD FORMAT IN FILESPEC FOR RELOCATE DATA COMMAND
          The user has made a syntax error in specifying the new name  of
          a data file while issuing the RELOCATE DATA command.

   MI26   BAD FORMAT FOR LINE-NUMBERED FILE
          The user has referenced a line-numbered input file whose format
          does  not  conform  to  the  requirements  of System 1022.  See
          "Input File Formats" in Chapter 2.
|  
|  MI27   NO SUCH AUXFILE
|         The source auxfile specified in a RELOCATE AUXFILE  command  is
|         not one that belongs to the current data set.
|  
|  MI28   NEW FILESPEC FOR RELOCATE AUXFILE ALREADY IN USE
|         The name of the target auxiliary file specified in  a  RELOCATE
|         AUXFILE  command  is  already  in use as the name of some other
|         file.
|  
|  MI29   ILLEGAL PRINT CHANNEL NUMBER
|         The subscript for SYSPCCOL, SYSPCROW, SYSPCRESET,  and  SYSPAGE
   SYSTEM 1022 ERROR MESSAGES                                   Page E-26
   Revision 4


|         must  be  an integer between 1 and 8.  All other subscripts are
|         out of range.
|  
|  MI30   ATTEMPT TO WRITE ILLEGAL VALUE TO SYSPC FUNCTION
|         SYSPCCOL, SYSPCROW, and SYSPCRESET require a  positive  integer
|         as their argument.  This integer must be between 0 and 2^16-1.
|  
|  MI31   ILLEGAL ATTEMPT TO READ SYSPC FUNCTION
|         The subscript for SYSPCCOL, SYSPCROW, SYSPCRESET, and $SYSPCPOS
|         must  be  the  same  as  the  channel  number  specified in the
|         preceding INIT 123 or INIT DIF command.  You can read the value
|         of  SYSPCCOL,  SYSPCROW,  SYSPCRESET,  or $SYSPCPOS only if the
|         keyword 123 or DIF has been given in the preceding INIT command
|         and  the subscript matches the channel number specified in that
|         INIT command.
|  
|  MI32   ILLEGAL ATTEMPT TO WRITE SYSPC FUNCTION
|         The subscript for SYSPCCOL, SYSPCROW, and  SYSPCRESET  must  be
|         the  same as the channel number specified in the preceding INIT
|         123 command.  You can assign a value to SYSPCCOL, SYSPCROW,  or
|         SYSPCRESET  only  if  the  keyword  123  has  been given in the
|         preceding INIT command and the subscript  matches  the  channel
|         number specified in that INIT command.







   E.6  TYPE 6:  FORMAT OR PRINT OUTPUT ERRORS (FO)

   FO1    CAN'T OPEN OUTPUT DEVICE
          The formatter cannot open the output device  specified  by  the
          user.

   FO2    CAN'T ENTER OUTPUT FILE
          1022 cannot write the output file, usually because that file is
          protected, is in a protected area, or the user is over quota.

   FO3    OUTPUT TO UNASSIGNED DEVICE
          The user specified a System device  number  in  an  ON  clause,
          which has not been assigned to a device.  See INIT.

   FO4    NOT ENOUGH DIGITS IN PICTURE SPECIFICATION
          The PICTURE specification supplied by  the  user  doesn't  have
          enough  positions  to  handle  the  data  supplied to it.  This
          usually happens with text sent to a picture.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-27
   Revision 4


   FO5    PICTURE TOO LONG
          The picture is more than 50 internal characters long.

   FO6    ZERO REPEAT COUNT
          The multiplier in front of a parenthetical  group  is  0.   The
          multiplier should either be omitted, or be a positive number.

   FO7    MISSING ) IN REPEAT
          The format scanner has run off the end of the format  statement
          trying to match a left parenthesis with its corresponding right
          parenthesis.

   FO8    ILLEGAL CHARACTER IN NUMERIC SPECIFICATION
          A  special  or  meaningless  character  appears  in  a  numeric
          specification.

   FO9    INVALID USE OF PERIODS IN SPEC
          The  scan  found   two   unrelated   periods   in   a   numeric
          specification.

   FO10   INVALID FORMAT SPECIFICATION
          This is the general  error  message  for  strange  input.   The
          System doesn't know what is happening.

   FO11   INVALID NUMBER
          Either a  number  is  out  of  range,  or  unexpected  in  this
          position.  The number itself may be a valid integer.

   FO12   MISSING OR BAD FORMAT SPECIFICATION
          1022  either  saw  something  like  M-3...  with  no  following
          specification  (missing),  or  hit  a  right parenthesis in the
          middle of decoding a specification.

   FO13   NUMERIC SPECIFICATION AND PICTURE COMBINED
          Both a numeric specification and a  Picture  specification  are
          seen  in  the same formatting instruction.  IP999 is legal, but
          I5P999 is not.

   FO14   TOO MANY PAREN LEVELS
          The Formatter has a limit of 10 nested repeating  groups.   The
          user has just used 11.

   FO15   INVALID C SPECIFICATION
          The Cn specification seen is an illegal one.  N is not a  valid
          specifier.

   FO16   UNENDED ASCII LITERAL
          A literal of the form "-----" is started, but the  scanner  ran
          off the end of the format.  Another " is needed.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-28
   Revision 4


   FO17   BAD SCROLLING SPECIFICATION
          A number supplied in a scrolling specification is 0 or  out  of
          range, or something else strange.

   FO18   SA DOES NOT FOLLOW S SPEC
          An SA specification must follow an S spec,  to  which  it  must
          apply.

   FO19   SCROLLING NOT ASSEMBLED
          This message indicates that the user's version of  System  1022
          does not have the Scrolling option.

   FO20   TOO MANY SCROLLS
          There is a limit of 20 S specs to any one output line.

   FO21   SCROLLING PAST COL 400
          It is illegal to scroll information past column  400,  although
          it is legal to write lines of any length.

   FO22   OUTPUT DEVICE ALREADY IN USE BY USER
          The user has assigned the same device to two  different  System
          device  numbers.   This  usually  happens with TTY and LPT.  It
          doesn't happen to device DSK or other file structures.

   FO23   ILLEGAL PICTURE SWITCH
          The user supplied an illegal switch to a Picture  specification
          using the Wx option.

   FO24   * OR $ AFTER NUMERIC SPECIFICATION
          The * or $ characters can only be floated in front of a  number
          in the simple specification.

   FO25   ILLEGAL VALUE IN DISPLAY NUMERIC OR DISPLAY DATE FIELD
          A display date or display number could not be converted to  its
          underlying form on output.  For example, the display data in an
          unbundled data set attribute is illegal.

   FO26   TAB (nT) COLUMN IS TOO LARGE OR ILLEGAL
          The user is either trying to tab  past  the  400th  column,  or
          using an illegal value for the numeric argument.
|  
|  FO27   ILLEGAL PAGE-ORIENTED COMMAND ON PC PRINT CHANNEL
|         The HEADING, FOOTING, BODY, PAGE,  and  TYPAGE  page-formatting
|         commands  are  not allowed in PRINT commands that direct output
|         to a channel specified in a preceding  INIT  123  or  INIT  DIF
|         command.
|  
|  FO28   ILLEGAL DIF FILE FORMAT
|         System 1022 does not support L, $, $3, $4, S, T, or  C  formats
|         in  PRINT commands that direct output to a channel specified in
|         a preceding INIT DIF command.
   SYSTEM 1022 ERROR MESSAGES                                  Page E-28A
   Revision 4


|  FO29   ILLEGAL PC FILE FORMAT
|         System 1022 does not support $3, $4, S,  T,  or  C  formats  in
|         PRINT  commands  that direct output to a channel specified in a
|         preceding INIT 123 or INIT DIF command.
|  
|  FO30   "L" FORMAT ILLEGAL ON NON-123 PRINT CHANNEL
|         System 1022 supports "L" format only  in  PRINT  commands  that
|         direct  output  to  a channel specified in a preceding INIT 123
|         command.
|  
|  FO31   SYSPC COUNTER OVERFLOW ON EOL
|         In printing to a 123 columnwise file, the value of SYSPCROW has
|         exceeded  the  allowed limit of 2^16-1 or, in printing to a 123
|         rowwise file, the value of SYSPCCOL has exceeded that value.
|  
|  FO32   SYSPC COUNTER OVERFLOW ON EOI
|         In printing to a 123 columnwise file, the value of SYSPCCOL has
|         exceeded  the  allowed limit of 2^16-1 or, in printing to a 123
|         rowwise file, the value of SYSPCROW has exceeded that value.
|  
|  FO33   SYSPCROW COUNTER OVERFLOW IN DIF FILE
|         In printing to a DIF file, the value of SYSPCROW  has  exceeded
|         the allowed limit of 2^18-1.
|  
|  FO34   SYSPCCOL COUNTER OVERFLOW IN DIF FILE
|         In printing to a DIF file, the value of SYSPCCOL  has  exceeded
|         the allowed limit of 2^18-1.







   E.7  TYPE 7:  UPDATE ERRORS (UP)

   UP1    CAN'T OPEN DATA SET FOR WRITING
          The DECsystem-10 file protection does not allow  this  user  to
          open  the  file  for  writing.   System 1022 received the error
          return when attempting to update the data set.  If the user has
          rights  to  write the file, check to see that the disk quota is
          not exceeded.

   UP2    DATA SET STRUCTURE CHANGED  BY  ANOTHER  USER;   FILE  MUST  BE
          REOPENED
          The data set is superseded by a LOAD or DUMP command.   If  the
          data set is not in a multiple data set file, the file itself is
          superseded.  If the data set is in a multiple data set file, it
          is  overwritten  within that file.  This message does not print
          if another user keys or optimizes an attribute.

   SYSTEM 1022 ERROR MESSAGES                                  Page E-28B
   Revision 4


   UP3    THE CURRENTLY SELECTED  RECORD  HAS  BEEN  CHANGED  BY  ANOTHER
          UPDATER
          The record has been changed between the time  it  was  selected
          and the time a CHANGE command was issued.

   UP4    DATASET NOT HANDLED WITH ENQ/DEQ
          The user has attempted to apply an UPDATE PREVENT command to  a
          data  set  that  is not ENQ.  UPDATE PREVENT works only for ENQ
          sets.

   UP5    OPERATION IS ILLEGAL WITH UPDATE ON
          The user has attempted to issue an  UPDATE  PREVENT  or  UPDATE
          ALLOW  command  while  a previously issued UPDATE ON command is
          still in effect.  This is not allowed.

   UP6    UNABLE TO PREVENT UPDATES
          The user has issued an UPDATE PREVENT command  but  the  update
          restriction  cannot be applied (presumably because another user
          has the set open for update already).
|  
|  UP7    DATASET MUST BE ENQ TO DO LOCK
|         To put a userlock  on  a  string  with  the  LOCK  ON  USERLOCK
|         command,  the  data  set  containing that record must be opened
|         ENQ.  In order to lock an individual  record  with  the  GETREC
|         $LOCK  or LOCK ON RECORD command, the data set must be both ENQ
|         and RECLOCK.
|  
|  UP8    RECORD WAS NOT PREVIOUSLY LOCKED
|         The user either tried to change, delete, or undelete a  RECLOCK
|         dataset record without first locking the record with the GETREC
|         $LOCK or LOCK ON RECORD command  or  else  issued  a  LOCK  OFF
|         RECORD command on a record that was not currently locked.
|  
|  UP9    USERLOCK STRING WAS NOT PREVIOUSLY LOCKED
|         The user issued a LOCK OFF USERLOCK command on  a  string  that
|         was not currently locked.
|  
|  UP10   CANNOT LOCK RECORD
|         You have tried to lock a record that another user currently has
|         locked.
|  
|  UP11   CANNOT LOCK USERLOCK STRING
|         You have timed out of the queue while trying to lock  a  string
|         on which some other user currently has a lock.
|  
|  UP12   USERLOCK STRING ALREADY LOCKED
|         You have issued a LOCK ON USERLOCK command on a string on which
|         you already have a lock.
|  
|  UP13   CANNOT LOCK ON/OFF RECORD WHILE IN GLOBAL MODE
|         You must be in local (GETREC) mode to execute a LOCK ON  RECORD
|         or LOCK OFF RECORD command.
   SYSTEM 1022 ERROR MESSAGES                                  Page E-28C
   Revision 4


|  UP14   DATASET MUST BE NORECLOCK TO MODIFY ACCESS TO NOENQ
|         If a data set is RECLOCK, it is also  by  definition  ENQ.   To
|         make  a  data set NOENQ, you must first make certain that it is
|         NORECLOCK.
|  
|  UP15   DATASET MUST BE ENQ TO MODIFY ACCESS TO RECLOCK
|         Only ENQ data sets can be RECLOCK.
|  
|  UP16   MODIFY FAILED BECAUSE OTHER USERS ARE ACCESSING THE FILE
|         You need exclusive (UPDATE) access to the data set to execute a
|         MODIFY $ACCESS RECLOCK or MODIFY $ACCESS NORECLOCK command.
|  
|  UP17   ILLEGAL WHEN DATASET IS NORECLOCK
|         The data set must be RECLOCK before you can lock a record  with
|         the GETREC $LOCK or LOCK ON RECORD command.
|  
|  UP18   ILLEGAL WHEN DATASET IS RECLOCK
|         Users cannot execute  CHANGE,  DELETE,  UNDELETE,  or  TRANSACT
|         commands in global mode when the data set is RECLOCK.
|  
|  UP19   ILLEGAL WITH RECORD OR USERLOCK STRING LOCKED
|         You cannot execute MODIFY $ACCESS RECLOCK/NORECLOCK commands if
|         you  currently have a lock on a record or userlock string.  You
|         should issue the appropriate LOCK OFF command before giving the
|         MODIFY $ACCESS RECLOCK/NORECLOCK command.







   E.8  TYPE 8:  SORT ERRORS (SO)

   SO1    NOT ENOUGH IO CHANNELS FOR SORT
          There are not 4 free I/O channels available to execute the SORT
          command.

   SO2    ILLEGAL SCRATCH DEVICE
          The USING clause in the SORT command specifies a  device  which
          does not exist, is not available, or is not a disk.

   SO3    CAN'T OPEN SORT OUTPUT FILE
          A SORT temporary file cannot be written.

   SO4    TOO MANY SORT FIELDS
          More than 20 fields are specified as keys to a sort.

   SO5    SORT IO ERROR
          System 1022 cannot write a disk  block  for  a  sort  temporary
          file.  Check for disk quote exceeded or hardware disk errors.

   SYSTEM 1022 ERROR MESSAGES                                  Page E-28D
   Revision 4


   SO6    IO ERROR SORT FILE
          System 1022 cannot read  a  sort  temporary  file.   Check  for
          hardware disk errors.

   SO7    STRING FUNCTION RESULT MUST HAVE SAME LENGTH FOR EACH RECORD
          The SORT command only operates on  values  of  uniform  length.
          String  functions that return values of variable length must be
          combined with other functions  that  trim  or  pad  to  produce
          results of uniform length for sorting.







   E.9  TYPE 9:  I/O ERRORS (IO)

   IO1    ERROR READING DISK
          System 1022 cannot read a disk block  of  the  data  set  file,
          probably due to hardware disk errors.

   IO2    ERROR WRITING DISK
          System 1022 cannot  write  a  disk  block  of  the  data  file,
          probably due to hardware disk errors.

   IO3    INFO IO ERROR
          System 1022 cannot write a disk  block  on  the  INFORM  output
          file.  Check for disk quota exceeded or hardware disk errors.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-29
   Revision 4


   IO4    SAVE CMD OR FILECLAUSE IO ERROR
          System 1022 cannot write a disk block for a SAVE file, or  read
          a disk block during the FILE part of a FIND command.  Check for
          disk quota exceeded or hardware disk errors.

   IO5    SORT IO ERROR
          System 1022 cannot write a disk  block  for  a  sort  temporary
          file.  Check for disk quota exceeded or hardware disk errors.

   IO6    IO ERROR SORT FILE
          System 1022 cannot read  a  sort  temporary  file.   Check  for
          hardware disk errors.

   IO7    KEY TMP FILE READ ERROR
          A disk read error occurred while keying attributes.

   IO8    KEY TMP FILE WRITE ERROR
          A disk write error is encountered while executing a KEY,  LOAD,
          or APPEND command;  check for over quota.

   IO9    IO OUTPUT ERROR
          An error occurred in an attempt to output ASCII data in a PRINT
          command.

   IO10   IO ERROR WRITING DMS FILE
          An output error occurred while System 1022 wrote a new data set
          file in a DUMP command.

   IO11   NON-RECOVERABLE OUTPUT ERROR
          There is an error writing an external file.

   IO12   NON-RECOVERABLE INPUT ERROR
          There is an error reading an external file.

   IO13   INPUT FILE READ ERROR
          System 1022 detected a hardware error while reading input on  a
          FILE  TYPE  or  FILE  COPY.  Try again.  If the error persists,
          contact your system administrator or computer operations staff.

   IO14   OUTPUT FILE WRITE ERROR
          System 1022 detected a hardware writing  error  while  doing  a
          FILE  COPY.   Try  again.   If the error persists, contact your
          system administrator or computer operations staff.

   IO15   FILE RENAME OR DELETE ERROR
          System 1022 could not perform the specified  RENAME  or  DELETE
          operation  and  issued a warning message.  This is probably due
          to a protection error.  Read the warning  message  for  further
          information.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-30
   Revision 4


   E.10  TYPE 10:  FATAL SYSTEM ERRORS (SY)

   These errors should not occur during use of System 1022.  If any does,
   please report this to Software House.

   SY1    SORT FILE NOT FOUND
          System 1022 cannot locate a temporary sort file just written.

   SY2    EVAL FATAL ERROR
          The expression evaluator has an impossible error status.

   SY3    SYSTEM 1022 FATAL ERROR--CALLED FROM LOCATION address
          This message is generated by several  conditions  which  should
          not occur.  Please report this if it can be reproduced.

   SY4    OUT OF IO CHANNELS
          1022 has run out of I/O channels, which can only happen due  to
          System bugs.

   SY5    BAD BUFFER ALLOCATION
          The formatter is unable to allocate space.

   SY6    BAD SPEC IN DISPATCH TREE
          A bad code is scanned during the search of an internal table in
          core.

   SY7    KEY TMP FILE LOOKUP ERROR
          A temporary file written by a KEY, or LOAD  command  cannot  be
          found.

   SY8    DOUBLE PRECISION OPERATION ILLEGAL FROM HOST LANGUAGES

   SY9    BUFFER MANAGEMENT FAILURE IN EVAL

   SY10   INTERNAL INCONSISTENCY (ILLEGAL CONVERSION)

   SY11   INTERNAL INCONSISTENCY (UNIVERSAL SELECTION FAILURE)

   SY12   INTERNAL INCONSISTENCY (BACK SELECTION FAILURE)

   SY13   INTERNAL INCONSISTENCY (ILLEGAL FUNCTION NUMBER)

   SY14   ILLEGAL EVAL OPERATION FROM HOST LANGUAGES

   SY15   UNIMPLEMENTED CONVERSION

   SY16   CANNOT ACCESS KEY TMP FILE

   SY17   NO FREE CHANNELS

   SYSTEM 1022 ERROR MESSAGES                                   Page E-31
   Revision 4


   SY18   UNRECOVERABLE SORTING ERROR WHILE PROCESSING KEYS

   SY19   TOO MANY RECORDS IN DATA SET
          There is a limit of 262,143 (2**18-1) records in a data set.

   SY20   MEMORY MANAGEMENT ERROR - INTERNAL BUFFER OVERWRITTEN

   SY21   INTERNAL ERROR:  DISPATCH ON ZERO - PLEASE REPORT

   SY22   INVALID HOME BLOCK FORMAT FOR DATASET







   E.11  TYPE 11:  OUT OF CORE ERRORS (CO)

   All the following messages are generated by System 1022 attempting  to
   allocate more core than is available to the user.

   CO1    OUT OF CORE -- COMPLEX FIND COMMAND
          A complex FIND command needed more core.

   CO2    OUT OF CORE -- ADD COMMAND
          An ADD command needed more core.

   CO3    OUT OF CORE -- SET BUFFER COMMAND
          A SET BUFFER command needed more core.

   CO4    OUT OF CORE -- SORT COMMAND
          More core was needed to process sorted records.

   CO5    OUT OF CORE -- SORT COMMAND
          Not enough core is available to perform the SORT.  If the  user
          has  specified a core size, try reissuing the command with less
          core specified.

   CO6    OUT OF CORE -- TECO TEXT EDITOR
          More core is needed to run the TECO text editor.

   CO7    OUT OF CORE --OPEN COMMAND
          More core is needed to hold the tables necessary  to  OPEN  the
          data set file.

   CO8    OUT OF CORE -- KEY COMMAND
          More core is needed to perform a KEY command.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-32
   Revision 4


   CO9    OUT OF CORE -- KEY REFORMATTER
          More core is needed for the key reformatter.

   CO10   OUT OF CORE -- LOAD COMMAND
          More core is needed for the loading program.

   CO11   OUT OF CORE -- APPEND COMMAND
          More core is needed for an APPEND command.

   CO12   OUT OF CORE WHILE PROCESSING KEYS
          More core is needed to process the keys.

   CO13   OUT OF CORE -- I/O BUFFERS
          More core is needed for I/O buffers.

   CO14   NOT ENOUGH CORE TO SORT KEYS
          More core is needed to sort the keys.

   CO15   OUT OF CORE -- COLLECT COMMAND
          More core is needed to execute a COLLECT command.

   CO16   OUT OF CORE
          More core is needed.  Core usage  can  be  reduced  by  closing
          unneeded data sets and by issuing the SET BUFFERS command.







   E.12  TYPE 12:  PL1022 ERRORS (PL)

   PL5    GETREC, NO RECORD
          Either there are no records selected for a GETREC command;   or
          previous  GETREC  commands  have  looped  through  all selected
          records.

   PL6    CALL LEVEL EXCEEDED
          Subroutine calls are nested too deeply in a PL1022 program.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-33
   Revision 4


   E.13  TYPE 14:  HOST LANGUAGE ERRORS (HL)

   HL1    NUMERIC DATA REQUESTED IN TEXT ARGUMENT
          In 113, a call to the DBVAL or DBGET subroutine  from  a  COBOL
          program  is  requesting  that numeric data be placed in a COBOL
          DISPLAY variable.

   HL2    INVALID ATTRIBUTE NAME
          An attribute name is needed, but does  not  exactly  match  any
          name or synonym.

   HL3    INVALID RELATIONAL
          1022 does not recognize the relational name or number,  or  the
          relational is illegal in this command.

   HL4    ATTRIBUTE NOT KEYED
          The user has used an unkeyed attribute in a FIND command.

   HL5    INVALID OR NO VALUE
          A value was expected, but none was given, or the value was  out
          of legal range.

   HL6    INVALID LOGICAL
          The logical in a DBFIND or DBSRCH command is not recognized.

   HL7    DBVAL CALLED BEFORE DBGREC
          The user must be in local mode, by a  call  to  DBGREC,  before
          calling DBVAL.

   HL8    DOUBLE ATTRIBUTE IN ADD OR CHANGE
          The same attribute can not  be  specified  twice  in  DBADD  or
          DBCHNG.

   HL9    TOO FEW ARGS
          Another argument was required, but the list ended.

   HL10   OUT OF CORE
          1022 needs more than available core for internal table space.

   HL11   DATA SET NOT OPEN
          The command requires that a data set be open for operations.

   HL12   INVALID COBOL DISPLAY TYPE
          The user declared a variable as DISPLAY-9, which the COBOL Host
          Language interface does not recognize.

   HL13   SAV. ARGUMENT NOT SEQUENTIAL OR NOT IN RANGE
          For efficiency, the user is required to  use  the  lowest  SAV.
          number  that  he  can  at  any  time.  Here he used one that is
          greater than 10, or skipped a number in sequence.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-34
   Revision 4


   HL14   ADD OR CHANGE ON PROTECTED ATTRIBUTE
          The user may not specify an attribute that  is  protected  from
          change,  being  Integer  Of Identification, Date Of Change, and
          Date Of Entry.

   HL15   ILLEGAL TYPE CONVERSION
          The host language interface cannot convert text to numeric,  or
          the reverse.

   HL16   TOO MANY SORT FIELDS
          The user has given more than 20 attributes to sort on.

   HL17   ILLEGAL OR REPEATED SORT SPECIFICATION
          The scan hit an unknown word, or duplicate keywords, processing
          a sort description.

   HL18   UNAUTHORIZED COMMAND
          Either the ADMIT protection on the data set does not allow  the
          last  command  to  be  executed,  or  DBRETN  was called from a
          FORTRAN or MACRO program.

   HL19   UNAUTHORIZED ATTRIBUTE REQUEST
          The ADMIT protection on the data set  prohibits  the  attribute
          specified in this operation, usually in DBCHNG.

   HL20   "FILE" INVALID IN SEARCH
          The user can not  use  the  FILE  <file-descriptor>  option  in
          DBSRCH.

   HL21   INVALID FILE DESCRIPTOR
          A file descriptor in DBOPEN or DBAUD has illegal form.

   HL22   INVALID PASSWORD
          A password supplied in a DBPSWD command is not correct.

   HL23   INVALID KEYWORD
          The DBAUD command saw an invalid keyword.

   HL24   ALREADY AN ATTRIBUTE IDENTIFIER
          The new attribute name or abbreviation specified in a  call  to
          the DBMOD routine duplicates an existing attribute identifier.

   HL26   INVALID DATA SET SPECIFIED
          DBSET specified  a  data  set  number  that  is  not  currently
          assigned to a data set.

   HL27   INVALID DBAUD SUB-COMMAND
          The first argument to DBAUD is not  a  valid  subcommand.   The
          legal DBAUD subcommands are:  START, CHECK, and PLACE.

   HL28   AUDIT FILE NOT OPEN
          An attempt is made to write data into an audit file before  the
          file is initialized.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-35
   Revision 4


   HL29   ILLEGAL AUDIT FILE BLOCK TYPE
          User defined audit file entries may only have  entry  codes  in
          the range 700-777 octal.

   HL30   INVALID DBAUD 'START' KEYWORD
          One or more of the keywords in a 'START' call to DBAUD  is  not
          recognized.  The possible keywords are:  FILE, LOCK, and JOB.

   HL31   SYSID ILLEGAL HERE
          The user has specified SYSID in a call to DBPSWD.  SYSID cannot
          be protected.

   HL32   DBEND NOT ALLOWED HERE
          DBEND may not be called during an error trapping subroutine  or
          procedure.

   HL33   NO RETURN ADDRESS FOR DBRETN
          DBRETN was entered outside of an error-trapping  procedure  and
          1022 has no return address set up.

   HL34   INVALID DATA SET SPECIFIED -- DATA SET NAME AMBIGUOUS
          A call to DBSET specified a data set  name  that  matches  more
          than  one  open  data  set.   Close the unwanted data set(s) or
          reference the desired one by data set number or alias.

   HL35   INVALID SYSTEM VARIABLE NAME OR NUMBER
          The system variable name in a call to DBSYSV was not recognized
          or the number in that call was out of range.

   HL36   SYSTEM VARIABLE NOT USER ASSIGNABLE
          The user has attempted to change the value of a system variable
          that may only be read.

   HL37   SCALING NOT SUPPORTED FOR COBOL ARGUMENTS
          COBOL picture editing and picture  scaling,  including  implied
          decimal, are not supported by System 1022.  Do editing in COBOL
          by moving a returned item to a COBOL edited field.

   HL38   INVALID ARGUMENT, LITERALS CANNOT BE CHANGED
          The user has specified a constant where an indication of change
          is expected.

   HL39   SIZE OF VALUE/COUNT PAIR EXCEEDS USER ARRAY BOUNDS
          In issuing a DBVALU command, the user has made the  ARRAY-START
          and  ARRAY-END  specifications  too narrow to allow room in the
          array for a single value/occurrence pair.

   HL40   REQUESTED NUMBER OF VALUES EXCEEDS ALLOWABLE MAXIMUM
          In issuing a DBVALU command, the user has set  NV  to  a  value
          greater  than the maximum number of value/occurrence pairs that
          can be contained within the bounds defined by  ARRAY-START  and
          ARRAY-END.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-36
   Revision 4


   HL41   UNEXPECTED EOF DURING KEY SEARCH
          The data file  has  been  damaged.   An  internal  pointer  has
          directed a read past the end of the file during a key search.

   HL42   UNEXPECTED EOF WHILE COUNTING KEY VALUES
          The data file  has  been  damaged.   An  internal  pointer  has
          directed  a  read  past  the end of the file during a key value
          count.

   HL43   REFERENCE TO AN ELEMENT OF A COLLECTION IS ILLEGAL
          Data sets serving as constituents of a collection can  only  be
          referenced or accessed as part of that collection.

   HL44   COMMAND NOT ALLOWED WHEN SET TO A COLLECTION
          The user has attempted to  apply  a  disallowed  command  to  a
          current collection.

   HL45   INVALID ARGUMENT DESCRIPTION RETURNED FROM XGARG.
          The XGARG.  routine  that  identifies  the  argument  type  was
          unable  to  do so either because a particular argument contains
          an invalid argument description or else  because  there  is  an
          error  in  the  XGARG.   routine  itself.   Consult your system
          manager.







   E.14  TYPE 15:  LOAD AND APPEND ERRORS (LD)

   LD1    NOT ENOUGH CHANNELS AVAILABLE
          There are fewer than four free channels, not enough to  perform
          a LOAD or APPEND command.

   LD2    CANNOT OPEN DESCRIPTION FILE DEVICE
          The device given for the DMD file is unavailable to this job.

   LD3    CANNOT FIND DESCRIPTION FILE
          The description (DMD) file specified in a LOAD  command  cannot
          be read.

   LD4    ERROR READING DESCRIPTION FILE
          An I/O error occurred while reading the description file for  a
          LOAD command.

   LD5    DDL ERRORS ENCOUNTERED
          A LOAD command is terminated by syntax or other errors  in  the
          data set description.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-37
   Revision 4


   LD6    CANNOT OPEN INPUT DATA FILE DEVICE
          The device for the  input  data  file,  in  a  LOAD  or  APPEND
          command, cannot be accessed by this job.

   LD7    CANNOT FIND INPUT DATA FILE
          1022 cannot locate the input data file for  a  LOAD  or  APPEND
          command.

   LD8    ERROR READING INPUT DATA FILE
          A LOAD or APPEND command encountered  I/O  errors  reading  the
          input data file.

   LD10   DATA SET ALLOCATION UNSUCCESSFUL
          The output allocation of the data set file in  a  LOAD  command
          failed  due  to either an enter or open failure, or because the
          total allocation could  not  be  performed  in  the  number  of
          attempts specified.

   LD11   ERROR OPENING CHANNEL
          The input file device can not be opened.

   LD12   ERROR WRITING DATA BASE FILE
          System 1022 encountered errors writing a disk block to the data
          set file, probably due to hardware disk errors.

   LD13   CAN'T ENTER DMS FILE
          System 1022 is unable to enter the DMS file.

   LD14   OPEN ERROR ON SCRATCH CHANNEL
          System 1022 can not open the output device.

   LD15   UNABLE TO OPEN CHANNEL FOR KEY TMP FILE
          The device for a KEY TMP file can not be opened.

   LD16   CAN'T ENTER KEY TMP FILE
          The KEY TMP file can not be entered.

   LD17   CAN'T FIND SPOOLER FILE
          A spooler System file can not be found.

   LD18   CAN'T OPEN SPOOLER CHANNEL
          The device for a spooler file can not be opened.

   LD19   LRECL SPECIFIED IS INCOMPATIBLE WITH LRECL IN DMD
          The LRECL specified on the command line  is  smaller  than  the
          record  size  determined  from  the field specifications of the
          Data Description file.  The LRECL  must  be  as  great  as  the
          highest column number used in the description file.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-38
   Revision 4


   LD21   OUT OF CORE
          Too little core is available to process  the  LOAD,  APPEND  or
          TRANSACT.

   LD22   KEY CONVERSION NOT IMPLEMENTED
          This error should not occur.   Please  report  it  to  Software
          House.

   LD23   CAN'T ENTER DATA FILE
          A data file in the DUMP command cannot be entered.

   LD24   ISAM DATA FILE ILLEGAL HERE
          ISAM data files may be used only with the CREATE command.   The
          TRANSACT  and  APPEND commands only accept ISAM data files that
          are part of a 1022 data  set.   ISAM  data  files  may  not  be
          written with the DUMP command.

   LD25   ISAM DATA FILE OF INFINITE LENGTH FOUND - RUN SETEOF FIRST
          An attempt is made to use CREATE on an ISAM file before setting
          an end-of-file flag on the file.  The ISAM file was infinite in
          length.  Use the DEC-supplied SETEOF program  to  set  the  EOF
          flag, then reissue the CREATE command.

   LD26   COULD NOT ENTER DMS FILE
          The LOAD or CREATE command could not create the DMS file.  This
          is  probably  due  to  limited  disk  space, or to another user
          updating the file when the LOAD or CREATE command was given.

   LD27   ATTEMPT TO CREATE  A  DATA  SET  CONTAINING  MORE  THAN  262143
          RECORDS
|         The DMI file given in a CREATE contains more than  the  maximum
|         number  of  records currently allowed by 1022 without the Large
|         Data Sets Module.
|  
|  LD28   CANNOT DUMP TO MULTI-FILE DATA SET
|         It is not possible to dump records to a data set that  consists
|         of more than one file.
|  
|  LD29   ILLEGAL SCRATCH DEVICE SPECIFIED FOR LOAD
|         The user has specified a  nonexistent  device  in  the  SCRATCH
|         clause of the loading section of a data description file.
|  
|  LD30   SYSCUSTDMI MUST BE DEFINED BEFORE USING CUSTDMI KEYWORD
|         The CUSTDMI keyword signals 1022  to  use  a  user-written  DMI
|         reader  rather than the standard one when doing a load, append,
|         or transact.  The address of this user-written DMI reader  must
|         be  stored  in  the system variable SYSCUSTDMI before it can be
|         accessed for a load, append, or transact.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-39
   Revision 4


   E.15  TYPE 16:  TRANSACT ERRORS (TR)

   TR1    LOCATOR NOT KEYED
          An unkeyed attribute is a locator in an  unsorted  transaction.
          The locators must be keyed attributes.

   TR2    LOCATOR CONVERSION NOT IMPLEMENTED
          Report this error to Software House.

   TR3    NO RECORDS SELECTED FOR SORTED TRANSACTION
          No records are selected for this transaction.

   TR4    LOCATOR PROTECTED OR NAME DOES NOT MAP TO MASTER
          The name of a locator attribute  does  not  match  any  of  the
          master file attributes.

   TR5    ADDITIVE CONVERSION NOT IMPLEMENTED
          Please report this error to Software House.

   TR6    NO INPUT FILE FOUND
          No transaction  file  was  found.   Transaction  processing  is
          terminated.

   TR7    DUMP ILLEGAL IN GETREC MODE
          You must be in global mode to issue a DUMP command.

   TR8    UNAUTHORIZED ATTEMPT TO READ DATA SET
          User did  not  satisfy  ADMIT  command  requirements  for  READ
          access.   Ask  your  data  base administrator for access to the
          data set.


   TR9    UNAUTHORIZED ATTEMPT TO WRITE DATA SET
          User did not  satisfy  ADMIT  command  requirements  for  WRITE
          access.   Ask  your  data  base administrator for access to the
          data set.







   E.16  TYPE 18:  AUDIT ERRORS (AU)

   AU1    NO FREE CHANNELS FOR AUDIT FILE
          There are no channels available for writing the audit file.

   AU2    CAN'T OPEN AUDIT FILE DEVICE
          1022 cannot access the device for the audit file.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-40
   Revision 4


   AU3    COULD NOT ENTER AUDIT FILE
          1022 cannot gain write access to the Audit file.

   AU4    CAN'T GET AT AUDIT FILE
          1022 cannot write the audit file.

   AU5    NO FREE CHANNELS FOR AUDIT FILE
          A call to DBAINI has failed for lack of a free channel to  read
          the audit file.

   AU6    AUDIT FILE NOT OPENED FOR DBAGET
          DBAGET is called before a call to DBAINI.

   AU7    ILLEGAL AUDIT FILE LOCATOR CODE
          A call to DBALOC gives an incorrect locator code value.

   AU8    INVALID KEYWORD
          DBAINI is called with an unrecognized keyword.

   AU9    CAN'T FIND AUDIT FILE
          1022 is unable to access the audit file  for  a  LIST,  BACKUP,
          FIX, or DBAINI operation.

   AU10   AUDIT FILE DAMAGED
          The audit file contains bad data.

   AU11   CAN'T FIND CHECKPOINT
          The required checkpoint is not in the audit file.

   AU12   WRONG AUDIT FILE VERSION
          The audit file is incompatible  with  this  version  of  System
          1022.

   AU13   NOT ENOUGH CORE
          A BACKUP operation requires more than the available  amount  of
          core.

   AU14   AUDIT BACKUP ABORTED
          An unrecoverable error has occurred during a BACKUP.

   AU15   AUDIT VERIFICATION FAILURE
          The audit trail specified for a BACKUP contains omissions  that
          prevent the BACKUP from proceeding properly.  The BACKUP is not
          attempted.

   AU16   NOT ENOUGH IO CHANNELS FOR AUDIT LIST
          An AUDIT LIST requires 1 free channel, 2 if an output  file  is
          written.

   SYSTEM 1022 ERROR MESSAGES                                   Page E-41
   Revision 4


   AU17   CAN'T ENTER OUTPUT FILE
          The output file for an AUDIT LIST  or  AUDIT  MERGE  cannot  be
          started.

   AU18   CAN'T FIND INPUT FILE
          One of the input files to AUDIT MERGE is not there.

   AU19   NOT ENOUGH CHANNELS FOR MERGE
          AUDIT MERGE requires 3 free channels.

   AU20   COULDN'T START AUDIT FILE
          An AUDIT START command is not completed due to errors.

   AU21   COMMENT NOT WRITTEN
          The AUDIT COMMENT is not written due to errors.

   AU22   CHECKPOINT NOT WRITTEN
          An AUDIT CHECKPOINT did not complete, due to errors.

   AU23   AUTO AUDIT FAILURE
          A data set has  an  automatic  audit  trail  (specified  by  an
          earlier AUDIT START AUTO command) which 1022 is unable to read.

   AU24   ACCESS NOT ALLOWED UNTIL DAMAGE FIXED
          The audit trail recovery mode is ALLOW NOTHING.  The  data  set
          is  damaged and must be fixed before audit allows normal access
          again.

   AU25   RETRY NOT SUPPORTED
          The RETRY option of the AUDIT RECOVERY and AUDIT  FIX  commands
          is no longer supported in System 1022.

|  AU26   SCRATCH FILE ERROR DURING AUDIT BACKUP
|         System 1022 has encountered a disk error while using a  scratch
|         file to back up a large data set.







   E.17  TYPE 19:  DEBUGGING ERRORS (DB)

   DBx    The user should not encounter DB error messages, which are  for
          internal  Software  House  use.  If a DB error message appears,
          please report it to Software House.
   SYSTEM 1022 ERROR MESSAGES                                   Page E-42
   Revision 4


   E.18  TYPE 20:  SPSS INTERFACE ERRORS (SP)

   SP1    NO FREE CHANNEL FOR SPSS COMMAND
          The SPSS command needs one free channel to operate.

   SP2    SPSS COMMAND ILLEGAL IN GETREC MODE
          Statistics are meaningless for one record.  The user should set
          up his selection group again and reissue the SPSS command.

   SP3    INTERNAL ERROR IN SPSS COMMAND - CONVERSION
          This error  should  never  occur.   It  is  included  only  for
          security.   QUIT  from  System 1022 and try again.  Also notify
          your System 1022 maintainer.

   SP4    SPSS COMMAND ABORTED DUE TO ERRORS
          An error in file LOOKUP or ENTER occurred.   A  detailed  error
          message has already printed.

   SP5    SPSS SYSTEM FILE NOT CREATED BY 1022
          System 1022 can only add subfiles to an SPSS system file  which
          was created by 1022.

   SP6    ATTEMPT TO ADD A SUBFILE FROM A DIFFERENT DATA SET
          Adding subfiles from different data sets to an SPSS system file
          is a meaningless operation which SPSS cannot handle.

   SP7    SPSS FILE DAMAGE - EOF
          The SPSS system file has an inconsistent internal  format,  and
          subfiles cannot be added to it.  The user must create it again.

   SP8    TOO MANY SUBFILES
          A maximum of 10 subfiles are permitted by the  SPSS  Interface.
          The user has attempted to exceed this limit.  This limit may be
          exceeded by use of the ADD SUBFILES procedure  in  SPSS.   (See
          the SPSS manual.)

   SP9    NO RECORDS SELECTED
          No selection group is set up, and no file is created.







   E.19  TYPE 21:  COMPILE/PERFORM ERRORS (CP)

   CP1    COMPILED PL1022 INTERNAL INCONSISTENCY--PLEASE REPORT!
          The user should not encounter this message, as it  indicates  a
          System  1022 bug.  If this message appears, please report it to
          Software House.












                                 APPENDIX F

                        SYSTEM 1022 WARNING MESSAGES



   The following is a list of error messages printed by System 1022.  The
   interactive  System  returns  to  command  level;   the  Host Language
   Interface aborts.


                        INTERACTIVE WARNING MESSAGES


   <CHANGE or DELETE> ignored. Record altered after GETREC.
   SYSID = <n> Data set <data set-descriptor>
   %Continuing

        The current record selected by  GETREC,  or  first  record  of  a
        sorted  selection  group, was updated by another user between the
        time the user selected this record and issued an update  command.
        The user's update command is not executed.


   Possible FILE DAMAGE (or UPDATE in progress) as of <time> ON <date>

        The user has OPENed a data set at the time another user is in  an
        update sequence.  <time> and <date> indicate the beginning of the
        last update sequence.  This message may be due to a system  crash
        during  the  previous  update.   See  the  discussion of Multiple
        Access of the Data set in Chapter 5.

   1022 ENTER error (3) File being Modified File: <file name>
   File still busy after SYSNRETRY (=<n>) retries.
   ? (UP1) Can't OPEN data set for writing

        1022 has made SYSNRETRY attempts to gain update access to a  data
        set, and the data set is still in update mode for another job.



                  HOST LANGUAGE INTERFACE WARNING MESSAGES


     <CHANGE or DELETE> ignored for SYSID = <n> in <data set-descriptor>
   SYSTEM 1022 WARNING MESSAGES                                  Page F-2
   Revision 4


     Record updated since last GETREC
   % Execution will continue

        The record selected by the user's  HLI  program  was  updated  by
        another user between the selection call and the update call.













                                 APPENDIX G

                      STANDARD FORM FOR SIMPLE REPORTS



   The following is a standard form for writing  simple  reports,  to  be
   used as follows:

        1) Fill in all appropriate blanks.

        2) Lines with asterisks may be repeated as needed  (for  example,
           several ON STARTs).

        3) Create a text file containing needed lines.  Omit  lines  with
           no  entries.   Remember  that  a period must end every command
           line.

        4) Run System 1022 and execute the file with the USE command.

   STANDARD FORM FOR SIMPLE REPORTS                              Page G-2
   Revision 4


        Report name:  _____________________________


     OPEN _____________ .
           data set-name

     FIND ___________________________________________________________ .
              condition

     SEARCH _________________________________________________________ .
              condition

     SORT ___________________________________________________________ .
              sort-clause

   * INIT ______________   ________________________ .
          channel-number         filename

     REPORT START.

     TYPAGE ______________________________  .
            page length at terminal

     PAGE _______________________________  .
          page length of printing device

     BODY _______________________________  .
            number of printing lines to
            use on each page

   * HEADING PRINT ________________________________________________
                       print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

   * FOOTING ______  PRINT ________________________________________
             #lines            print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

   * ON START PRINT _______________________________________________
                       print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.
   STANDARD FORM FOR SIMPLE REPORTS                              Page G-3
   Revision 4



   * ON CHANGE _______________________
                expression

         PRINT ____________________________________________________
                  print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

   * ON CHANGE _______________________
                expression

         PRINT ____________________________________________________
                  print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.


     PRINT __________________________________________________________
            print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

   * ON CHANGE _______________________
                expression

         PRINT ____________________________________________________
                  print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

   * ON CHANGE _______________________


                expression

         PRINT ____________________________________________________
                  print-list

            FORMAT ________________________________________________
                       format-list
   STANDARD FORM FOR SIMPLE REPORTS                              Page G-4
   Revision 4



                   ___________________________________________  END.


   * ON END PRINT _________________________________________________
                       print-list

            FORMAT ________________________________________________
                       format-list

                   ___________________________________________  END.

     REPORT END.

     RELEASE.

     PRINT "_____________________________________________________" .
                message












                                 APPENDIX H

                          SYSTEM 1022 FATAL ERRORS



   The following is a list of fatal  error  messages  printed  by  System
   1022.


   1022 Fatal Internal Error called from module XX1400 at user nnnnnn.
   Please report.

        An internal error in 1022 has been discovered.  This often  is  a
        programming  error on the part of Software House, but it may also
        be caused by machine error.  The user should contact  the  system
        administrator immediately to report the problem.  This error will
        leave the user at 1022 command level.


   ?ABORTING DUE TO VERSION SKEW, SEGMENT XX1400.

        The segments of System 1022 which were called were not created in
        the  same version.  The system administrator should be contacted.
        This error will leave the user at monitor level.


   %% 1022 RUNTIME SYSTEM FOROTS/LIBOL VERSION SKEWED

        The version of FOROTS or LIBOL with which the program was  loaded
        is not the same as the one with which the 1022 object time system
        was created.  The system administrator should be contacted.   The
        program  continues  to  run,  although  it  may  fail due to this
        version skew.
   SYSTEM 1022 FATAL ERRORS                                      Page H-2
   Revision 4















                                 APPENDIX I

          SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES



|  System variables perform essentially three functions:
|  
|       1.  They return information about the system.
|  
|       2.  They configure the global operation of the system.
|  
|       3.  They allow the user to configure the system locally.
|  
|  The following table lists the System 1022 system  variables  that  are
|  user-settable in order by the commands and functions that are affected
|  by them.  System variables and their settings are described in  detail
|  in Chapter 2 of this manual.
|  
|  
|  FUNCTIONS/COMMANDS                          VARIABLES   __________________                          _________
|  
|  
|  ACCEPT                                      SYSDELIM
|  
|  ADD                                         SYSADDMSG
|                                              SYSALCMSG
|                                              SYSCBLSIGN
|                                              SYSEURODAT
|                                              SYSEXPTYPE
|                                              SYSNOYMD
|  
|  ALLOCATE                                    SYSALCMSG
|  
|  APPEND                                      SYSALCMSG
|                                              SYSCBLSIGN
|                                              SYSCUSTDMI
|                                              SYSDMETRID
|                                              SYSEURODAT
|                                              SYSMOYMD
|  
|  
|  
|  
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES       Page I-2
   Revision 4


|  FUNCTIONS/COMMANDS                          VARIABLES   __________________                          _________
|  
|  
|  CHANGE                                      SYSCBLSIGN
|                                              SYSEURODAT
|                                              SYSEXPTYPE
|                                              SYSNOYMD
|                                              SYSREP1
|                                              SYSREP2
|                                              SYSTRAPUP3
|  
|  Controls form feeds in reports              SYSREPSYNC
|  
|  Conversion functions                        SYSCVTERR
|                                              SYSCVTMSG
|  
|  CREATE                                      SYSPROT20
|  
|  DBEXEC+FIND                                 SYSDBEXMSG
|  DBEXEC+MAP                                  SYSDBEXMSG
|  
|  DBSET                                       SYSDSALIAS
|  
|  DFIND                                       SYSBETWEEN
|                                              SYSCASE
|                                              SYSCORESS
|                                              SYSDCORESS
|                                              SYSSCRFILE
|                                              SYSTEXTDOT
|  
|  Division by 0                               SYSDIV
|                                              SYSDIVMSG
|                                              SYSDIVP
|  
|  DUMP                                        SYSPROT20
|                                              SYSSCRDEV
|                                              SYSSWEDSRT
|  
|  DUMP SORTED                                 SYSSCRDEV
|                                              SYSSWEDSRT
|  
|  Error messages                              SYSERRTEXT
|                                              SYSIOMSG
|  
|  
|  FILE COPY                                   SYSPROT20
|  
|  Host language data conversion               SYSHLCVT
|                                              SYSHLDISP
|                                              SYSHLMODE
|  
|  
|  
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES       Page I-3
   Revision 4


|  FUNCTIONS/COMMANDS                          VARIABLES   __________________                          _________
|  
|  
|  IF                                          SYSBETWEEN
|                                              SYSCASE
|                                              SYSCORESS
|                                              SYSDCORESS
|                                              SYSEXPTYPE
|                                              SYSIFTYPE
|                                              SYSSCRFILE
|                                              SYSTEXTDOT
|  
|  LOAD                                        SYSCBLSIGN
|                                              SYSCUSTDMI
|                                              SYSDMETRID
|                                              SYSEURODAT
|                                              SYSNOYMD
|                                              SYSPROT20
|  
|  ON CHANGE                                   SYSREP1
|                                              SYSREP2
|  Out of range errors                         SYSRNGMSG
|  
|  Overflow/underflow errors                   SYSOVF
|                                              SYSOVFMSG
|                                              SYSOVFP
|  
|  Pass date values between HL and 1022        SYSUSERD1
|                                              SYSUSERD2
|                                              SYSUSERD3
|  
|  Pass integer values between HL and 1022     SYSUSERI1
|                                              SYSUSERI2
|                                              SYSUSERI3
|  
|  Pass real values between HL and 1022        SYSUSERR1
|                                              SYSUSERR2
|                                              SYSUSERR3
|  
|  Pass text values between HL and 1022        SYSUSERT10
|                                              SYSUSERT40
|                                              SYSUSERT5
|  
|  
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES       Page I-4
   Revision 4


|  FUNCTIONS/COMMANDS                          VARIABLES   __________________                          _________
|  
|  
|  PRINT                                       SYSAMBATTR
|                                              SYSDATEFMT
|                                              SYSEURODAT
|                                              SYSEXPTYPE
|                                              SYSNOYMD
|                                              SYSPAGE
|                                              SYSPCCOL
|                                              SYSPCRESET
|                                              SYSPCROW
|                                              SYSTEXTDOT
|  
|  PUSH                                        SYSEXECKP
|  
|  Resets page and line numbers in reports     SYSREPMODE
|  
|  
|  SEARCH                                      SYSBETWEEN
|                                              SYSCASE
|                                              SYSCORESS
|                                              SYSDCORESS
|                                              SYSEXPTYPE
|                                              SYSSCRFILE
|                                              SYSTEXTDOT
|  
|  
|  SELECT                                      SYSBETWEEN
|                                              SYSCASE
|                                              SYSCORESS
|                                              SYSDCORESS
|                                              SYSEXPTYPE
|                                              SYSSCRFILE
|                                              SYSTEXTDOT
|  SORT                                        SYSKEEPBUF
|                                              SYSSCRDEV
|                                              SYSSCRFILE
|                                              SYSSWEDSRT
|  
|  TOPS-10 segmentation                        SYSNOSEG
|  
|  TRANSACT                                    SYSALCMSG
|                                              SYSCBLSIGN
|                                              SYSCUSTDMI
|                                              SYSDMETRID
|                                              SYSEURODAT
|                                              SYSNOYMD
|  
|  
|  
|  
|  
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES       Page I-5
   Revision 4


|  FUNCTIONS/COMMANDS                          VARIABLES   __________________                          _________
|  
|  TYPE                                        SYSAMBATTR
|                                              SYSDATEFMT
|                                              SYSEURODAT
|                                              SYSEXPTYPE
|                                              SYSPAGE
|                                              SYSTEXTDOT
|  
|  Update Commands                             SYSDEQFAST
|                                              SYSENQTYPE
|                                              SYSKEEPPSI
|                                              SYSNOPSI
|                                              SYSNRETRY
|                                              SYSRESET
|                                              SYSTENQ
|                                              SYSTRETRY
|  
|  UPDATE OFF                                  SYSWRITE20
|  
|  USERCALL                                    SYSUSERADR
|  
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES       Page I-6
   Revision 4



   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-1
   Revision 4


                                   INDEX



   # (see pound sign), 2-14A          123 clause
   $ format, 6-26                       INIT command, 2-25
     with WKS files, 12-17            @ constructions
   $ACCESS ENQ/NOENQ clause             for command files, 2-17
     in MODIFY command, 7-21          @<file-descriptor>, 2-17
   $ACCESS RECLOCK/NORECLOCK clause   @=<variable-name>, 2-17
     in MODIFY command, 7-21          @TTY:, 2-17
   $ATTR clause                           
     in MODIFY command, 7-21          A format, 6-10
   $BDAYS, 2-47                       Abbreviations
   $DATE, 2-37                          of attributes, 3-11
   $DATEJUL, 2-49                       of commands, 2-3
   $DAY, 2-47                         Aborting commands
   $DECODE, 2-37                        during execution, 2-21
   $DINT, 2-37                          of several lines, 2-14A, 2-20
   $DSNAME clause                     ACCEPT command, 8-21
     in MODIFY command, 7-21            ON ERROR clause of, 8-21
   $EXP, 2-36                           syntax of, 8-21
   $FMONTH, 2-47                      Access
   $GETAB, 2-50                         simultaneous, 5-36
   $INT, 2-37                             ENQ system for, 5-40
   $JULDATE, 2-49                         retry system for, 5-39
   $LMONTH, 2-47                        to attributes, 11-18
   $LOCK option                         to data set, 11-1
     GETREC command with, 5-48        Activating deleted records, 5-4
   $LOG, 2-36                         ADD command, 5-4
   $LOG10, 2-36                         null values in, 5-5
   $MAX, 2-35                           pound sign (#) Z with, 5-6
   $MDYDATE, 2-47                       syntax of, 5-4
   $MEAN, 2-35                          with PL1022, 8-5
   $MIN, 2-35                         ADDCLUSTER
   $MOD, 2-36                           in DMD file, 3-31
   $MONTH, 2-46                       ADDITIVE attributes, 3-20
   $REAL, 2-37                        ADMIT command, 11-1 to 11-2
   $SQ, 2-36                            CLASS PASSWORD option, 11-4
   $SQRT, 2-36                            syntax, 11-4
   $STDEV, 2-35                         CLEAR option, 11-13
   $SYSPCPOS                            collections with, 4-45
     with DIF files, 12-9               FOR clause, 11-2, 11-4, 11-6,
     with WKS files, 12-26                11-9
   $TEXT, 2-38                          keyword abbreviations, 11-3
   $TEXT function, 2-38                 keywords in, 11-3
   $TEXTL, 2-38                         OWNER option, 11-17
   $TEXTR, 2-38                         PASSWORD keyword in, 11-1
   $TOT, 2-34                           syntax, 11-2
   $VDATE, 2-49                         with user-id
   $WDAY, 2-47                            TOPS-10, 11-5
   $YDAY, 2-47                            TOPS-20, 11-7
   $YEAR, 2-46                        ALIAS
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-2
   Revision 4


     definition of, 2-22C             Attribute qualification, 2-22D
   Alias, 4-4                           with SEARCH, 4-28
   Aligned data, 3-27                   with SELECT, 4-28
   ALLOCATE command, 5-8B             ATTRIBUTE statement, 3-11
     syntax of, 5-8B                    ABBREVIATION clause of, 3-11
   ALLOCATE statement                   ACCESS KEYED clause of, 3-13
     in DMD, 3-29                       additive attributes in, 3-20
   Alternate data set reference,        COLUMN clause of, 3-12
     2-23, 8-26, 8-30 to 8-31, 8-34     data types in, 3-12
     with SEARCH, 4-28                  DATE OF CHANGE in, 3-16
     with SELECT, 4-28                  DATE OF ENTRY in, 3-15
   AND operator, 4-17                   DELIMIT clause in, 3-17, 3-27
     omitting, 4-23                     error handling in, 3-17
   APPEND clause                        FILLER statement in, 3-12
     INIT command, 2-25                 INTEGER OF IDENTIFICATION in,
   APPEND command, 5-14                   3-16
     BUFFER option of, 5-15             keyed attributes in, 3-13
     CORE option of, 5-15               KEYED clause of, 3-13
     CUSTDMI option of, 5-15            KEYFILE clause, 3-16
     defaults for, 5-15                 LENGTH clause of, 3-12
     delimited-field input with,        order of, 3-20
       3-20                             RANGE clause of, 3-14
     error messages for, E-36           RESET option of, 3-15
     errors in, 3-44A                   sequence in DMD, 3-20
     for ISAM data file, 5-15           skipping blanks in, 3-12
     LRECL option of, 5-15              special data types in, 3-15
     NODME option of, 5-15              syntax of, 3-11, 3-14
     syntax of, 5-14                    TYPE keyword in, 3-12
   APPEND mode, 2-25                  Attributes, 1-5
   APPLIED transactions, 5-23           access to, 11-18
   Arithmetic functions, 2-36           adding to data set, 3-55
     $EXP, 2-36                         changing values of, 5-1
     $LOG, 2-36                         comparing, 4-27
     $LOG10, 2-36                       comparing in same record, 4-27
     $MOD, 2-36                         defining, 3-11
     $SQ, 2-36                          definition of, 1-5
     $SQRT, 2-36                        in DMD, 3-11
   Arithmetic mean, 2-35                in FIND command, 4-10
   Arrays                               keyed, 3-13
     defining, 8-18                       values distribution of, 4-59
     in constant functions, 2-19        many changes to, 5-9
   AS alias clause                      names of, 7-3
     in OPEN command, 4-4                 changing, 7-21
   AS clause                              definition of, 3-11
     of JOIN command, 4-36                omitting, 4-23
   ASCII data file transactions,          printing, 7-10
     5-26                               overlapping, 3-35
   Asterisk (PL) prompt, 8-3            printing, 7-3
   Asterisk (R) prompt, 9-4             security of, 11-2
   ATTEMPTS clause                      system-defined, 4-22
     in DMD, 3-29                     AU error messages, E-39
   Attribute descriptor               AUDIT BACKUP command, 10-8
     definition of, 2-22D               syntax of, 10-16
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-3
   Revision 4


   AUDIT CHECKPOINT command, 10-8,      INFORM AUDIT command for,
     10-18                                10-15
     syntax of, 10-18                   locked files for, 10-7
   AUDIT CLEAR command, 10-6, 10-19     manual mode for, 10-6
     syntax of, 10-19                   merging files for, 10-17
   AUDIT COMMENT command, 10-19         multiple updating before,
     syntax of, 10-19                     10-10
   AUDIT FIX command, 5-33, 10-10,      post-images in, 10-3, 10-17
     10-20                              pre-images in, 10-3
     syntax of, 10-20                   printing status of, 7-4
   AUDIT FORWARD command, 10-8,         quick fixes in, 10-20
     10-17                              readonly access for, 10-7
     syntax of, 10-17                   recovery procedure in, 10-8
   AUDIT LIST command, 10-14              access to, 10-10
     syntax of, 10-14                     administering, 10-10
     THRU clause in, 10-17                automatic, 10-11
     TILL clause in, 10-17                manual, 10-11
   AUDIT MERGE command, 10-17           resources used by, 10-12
     syntax of, 10-17                   restricting access to, 10-11
   AUDIT RECOVERY command, 10-8,        roll backward, 10-3
     10-10, 10-19                       roll forward, 10-3
     ALLOW clause of,                   starting, 10-13
       10-10 to 10-11                   storage for, 10-5
     syntax of, 10-19                   types of, 10-3
   AUDIT START command, 10-6, 10-13     when to use, 10-1
     AUTO option of, 10-14            audit trails
       turning off, 10-19               error messages for, E-39
     JOB option of, 10-14             AUTO.DMC file, 2-14
     LOCK option of, 10-14            Automatic start-up file, 2-14
     LOCKED clause, 10-7              AUXFILE statement
     syntax of, 10-13                   in DMD, 3-25
   Audit trails, 10-1                 Auxiliary files, 3-25, 4-5
     access to files for, 10-6          recovery after loss, 4-5
     automatic, 10-19                   relocating, 3-50
     automatic mode for, 10-6           renaming, 3-50
     backup procedure in, 10-16       Average
     block allocation in, 10-16         calculating the, 2-35
     checkpoints in, 10-8, 10-18          
     collections with, 4-45           BACKTO command, 5-7
     commands summary, 10-3             collections with, 4-45
     comments in, 10-19                 syntax of, 5-7
     defaults for, 10-15              Base e
     definition of, 10-1                exponentiation function, 2-36
     disk failures in, 10-4             logarithm function, 2-36
     dump for, 10-16                  BDAYS function, 2-47
     efficiency of, 10-1, 10-6,       BEG operator, 4-11
       10-12                          BEGINS operator, 4-11
     filenames in, 10-15              BET operator, 4-11
     files for, 10-5                  BETWEEN operator, 4-11
       locked, 10-7                   Binary to ASCII conversion
       locks on, 10-12                  $DECODE for, 2-37
       merging, 10-17                 Blank format, 6-23
       printing, 10-14                BLOCKED statement
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-4
   Revision 4


     in DMD file, 3-30                Characters
   Blocks                               reserved, 2-15
     logical records in, 3-30         Checkpoints, 10-8, 10-18
     structured                       CLEAR COLLECT command, 4-45
       DBSET command for, 8-28          syntax of, 4-45
   blocks                             CLEAR command, 8-22
     disk                               syntax of, 8-22
       error messages for, E-28D      CLEAR JOIN command, 4-38
   BLOCKS statement                     syntax of, 4-38
     in DMD file, 3-26                CLOSE CHAN,CL.IN in TOPS-10,
   BLOCKSIZE statement                  2-53
     in  DMD file, 3-30               CLOSE command, 4-8
   BODY command                         syntax of, 4-8
     in reports, 9-10                 CO error message, E-31
   Boolean expressions, 8-5           COBOL over-punch character, 3-6
     multiple matching in, 8-5        COL option
   BUFFER option                        with INIT 123 command, 12-10
     APPEND command with, 5-15          with INIT DIF command, 12-2
     in DUMP command, 3-52            COLLECT command, 4-42
     LOAD command with, 3-40            ADD clause of, 4-42
     TRANSACT command with, 5-29        ADD keyword in, 4-42
   Buffers                              ALL clause of, 4-42
     allocating, 7-23                   ALL keyword in, 4-42
     SET BUFFER command for, 7-23       AS clause of, 4-42
   Bundled data sets, 3-2               CLEAR COLLECT with, 4-45
     advantages of, 3-37                collection
     compared to unbundled, 3-37          compared to data set, 4-44
     OPEN command with, 8-32              name in, 4-42
     overlapping attributes with,       commands not allowed with,
       3-36                               4-45
                                        DBSET with, 4-43
   C format, 6-25                       for very large data sets, 4-43
   CALL statement                       INFORM COLLECT with, 7-4
     in PL1022, 8-16                    initial selection group in,
   CHANGE command, 5-1                    4-43
     GETREC with, 8-14                  JOIN with, 4-42, 4-45
     syntax of, 5-1                     LOCK OFF USERLOCK  with, 5-53
   Channel 1, 2-24                      LOCK ON USERLOCK  with, 5-53
   Channels                             selection condition in, 4-43
     allocating, 2-67                   sorted order in, 4-43
     default, 2-24                      syntax of, 4-42
     extended, 2-67                     SYSID with, 4-45
     in reports, 9-8                  Collection name, 4-42
     limits on, 2-67                  COLUMN clause
     numbers of, 4-55                   of ATTRIBUTE statement, 3-12
     output, 2-24                       with delimited input, 3-18
     reassigning, 2-24                Command execution
     releasing, 2-25                    aborting, 2-21
     reserved, 2-67                   Command files, 2-16
     TOPS-10, 2-67                      comments in, 2-21
     with PRINT command, 4-47, 4-54     ending, 2-18
   Character strings                    ending commands in, 2-18
     entering, 2-15                     errors in, 7-24
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-5
   Revision 4


     in PL1022, 8-24                  Constant function, 2-19
     in PL1022 or REPORT program,       arrays in, 2-19
       2-17                           Constants, 2-19
     line continuation in, 2-14A        changing values of, 2-19
     message display in, 2-20         CONT operator, 4-11
     typing, 2-20                     CONTAINS operator, 4-11
   Command groups in reports, 9-7     Continuation of lines, 2-14
   Command level, 2-16                  in command files, 2-14A
   Command line                         in format statements, 2-14A
     definition of, 2-13              CONTROL-C, 2-22
     interactive, 2-13                  to interrupt update, 2-1
   Command parameters, 2-22             to terminate commands, 2-22
   command scanner error messages,      with channels, 2-25
     E-1                              CONTROL-E, 7-17
   Command syntax, 2-13               CONTROL-O, 2-21
   command syntax                     CONTROL-U, 2-21
     error messages, E-1              Conventions
   Commands                             examples, 2-12
     abbreviations for, 2-3             syntax, 2-12
     aborting multiline, 2-14A,       Conversion
       2-20                             data type, 2-26A, 2-36
     aborting single, 2-21              functions for, 2-36
     comments in, 2-16                  numeric to display, 3-57
     descriptions of, 2-12              run-time errors in, 2-38
       conventions in, 2-12             type, 2-26A
     ending, 2-13                     Conversion functions, 2-36
       in command files, 2-18           $DATE, 2-37
     immediate, 2-20                    $DECODE, 2-37
     list of, 2-3                       $DINT, 2-37
     restricted, 2-3                    $INT, 2-37
     structure of, 2-13                 $REAL, 2-37
     summary of, 2-3                    text, 2-38
     syntax of, 2-13                  Copying files, 7-31
     variables in, 8-23               core error messages, E-31
   Comments                           CORE option
     in commands, 2-16                  APPEND command with, 5-15
     in files, 2-16                     LOAD command with, 3-40
     in PL1022, 8-6                     TRANSACT command with, 5-29
   COMP data type                     CREATE command, 3-45
     aligning, 3-13                     attributes in
     definition of, 3-5                   special, 3-48
   COMP1 data type                      compared to LOAD command, 3-37
     aligning, 3-13                     DATA keyword in, 3-46
     definition of, 3-5                 DATE OF CHANGE with, 3-48
   Comparison of text values, 4-13      DATE OF ENTRY with, 3-48
   Compatibility of 1022 versions,      DMI file name in, 3-46
     5-6                                DMS file name in, 3-46
   COMPILE command, 8-2, 8-35           file name in, 3-46
     source file for, 8-35              INTEGER OF IDENTIFICATION in,
     syntax of, 8-35                      3-48
   Conditional statements               logical record length in, 3-46
     DBSET with, 8-29                   RESET statement with, 3-48
   CONST function, 2-19                 SET option of, 3-46
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-6
   Revision 4


     special attributes in, 3-48        adding attributes to, 3-55
     suppressing messages in, 3-46      alternate reference to, 2-23,
     syntax of, 3-45                      8-26, 8-38
   CT operator, 4-11                    building, 3-1
   Current data set, 8-25               bundled, 3-2
     after CLOSE command, 4-8             vs. unbundled, 3-37
     setting, 4-7                       changing bundled to unbundled,
   Current record, 4-30                   3-54
   Custom reports, 9-50                 changing unbundled to bundled,
   CWISE option                           3-54
     with INIT 123 command, 12-10       current, 8-25
                                          printing names of, 7-10
   D format, 6-10                           SYSDSFILE for, 2-55
   Damage recovery                        status of, 7-11
     audit trail, 10-1                  definition of, 1-5
   Damage to data set, 5-32             descriptors in
     Audit Trail for, 5-35                definition of, 2-22C
     automatic repair of, 10-19           printing, 7-4
     DBSYSV for, 5-33                   information about, 7-2
     from bugs, 5-35                    master, 3-52
     messages for, 5-33                 multifile, 1-5
     printing information on, 7-5       multiple, 3-58, 8-25
     repairing, 5-34                      example of, 8-30
     restricted access after, 10-11       reports for, 9-37
     status information on, 7-5         multiple views of, 8-26
   damage to files                      names of, 2-55
     error messages for, E-21             alias, 4-4
   Data base                              changing, 7-21
     definition of, 1-5                   definition of, 2-22C
     structure of, 1-5                  output, 3-52
   Data display commands                owners of, 11-1
     list of, 4-46                      related, 4-32
   Data extraction                      restoring, 10-1
     to DIF files, 12-1                 restructuring, 3-55
     to WKS files, 12-9                 security of, 11-1
   Data field                           separate views of single, 4-4
     columns in, 3-12                   simultaneous opening of, 8-25
     length of, 3-12                    status information on, 7-4
   Data file                            structure of
     definition of, 3-52                  defining, 3-11
     input from, 3-3                      printing, 7-11
   Data input                           unbundled, 3-2
     logical record size of, 3-28         creating, 3-45
   Data Interchange Format                DUMP command for, 3-52
     see DIF files                        vs. bundled, 3-37
   Data Management Description,       DATA statement
     3-10                               in DMD file, 3-23
   Data Management Input file, 3-3    Data type
   Data programming language, 8-1       COMP, 3-5
   Data set                             COMP1, 3-5
     current, 4-7                       DATE, 3-5
   Data sets                            DOUBLE COMP, 3-5
     access to, 4-1                     DOUBLE INTEGER, 3-5, 8-18
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-7
   Revision 4


     INTEGER, 3-5                       multiple type definition in,
     REAL, 3-5                            8-19
     TEXT, 3-5                          redefinition in, 8-20
   Data types                           subscripts in, 8-19
     conversion of, 2-26A, 2-36         syntax of, 8-18
     definitions of, 3-5              Defining data set structure,
     in ATTRIBUTE statement, 3-12       3-11
     input, 3-5                       DELETE command, 5-2
   DATE                                 with FIND command, 5-2
     data fields, 3-7                 Deleted records
     data type                          selecting, 4-26
       conversion to, 2-37            Deleting files, 7-31
       definition of, 3-5             DELIMIT clause
     formats, 6-10                      in ATTRIBUTE statement, 3-17
   DATE functions, 2-37                 in DMD, 3-18, 3-27
   Date functions, 2-46               Delimited-field input, 3-5,
     errors in, 2-46                    3-17, 3-27
     list of, 2-46                      APPEND command with, 3-20
   DATE OF CHANGE attribute             LOAD command with, 3-20
     with ATTRIBUTE statement, 3-16     TRANSACT command with, 3-20
     with CREATE command, 3-48        DESC clause, 5-16A
   DATE OF ENTRY attribute            DESC option
     with ATTRIBUTE statement, 3-15     of DUMP command, 3-52
     with CREATE command, 3-48        Description File, 3-10
   DATEJUL function, 2-49             DFIND command, 4-26
   Dates, 2-32                          with wildcards, 4-14
     all-numeric, 3-8                 DIF clause
     conversion of, 2-46                INIT command, 2-25
     data types with, 2-32            DIF files, 12-1
     formats for, 3-7, 6-10             data positioning, 12-8
     functions for, 2-46                data type conversion, 12-3
     input formats for, 3-7             print formats, 12-4
     quotation marks with, 2-32         printing to, 12-3
   DAY function, 2-47                 DINT function, 2-37
   DBEXEC call                        Direct mode
     for segmentation, D-1              definition of, 5-21
   DBSET command, 4-7, 8-25           Directory strings, 11-7
     at labels, 8-27                  DISABLE JOIN command, 4-39
     implicit, 8-27 to 8-28, 8-38     Disk access, 7-23
     in PL1022, 8-27                  disk block error messages, E-28D
     in structured blocks, 8-28       Disk files
     syntax of, 4-7                     output to, 4-47
     with collections, 4-43             reading commands in, 2-16
     with conditional statements,     Disk storage
       8-29                             allocating, 5-8B
   DBSYSV for System variables,         summary of requirements for,
     2-63                                 1-7
   DDL, 1-1                           Display commands
   Debugging pl1022 programs            list of, 4-46
     see pl1022, debugger             Display conversions, 3-57
   DEFINE command, 8-18               DMA file, 8-35
     in PL1022, 8-18                  DMC file, 2-17
     initial values in, 8-20          DMD file, 3-1, 3-10, 3-21
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-8
   Revision 4


     ALLOCATE clause in, 3-29           syntax of, 4-31
     ATTEMPTS clause in, 3-29         DUMP command, 3-51
     AUXFILE statement in, 3-25         BUFFER clause in, 3-52
     block allocation in, 3-29          data file name in, 3-52
     BLOCKED statement in, 3-30         DATA option of, 3-52
     BLOCKS statement in, 3-26          DESC option of, 3-52
     BLOCKSIZE statement in, 3-30       description file in, 3-52
     data description in, 5-16A         efficiency of, 3-52
     DATA statement in, 3-23            examples of, 3-55
     definition of, 3-21                for large data sets, 3-52
     disk structures for, 3-28          output data set name in, 3-52
     efficient loading of, 3-28         overlapping attributes with,
     ENQ statement of, 3-32               3-36
     examples of, 3-33                  record extraction in, 3-53
     FORMFEED statement in, 3-31        record order in, 3-53
     LOADING section of, 3-22           SET option of, 3-52
     logical blocks in, 3-30            SORTED BY clause in, 3-53
     magnetic tape input to, 3-30       syntax of, 3-51
     mode of input data in, 3-27        to bundle data sets, 3-54
     name extension in, 3-39            to unbundle data sets, 3-54
     NOENQ statement of, 3-32           UNBUNDLED option of, 3-52
     NORECLOCK statement in, 3-32         
     NULL statement in, 3-30          E format, 6-7
     output file for, 3-23              omitting arguments in, 6-9
     PAGES statement in, 3-26         EDIT command, 7-20
     parameters in, 3-31                on TOPS-10, 7-20
     queue for update access to,        on TOPS-20, 7-20
       3-32                             syntax of, 7-20
     RECLOCK statement in, 3-32       Efficiency of
     RECMODE in, 3-27                   aborting commands, 2-21
     RECORDS statement in, 3-25         adding batches of records,
     SCRATCH statement of, 3-28           5-14
     sections of, 3-21                  ALLOCATE command, 5-8B
     SET statement in, 3-25             APPEND vs. ADD commands, 5-14
     SET statement of, 3-23             audit files, 10-6
     temporary storage in, 3-28         audit trails, 10-1, 10-12
     TRUNCATE clause in, 3-29             AUDIT CHECKPOINT in, 10-8
   DME file, 3-44A                        buffers in, 10-14                                          _______
   DMF file, 8-44                         LOCKED clause in, 10-7
   DMI file, 3-3, 3-23                    NOREAD clause in, 10-7
     data file for unbundled, 3-48      buffer allocation, 7-23
     relocating, 3-48                   BUFFER option
     renaming, 3-48                       in APPEND command, 5-15
   DMS file, 3-23                         in DUMP command, 3-52
     SET statement of, 3-23               in LOAD command, 3-40
   DMV default extension, 4-26            in TRANSACT command, 5-29
   DMX file, 8-36, 8-42                 buffering data in update mode,
   DOUBLE INTEGER                         5-8
     data type                          bundled vs. unbundled data,
       conversion to, 2-37                3-37
       definition of, 3-5               case matching in FIND, 4-13
   DOUBLE INTEGER data type, 8-18       changing keyed attributes, 5-9
   DROP command, 4-31                   CORE option
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES   Page Index-9
   Revision 4


       in APPEND command, 5-15            setting, 7-24
       in KEY command, 5-10             codes, 2-66
       in keying attributes, 5-10       handling, 2-66, 3-44A, 8-44
       in LOAD command, 3-40              modifying, 3-17
       in transaction, 5-29             log file, 3-17
     data compaction, 3-38                suppression of, 3-40, 5-15,
     DUMP command, 3-52                     5-29
     dumping large data sets, 3-52      log file (DME), 3-44A
     EVALUATE command, 8-22             messages, 2-66
     FIND vs. SEARCH, 4-27                COMPILE command, E-42
     integer storage in DMD, 3-14         CP, E-42
     keyed attributes, 3-13               DB, E-41
     large sorts, 4-59                    PERFORM command, 8-44, E-42
     large-scale updates, 5-7, 5-12     recovery, 7-24
     MAP command                      error
       BY option of, 4-32               codes
     OPEN command with PL1022, 8-34       list of, E-1
     ordering records with DUMP,        messages
       3-53                               APPEND command, E-36
     record retrieval, 4-29               AU, E-39
     retrieval when adding records,       audit, E-39
       5-8B                               CO, E-31
     SELECT vs. SEARCH, 4-29              command scanner, E-1
     shortcuts in FIND command,           CS, E-1
       4-23                               disk block, E-28D
     simultaneous update attempts,        fatal, E-30, G-4
       5-40                               FD, E-21
       SYSDEQFAST, 5-41                   FI, E-20
     simultaneous updates, 5-38           file damaged, E-21
     SORT command, 4-57                   find and save, E-20
       buffer allocation with, 2-58       FIND command, E-20
       SYSKEEPBUF with, 2-58, 4-58        FO, E-26
     updating, 7-23                       format, E-26
     UPTO command, 5-6                    HL, E-33
   efficiency of                          host language, E-33
     segmentation setting, D-1            I/O, E-28D
   ENABLE JOIN command, 4-39              LD, E-36
     syntax of, 4-39                      list of, E-1
   END, 8-11                              LOAD command, E-36
   ENDIF, 8-8, 8-11                       MI, E-23
   ENQ access, 5-40                       miscellaneous, E-23
     changing, 7-21                       OP, E-21
   ENQ statement                          OPEN, E-21
     in DMD file, 3-32                    out of core, E-31
   EQ clause                              PL, E-32
     with print list, 8-23                PL1022, E-32
   EQ operator, 4-11                      print output, E-26
     omitting, 4-23                       SAVE command, E-20
   EQUAL operator, 4-11                   SO, E-28C
   EQUALS operator, 4-11                  SORT command, E-28C
   EQV operator, 4-17                     SP, E-42
   Error                                  SPSS interface, E-42
     character                            SY, E-30
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-10
   Revision 4


       TR, E-39                         definition of, 2-22
       transact, E-39                 File device, 2-22A to 2-22B
       UP, E-28A                      File name
       update, E-28A                    definition of, 2-22A to 2-22B
   ERROR clause, 3-17                   extensions, 2-22A to 2-22B
   Errors                             file name
     batch stream, 7-24                 extensions
     in APPEND command, 3-44A             table of, A-1
     in command files, 7-24           Files
     in data set creation, 3-17         access to, 2-22A
     in LOAD command, 3-44A             conversion of, 3-58
     in TRANSACT command, 3-44A         copying, 7-31
   ESC                                  deleting, 7-31
     to end a command, 2-13             description, 3-10
   EVALUATE clause                      DMD, 3-10
     of ON CHANGE command, 9-29         DME, 3-44A
   EVALUATE command, 8-22               DMI, 3-3
     efficiency of, 8-22                DMS, 3-23
     EQ clause with, 8-23               extending, 2-25
     in PL1022, 8-22                    in use, 7-10
     syntax of, 8-22                    journal, 10-1
   Evaluation                           manipulation of, 7-31
     of logical operators, 4-17         output, 4-54
   Examples                             output to, 4-47
     conventions in, 2-12               renaming, 7-31
     explanation of, 2-12               typing, 7-32
   Exclamation mark (!), 2-16         files
   EXIT command, 2-1                    damaged
   Exponential format, 6-7                error messages for, E-21
     omitting arguments in, 6-9       FILLER statement
   Expressions                          in DMI file, 3-12
     arithmetic, 2-25                   with delimited input, 3-18
     comparing, 2-31                  FILOP. call in TOPS-10, 2-58
     conversion in, 2-26A             FINAL section in reports, 9-26
     date, 2-32                       FIND command, 4-10
     evaluation of, 2-26                ALL keyword in, 4-21
     mixed mode, 2-26A                  case in, 4-13
     storing, 2-31                      collapsing, 4-23
                                        compared to SEARCH, 4-27
   F format, 6-6                        error messages for, E-20
     omitting arguments in, 6-9         FILE clause of, 4-26
   fatal errors, E-30                   FILE in
     list of, G-4                         collections with, 4-45
   FI error messages, E-20              FILE keyword in, 4-22
   Field, 1-5                           GETREC with, 8-14
   Field width                          internal record number in,
     of attributes in DMD, 3-12           4-22
   Field-delimited input, 3-5,          LAST keyword in, 4-21
     3-17, 3-27                           leaving local mode with,
   File                                     4-30
     definition of, 1-5                 logical operators in, 4-17
   FILE command, 7-31                     omitting, 4-23
   File descriptor                      messages after, 7-25
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-11
   Revision 4


     relational operators in, 4-11        scale factors in, 6-9
       omitting, 4-23                     sign in, 6-3
     saved files in, 4-22               O (octal), 6-6
     selection conditions in, 4-10      operations control, 6-26
     shortcuts in, 4-23                 P (picture), 6-16
     sorted order in, 4-26                contractions in, 6-22A
     syntax of, 4-10                      decimal alignment in, 6-19
     SYSID in, 4-22                       limits on, 6-23
     system responses to                  numeric control group for,
       altering, 4-10                       6-16
     unkeyed attributes in, 4-21          special editing in, 6-19
     with wildcards, 4-14                 with other formats, 6-22
   Floating point format, 6-6           paper motion control, 6-25
   FMONTH function, 2-47                parentheses in, 6-26
   FO error messages, E-26              picture (see P), 6-16
   FOOTING command                      positional, 6-23
     in compiled report programs,       quoted literal, 6-15
       8-44                             repeating, 6-26
     in simple reports, 9-9             S (scrolling), 6-11
   Format                                 append option of, 6-12
     $, 6-26, 12-17                       modes in, 6-13
     A, 6-10                            SA, 6-12
     blank, 6-23                        scrolling (see S), 6-11
     C, 6-25                            separators in, 6-1
     commas in, 6-1                     slash (/), 12-4, 12-17
     conventions in commands, 2-12      slash(/), 6-24
     D (date), 6-10                     spaces in, 6-1
     definition of, 6-1                 suppressing <RET> after, 6-26
     E (exponential), 6-7               switch, 6-26
       omitting arguments in, 6-9       syntax of, 6-1
     ending, 6-27                       T (tab), 6-23
     F (floating point), 6-6            text, 6-10
       omitting arguments in, 6-9       X, 6-23, 12-4, 12-17
     G (general), 6-14                format
     Hollerith, 6-15                    error messages for, E-26
     I (integer), 6-4                 Formatter operations, 6-26
       omitting arguments in, 6-9     FORMFEED statement
     in PRINT command, 6-1              in DMD file, 3-31
     in TYPE command, 6-1             Full description file, 3-21
     L, 12-14                         Functions
     line continuation in, 2-14A        summary, 4-51
     list of, 6-29                      System, 2-33
     literal, 6-15                      Totals (see totals functions),
       quoted, 6-15                       2-33
     new line, 6-24                       
     NH, 6-15                         G format, 6-14
     numeric, 6-2                     GE operator, 4-11
       blanks in, 6-2                 General format, 6-14
       characters in, 6-3             GETREC command, 4-29
       decimals in, 6-3                 $LOCK keyword in, 4-30
       explanation of parts of, 6-2     $LOCK option of, 5-48
       field width in, 6-3              in PL1022, 8-14
       omitting arguments in, 6-9       LEAVE command with, 8-15
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-12
   Revision 4


     record number in, 4-30             with labels, 8-7
     record sequence number in,       IF THEN ELSE statement, 8-8
       8-14                           IF THEN END statement, 8-8
     SYSRECMODE with, 2-60, 4-30      IF THEN ENDIF statement, 8-8
     with MAP, 4-35                   IF THEN statement, 8-8
   GETREC section in reports, 9-22    IGNORE DAMAGE command, 5-33
   Global mode, 4-30                  Immediate commands, 2-20
   GOTO clause                        INFORM AUDIT command, 10-15
     in ON CHANGE command, 9-28       INFORM command, 7-2
   GOTO statement                       ADMIT option of, 7-3
     in PL1022, 8-7                     ATTRIBUTES clause of, 7-3
       equivalent to THEN, 8-11         AUDIT option of, 7-4
       syntax of, 8-7                   BASE option of, 7-4
   Group headings, 9-12                 COLLECT option of, 7-4
   Group totals, 9-12                   DAMAGE option of, 7-5
   GT operator, 4-11                    DMX option of, 7-5
                                        FILES option of, 7-10
   HEADING command                      for security information, 7-3
     in compiled report programs,       JOIN option of, 7-10
       8-44                             NAMES option of, 7-10
     in simple reports, 9-9             SET option of, 7-10
   HEADING section in reports, 9-24     STATUS option of, 7-11
   Headings                             STRUCTURE DATA option of, 7-12
     group, 9-12                        STRUCTURE option of, 7-11
   HELP command, 2-2                    STRUCTURE TABLE option of,
   Hierarchy in reports, 9-19             7-13
   HL error messages, E-33              VERSION option of, 7-15
   Hollerith format, 6-15             INFORM DAMAGE command, 5-33
   Host language                      INFORM FILES command, 2-67
     audit interface, 10-16           INFORM NAMES command
   host language                        with PRINT command, 4-50
     error messages, E-33             INFORM STRUCTURE command, 3-11
   Hyphen                             INIT APPEND command
     in interactive commands, 2-14      in reports, 9-26
                                      INIT command, 2-24
   I format, 6-4                        123 option of, 2-25, 12-9
     omitting arguments in, 6-9           COL option of, 12-10
   Identification of records, 3-16        CWISE option of, 12-10
   IF ELSEIF ELSE statement, 8-9          NRANGE option of, 12-10
   IF statement, 8-7                      ROW option of, 12-10
     compatibility with, 8-11             RWISE option of, 12-10
     compound, 8-8                      APPEND option of, 2-25
       syntax of, 8-10                  DIF option of, 2-25, 12-1
     DBSET command with, 8-29             COL option of, 12-2
     END vs. ENDIF in, 8-11               NCOLS option of, 12-2
     END with, 8-8                        ROW option of, 12-2
     ENDIF with, 8-8                    in reports, 9-8
     ending, 8-11                       syntax of, 2-24
     for single command, 8-8          INITIAL section in reports, 9-21
     in  PL1022, 8-7                  Input data
     in command block, 8-8              delimited-field, 3-5, 3-17
     nested, 8-10                       field-delimited, 3-27
     structured, 8-8                    formats, 3-3
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-13
   Revision 4


     logical record size, 3-28        KEY $VERIFY command, 7-15
     record formats, 3-3              KEY command, 5-9
     requirements, 3-3                  collections with, 4-45
     types, 3-5                         purpose of, 5-9
   INT function, 2-37                   syntax of, 5-9, 5-11
   INTEGER                            Key tables, 5-9
     data fields, 3-5                   ATTRIBUTE statement for, 3-13
     data type                          damaged, 5-34
       conversion to, 2-37                overlapping attributes for,
       definition of, 3-5                   3-36
     to DOUBLE INTEGER conversion,      FIND command for, 4-10
       2-37                             generating, 5-9
   INTEGER format, 6-4                  rebuilding, 5-9
     omitting arguments in, 6-9         reformatting, 5-13
   INTEGER OF IDENTIFICATION            removing, 5-9
     with ATTRIBUTE statement, 3-16     reserving space in, 3-30
     with CREATE command, 3-48          status of, 7-15
     with RESET, 3-55                   storage in auxiliary files,
   Integer range, 3-14                    3-16
   Interrupts                           suppressing generation of,
     with ENQ, 5-41                       3-40
   IO error messages, E-28D             text values in, 4-13
   ISAM data files, 3-27              Keyboard macros, 12-22
     appending from, 5-15             KEYED INACTIVE status, 3-40,
   Item                                 5-11
     definition of, 1-5               KEYFILE clause, 3-16
                                      keywords
   JOIN command, 4-36                   table of, B-1
     AS clause of, 4-36                   
     changing definitions with,       L format, 12-14
       4-38                           Labels
     collections with, 4-45             DBSET command at, 8-27
     examples of, 4-40                  in PL1022, 8-6
     mapping                          LAINVI, 3-44A
       many-to-many, 4-37             Large data sets module, 1-5
       one-to-many, 4-37                auxiliary files in, 3-25
     mapping in                         multifile data sets, 4-5
       many-to-one, 4-37              LARRANG, 3-44A
       one-to-one, 4-37               LD error messages, E-36
     NOMSG clause of, 4-36            LE operator, 4-11
     referenced in compiled pl1022,   LEAVE command
       8-39, 8-43                       with GETREC, 8-15
     simplified MAP with, 4-39        LEAVE statement, 8-13
     syntax of, 4-36                    in PL1022, 8-13
     UNI clause of, 4-36              LENGTH clause
   Join name, 4-36                      of ATTRIBUTE statement, 3-12
   Join path, 4-37                      with delimited input, 3-18
   Joined data sets, 4-36             LET command, 8-20
   Journal files, 10-1                  for System variables, 2-63
   JULDATE function, 2-49               in PL1022, 8-20
                                      Line continuation, 2-14
   KEY $CHECKSUM command, 7-15          in command files, 2-14A
   KEY $SCAN command, 7-15            Line number in reports, 9-3
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-14
   Revision 4


   Literals in formats, 6-15            in DMD file, 3-28
   LMONTH function, 2-47                in LOAD command, 3-41
   LOAD command, 3-39                   with SIXBIT ISAM, 3-28
     BUFFER option of, 3-40           LT operator, 4-11
     compared to CREATE command,          
       3-37                           MACRO routines
     CORE option of, 3-40               with USERCALL, 7-32
     CUSTDMI option of, 3-41          Magnetic tape
     DATA option of, 3-39               LOAD data from, 3-44
     data set name in, 3-39             non-standard block size for,
     delimited-field input with,          3-30
       3-20                           MAP command, 4-32, 8-30
     DESC clause of, 3-39               BY clause of, 4-32
     error messages for, E-36           DBSET with, 8-30
     errors in, 3-44A                   GETREC with, 4-35
     examples of, 3-41 to 3-42          JOIN with, 4-39
     FORMFEED option of, 3-41           LOGICAL clause of, 4-34
     input data file in, 3-39           messages after, 7-25
     logical record size in, 3-41       multi-locator, 4-35
     LRECL option of, 3-41              syntax of, 4-32
     magnetic tape, 3-44              Mapping in JOIN command
     MAX option of, 3-40                many-to-many, 4-37
     maximum number of records in,      many-to-one, 4-37
       3-40                             one-to-many, 4-37
     NODME option of, 3-40              one-to-one, 4-37
     NOKEYS option of, 3-40           Master data set
     NOMSG option of, 3-40              data field for, 5-17
     SET option of, 3-39                definition of, 3-52, 5-18
     suppressing messages in, 3-40    Master records, 5-21
     syntax of, 3-39                  MATCHES operator, 4-11, 4-14
   LOADING section                    MAX, 2-35
     of DMD file, 3-22                Maximum
   Local mode, 4-29                     calculating the, 2-35
     leaving, 4-30                    MDYDATE function, 2-47
   Locators                           MEAN
     in TRANSACT command, 5-19          calculating the, 2-35
   LOCK OFF RECORD command, 5-49      MEAN function, 2-35
   LOCK OFF USERLOCK command, 5-50    memory
     COLLECT with, 5-53                 segmentation and size of, D-1
   LOCK ON RECORD command, 5-49       Memory requirements
   LOCK ON USERLOCK command, 5-50       summary of, 1-8
     COLLECT  with, 5-53              Messages
   Logical block                        controlling, 7-25
     records in, 3-30                 messages
   Logical operators                    warning, F-1
     in FIND command, 4-17            MI error messages, E-23
     omitting, 4-23                   MIN, 2-35
     precedence in evaluation of,     Minimum
       4-17                             calculating the, 2-35
   Lotus 1-2-3 worksheet format       Modes
     see WKS files                      AUTO, 10-6
   LRECL clause                         Direct, 5-21
     in CREATE command, 3-46            displaying local/global
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-15
   Revision 4


       SYSRECMODE for, 2-60           NULL statement
     global, 4-30                       in DMD file, 3-30
     in scrolling format, 6-13        Numeric formats, 6-2
     local, 4-29                        omitting arguments in, 6-9
       DROP command for, 4-31           parts of, 6-2
     manual, 10-6                       scale factors in, 6-9
     SIXBIT (see SIXBIT), 3-9             
     SORTED, 5-22                     O format, 6-6
     update, 5-8                      Octal format, 6-6
   MODIFY command, 3-12, 5-47, 7-21   ON CHANGE command
     syntax of, 7-21                    channels in, 9-13
   Monitor functions, 2-50              control expressions, 9-50
   Monitor tables                       EVALUATE clause of, 9-29
     retrieving values from, 2-50       features for complex reports,
   MONTH function, 2-46                   9-28
   Multifile data sets, 1-5, 3-25       GOTO clause of, 9-28
   Multiple data set files, 3-58        heading, 9-24
   Multiple data sets, 8-25             hierarchy in, 9-25
     example of, 8-30                   ignoring, 9-33
   Multiple scratch devices, 4-58       in reports, 9-7
                                        in simple reports, 9-12
   Named Ranges, 12-10                  null, 9-19
   NBEG operator, 4-11                  options of, 9-28
   NBEGINS operator, 4-11               PRETOTAL clause of, 9-30
   NBET operator, 4-11                    restrictions on, 9-32
   NBETWEEN operator, 4-11              PRINT statement in, 9-12
   NCOLS option                         syntax of, 9-12
     with INIT DIF command, 12-2        System totals of, 9-50
   NCONT operator, 4-11                 totals in, 9-25
   NCT operator, 4-11                     distributed, 9-34
   NE operator, 4-11                    variables in, 9-50
   NEQ operator, 4-11                 ON END command
   Nested PL1022 programs, 8-25         in complex reports, 9-25
   New line format, 6-24                in reports, 9-25
   NH format, 6-15                      in simple reports, 9-13
   NMATCHES operator, 4-11, 4-14      ON START command, 9-13, 9-24
   NOENQ statement                    One-direction JOIN, 4-36
     in DMD file, 3-32                OP error messages, E-21
   NOMSG clause                       OPEN command, 4-1
     of JOIN command, 4-36              $MISSING option of, 4-5
   NOREAD clause                        ACCESS READONLY clause of, 4-2
     of AUDIT START command, 10-7       AS alias clause of, 4-4
   NORECLOCK access, 5-47               efficiency with PL1022, 8-34
     changing, 5-47                     error messages for, E-21
   NORECLOCK statement                  for multiple data set file,
     in DMD file, 3-32                    3-58
   NOSETNAME, 2-57                      in complex reports, 9-21
   NOT                                  in PL1022, 8-3, 8-31 to 8-32
     with relational operators,         INFORM SET command with, 4-8
       4-12                             NOCLOSE clause of, 4-1
   NOT operator, 4-17                   PASSWORD clause of, 4-2
   NRANGE option                        separators in, 4-1
     with INIT 123 command, 12-10       syntax of, 4-1
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-16
   Revision 4


     with bundled data sets, 8-32     PAGES statement
     with multifile data sets, 4-5      in DMD file, 3-26
     with unbundled data sets, 8-32   Paper motion control format,
   Operating system compatibility       6-25
     summary of, 1-7                  PARAMETER section in DMD, 3-31
   Operations control format, 6-26    Password
   Operators                            in ADMIT CLASS PASSWORD command,
     arithmetic                           11-4
       precedence of, 2-26              in ADMIT command, 11-1
     logical, 4-17                      in PERMIT command, 11-2, 11-18
     relational, 4-11                   with OPEN command, 4-2, 11-2
   Optimization                       PC extract, 12-1
     for key tables, 5-13               DIF files, 12-1
   OPTIMIZE command, 5-13               WKS files, 12-9
     collections with, 4-45           Perforations, 9-10
     compared to KEY command, 5-13    PERFORM command, 8-2, 8-35, 8-42
     syntax of, 5-13                    data set matching, 8-37
   OR operator, 4-17                    environment checking, 8-37,
     ommitting, 4-23                      8-42
   Output channels (see Channels),      syntax of, 8-42
     2-24                             PERMIT command, 11-18
   Output data set                      ACCESS READONLY option, 11-18
     definition of, 3-52                FOR clause, 11-18
   Output files                         syntax, 11-18
     PRINT command for, 4-54          Personal computers
   Output list, 4-48                    extracting data to, 12-1
   Output of values to terminal,      Picture editing, 6-16
     4-47                             Picture format (see P format),
   Over-punch characters, 3-5           6-16
   Overflow                           PL1022, 8-1
     conditions of, 2-29                ADD command with, 8-5
     definition of, 2-28                boolean expressions in
     suppressing messages for, 2-30       multiple matching in, 8-5
   Overlapping attributes, 3-35         branching in, 8-6
   overlays                             changing join definitions in,
     definition of, D-1                   4-39
                                        command files in, 2-17, 8-24
   P format, 6-16                       command syntax in, 8-1
     contractions in, 6-22A             commands for
     decimal alignment in, 6-19           list of, 8-2
     limits on, 6-23                    compiling, 8-3, 8-35
     numeric control group for,         conditional branching in, 8-7
       6-16                             DBSET command in, 8-27
     special editing in, 6-19           ending, 8-3
     with other formats, 6-22           error messages for
   Page                                   list of, E-32
     appearance, 9-10                   errors in, 8-3
     formatting commands, 9-8           executing, 8-1, 8-3, 8-35
     number, 9-3                        for reports, 9-20
   PAGE command                         IF statement in, 8-7
     in reports, 9-10                   interactive entry of, 8-3
   Paged output                         labels in, 8-6
     outside reports, 9-11              multiple matching in, 8-5
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-17
   Revision 4


     nested, 8-25                         with ALL keyword, 4-50
     OPEN command in, 8-3, 8-31         GETREC with, 8-14
     operators in, 8-5                  in reports, 9-7
     prompt for, 8-3                    INFORM NAMES command with,
     QUIT command with, 8-3               4-50
     REPEAT statement in, 8-12          interactive
     reports within, 9-5                  pretotals in, 9-30
     starting, 2-16, 8-3                ON clause of, 2-24, 4-47,
     STOP statement in, 8-17              4-54, 12-3
     stopping execution of, 8-17        ON option, 12-12
     structured loops in, 8-11          output files with, 4-54
     subroutines in, 8-16               output list of, 4-48
     THEN keyword in, 8-7               pretotals in, 4-53
     THEN label in, 8-11                real values in, 4-52
     using 1022 commands in, 8-4        stopping output from, 2-21
     variables in, 8-17                 syntax of, 4-47
   Pl1022                               SYSID with, 4-50
     debugger, 8-34                     totals in, 4-51
   PL1022 error message, E-32         Print list, 4-48
   POP command, 7-30                    EQ clause with, 8-23
   Positional formats, 6-23           print output
   Pound sign                           error messages for, E-26
     as first character in command,   PRINT statement
       2-20                             in ON CHANGE command, 9-12
     COM command, 2-21                  in reports, 9-25
     for immediate commands, 2-20     Printer options, 7-28
     prompt, 2-14A                    Program input
     T command, 2-20                    from report output, 9-4
     TYPE command, 2-20               Program structure, 1-7
     Z, 2-21                          Programming, 8-1
       command, 2-20                  Prompt
       with ADD command, 5-6            asterisk, 2-1, 2-16
   Precedence                           asterisk (PL), 2-16, 8-3
     of arithmetic operators, 2-26      asterisk (R), 2-16, 9-4
     of logical operators, 4-17         colon, 2-16, 7-18, 7-20
   Precompiling, 8-35                   for PL1022, 8-3
   PRETOTAL clause                      pound sign, 2-14A, 2-16
     of ON CHANGE command, 9-30         setting command, 7-26
   Pretotals                            SOS, 7-20
     in interactive PRINT command,      TECO, 7-18
       9-30                           Protection code,
     in PRINT command, 4-53             2-22A to 2-22B, 3-24
     in reports, 9-20, 9-30           PUSH command, 7-30
       restrictions on, 9-32              
   PRINT command, 4-47                Qualified attribute reference,
     ALL option of, 4-50                2-22D
     attribute values in, 4-50          with CHANGE, 2-22D
     channels with, 4-47, 4-54          with PRINT, 2-22D
     default format of, 4-48            with SEARCH, 2-22D, 4-28
     disk file in, 4-47, 4-54           with SELECT, 2-22D, 4-28
     EQ clause of, 8-23                 with SORT, 2-22D
     expressions in, 4-48               with TYPE, 2-22D
     FORMAT clause of, 4-48           Queued update access, 5-40
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-18
   Revision 4


   QUIT command, 2-1                    list of, 4-11
     to release channels, 2-25          omitting, 4-23
     with reports, 9-4                RELEASE command, 2-25
   Quotation marks                      syntax of, 2-25
     as characters, 2-15              RELOCATE AUXFILE command, 3-50
   Quoted literal format, 6-15          syntax, 3-50
                                      RELOCATE DATA command, 3-48
   Range, 3-15                          collections with, 4-45
   RANGE clause                         syntax of, 3-48
     in ATTRIBUTE statement, 3-14     REPEAT statement, 8-12
   Readonly access                      DBSET command with, 8-29
     for audit trails, 10-7             in PL1022, 8-12
   REAL                               Repeating formats, 6-26
     data fields, 3-6                 REPORT END command, 9-4, 9-26
     data type                        REPORT program
       conversion to, 2-37              command files in, 2-17
       definition of, 3-5               starting, 2-16
   REAL function, 2-37                REPORT START command, 9-4
   REAL values                        Reports
     printing and totalling, 4-52       advanced, 9-20
     rounding in printing, 4-52         BODY command in, 9-10
   RECLOCK access, 5-47                 channels for, 9-36
     changing, 5-47, 7-21               channels in, 9-8
   RECLOCK statement                    command groups in, 9-7
     in DMD file, 3-32                  commands for, 9-1
   RECMODE clause                       custom, 9-50
     DELIMIT clause in, 3-18, 3-27      date in, 9-3
   RECMODE statement                    distributed totals in, 9-34
     in DMD, 3-27                       errors in, 9-4
   Record-level locking, 3-32, 5-46     execution of, 9-4
     with GETREC $LOCK, 5-48            execution sequence in, 9-48
   Records                              features of, 9-1
     current, 4-30                      FINAL section in, 9-26
     definition of, 1-5, 3-4            FOOTING command in, 9-9
     extracting, 3-53                   GETREC section in, 9-22
     formats for, 3-4                   group headings in, 9-12
     id numbers of, 4-22                group totals in, 9-12, 9-25
     input to, 3-4                      HEADING command in, 9-9
     length of, 3-4                     HEADING section in, 9-24
     nonstandard format, 3-41,          hierarchical, 9-37
       5-15, 5-29                         one-level, 9-39
     ordering, 3-53                       three-level, 9-44
     reactivating deleted, 5-4            two-level, 9-41
     related, 4-32                      hierarchy in, 9-19
     selecting, 4-9                     INIT APPEND command in, 9-26
     selecting deleted, 4-26            INIT command in, 9-8
   RECORDS statement                    INITIAL section in, 9-21
     in DMD, 3-25                         clearing selection set in,
   REENTER command                          9-43
     after CONTROL-C, 2-22              JOIN command in, 4-39
   Relational operators                 labels in, 9-28
     in FIND command, 4-10 to 4-11      line number in, 9-3
     in SEARCH, 4-27                    lines per page in, 9-10
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-19
   Revision 4


     multiple data set, 9-37            standard form for, F-3
     ON CHANGE commands in, 9-7,        worksheet for, F-3
       9-12                           RESERVED WORDS
       ignoring, 9-33                   table of, B-1
     page formatting commands in,     RESET clause
       9-8                              with ATTRIBUTE statement, 3-15
     page number in, 9-3                with CREATE command, 3-48
     perforations in, 9-10              with DUMP command, 3-55
     precompilation of, 9-4           RET to end a command, 2-13
     pretotals in, 9-20, 9-30         RETURN statement in PL1022, 8-16
       clearing selection set for,    Roll backward audit trails, 10-3
         9-43                         Roll forward audit trails, 10-3
       restrictions on, 9-32          ROW option
     PRINT command in, 9-7              with INIT 123 command, 12-10
     PRINT section in, 9-25             with INIT DIF command, 12-2
     printing, 9-36                   RUN command, 7-29
       headings and totals in, 9-3      syntax of, 7-29
     program input from, 9-4          RWISE option
     programmed                         with INIT 123 command, 12-10
       definition of, 9-5                 
     programs for, 9-4                S format, 6-11
       ending, 9-4                      append option of, 6-12
       example of, 9-5                  modes in, 6-13
       starting, 9-4                  SA format, 6-12
     prompt for, 9-4                  SAVE command, 4-26
     QUIT command with, 9-4             collections with, 4-45
     record sequence numbers in,        error messages for, E-20
       9-3                              with FIND command, 4-22
     section commands in, 9-20        Scale factors
     sectioned, 9-20                    in numeric formats, 6-9
       example of, 9-27               Scratch device, 4-58
     separate totals in, 9-33         SCRATCH statement
     simple                             in DMD file, 3-28
       definition of, 9-5             Scrolling format, 6-11
       structure of, 9-5                append option of, 6-12
     SORT command in, 9-12              modes in, 6-13
     structure of, 9-5                SEARCH command, 4-27
       complex, 9-20                    case in, 4-28
     summary, 9-25, 9-36                compared to FIND, 4-27
     summary data in, 9-25              compared to SELECT, 4-29
     System variables in, 9-3           GETREC with, 8-14
       data type of, 9-3                messages after, 7-25
     three-level, 9-16                  relational operators in, 4-27
     time in, 9-3                       syntax of, 4-27
     to programs or systems, 9-4        with wildcards, 4-14
     totals in                        Sectioned reports, 9-20
       distributed, 9-34              sections
     TOTALS section in, 9-25            definition of, D-1
     two-level, 9-14                  Security
     TYPAGE command in, 9-10            data set, 11-1
     TYPE command in, 9-7               establishing with ADMIT commands,
     within DPL programs, 9-5             11-1
   reports                              INFORM command for, 7-2
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-20
   Revision 4


     information on, 11-10A               double integers in, 3-10
     limitations, 11-2                    integers in, 3-9
     resetting, 11-2, 11-10A              real numbers in, 3-10
     status information on, 7-3       Slash (/) format, 6-24, 12-4
   SEGMENTATION                         with WKS files, 12-17
     definition of, D-1               SO error messages, E-28C
   segmentation                       SORT command, 4-56
     DBEXEC call for, D-1               ASCENDING keyword in, 4-57
     setting, D-1                       buffer allocation with, 2-58
   SELECT command, 4-28                 buffer size in, 4-58
     compared to SEARCH, 4-29           BY keyword in, 4-57
     GETREC with, 4-29                  DESCENDING keyword in, 4-57
     in compiled pl1022, 8-43           DOWN keyword in, 4-57
     mode in, 4-29                      efficiency in, 4-57, 4-59
     syntax of, 4-28                    error messages for, E-28C
     with wildcards, 4-14               for large sorts, 4-58
   Selection conditions, 4-10           for single keyed attribute,
     relational operators in, 4-11        4-59
     special, 4-21                      in reports, 9-12
     syntax of, 4-10                    scratch device, 4-58
   Selection group                      scratch file-structure in,
     commands for, 4-9                    4-58
     definition of, 4-9                 string functions in, 2-46
   SET clause                           syntax of, 4-56
     in LOAD command, 3-39              UP keyword in, 4-57
   SET command, 7-22                  SORT KEY command, 4-59
     BUFFER option of, 7-23             collections with, 4-45
     controlling messages with,         syntax of, 4-59
       7-25                           Sort order, 4-57
     ERRCHAR option of, 7-24            of text values, 4-13
     ERROR option of, 7-24            SORT22, 4-58
     for top-of-form request, 7-28    SORTED BY
     SCRATCH option of, 7-27            in DUMP command, 3-53
     syntax of, 7-22                  Sorted mode, 5-22
     TAPE option of, 7-28             SOS command, 7-20
     to set prompts, 7-26               on TOPS-10, 7-20
   SET statement                        on TOPS-20, 7-20
     in DMD, 3-23, 3-25                 prompt for, 7-20
       protection code, 3-24            syntax, 7-20
   SET WATCH VERSION command, D-1       syntax of, 7-20
   Signs in formats, 6-3              SP error messages, E-42
   Simultaneous access and updates,   Special attributes, 3-15
     5-36                             Special data types, 3-15
     ENQ system, 5-40                 SPSS, 1-3
     retry system, 5-39                 command, 4-62
   SIXBIT                                 format of, 4-64
     binary to ASCII conversion           options of, 4-64
       $DECODE for, 2-37                  purpose of, 4-63
     clause in DMD file, 3-27           file, 4-62
     data file                          input, 4-62
       transactions with, 5-26          interface error messages, E-42
     ISAM file, 3-27                    subfiles, 4-63
     mode                             SQRT function, 2-36
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-21
   Revision 4


   Square root                        SYSDATE, 2-53, 9-3
     calculating the, 2-36            SYSDATEFMT, 2-53
   Standard deviation                 SYSDAYTIME, 2-53, 9-3
     calculating the, 2-35            SYSDBEXMSG, 2-54
   Starting                           SYSDCORESS, 2-54
     1022, 2-1                        SYSDELIM, 2-54, 8-21
     automatic file, 2-14             SYSDEQFAST, 2-54, 5-41
     from other programs, 2-1         SYSDIV, 2-30, 2-54
     RUN command for, 7-29            SYSDIVMSG, 2-31, 2-54
   STARTREC command, 4-30             SYSDIVP, 2-30, 2-54
   Statistics functions, 2-34         SYSDMETRID, 2-55, 3-44A to 3-44B
     $MEAN, 2-35                      SYSDSALIAS, 2-55, 4-4
     $MIN, 2-35                       SYSDSENQ, 2-55
     $STDEV, 2-34                     SYSDSFILE, 2-55
     $TOT, 2-34                       SYSDSNAME, 2-55
   Status of System 1022, 7-17        SYSENQDEF, 2-55, 5-39
   STDEV function, 2-35               SYSENQTYPE, 2-55, 5-42
   String functions, 2-40             SYSERRCODE, 2-55
   Strings                            SYSERRDEV, 2-55
     entering, 2-15                   SYSERREXT, 2-55
   STRUCTURE section                  SYSERRFILE, 2-55
     in DMD, 3-11                     SYSERRPPN, 2-56
   Structured loops                   SYSERRTEXT, 2-56
     in PL1022, 8-11                  SYSEURODAT, 2-56, 3-8
   Sub-file directory, 2-22A          SYSEXECKP, 2-56
   Subroutines                        SYSEXP, 2-56
     in PL1022, 8-16                  SYSEXPTYPE, 2-27, 2-56
   Subscripts, 8-18 to 8-19           SYSFDMATT, 2-56, 5-34
   Summary functions, 4-51            SYSFILDAM, 5-33
   Summary reports, 9-36              SYSFMSG, 2-56, 7-26
   SY error message, E-30             SYSGTABERR, 2-51, 2-56
   Syntax conventions, 2-12           SYSHLCVT, 2-57
   SYSADDMSG, 2-51, 5-5               SYSHLDISP, 2-57
   SYSADMCDIR, 2-51, 11-7             SYSHLMODE, 2-57
   SYSALCMSG, 2-51, 3-31              SYSHLNAME, 2-57
   SYSAMBATTR, 2-52, 8-26             SYSID, 2-57, 4-22
   SYSAUXCHK, 2-52, 4-5                 in collections, 4-45
   SYSBETWEEN, 2-52, 4-12               in MAP command, 4-33
   SYSCASE, 2-52                      SYSIFTYPE, 2-57, 8-7 to 8-8,
     efficiency of, 4-13                8-11
     in FIND, 4-28                    SYSIOMSG, 2-57
     in FIND command, 4-13            SYSJOBNO, 2-57
     in IF comparisons, 4-28          SYSKEEPBUF, 2-58, 4-58
     in SELECT command, 4-28          SYSKEEPPSI, 2-58, 5-43
   SYSCBLSIGN, 2-52, 3-6              SYSLINE, 2-58, 9-3, 9-8
   SYSCHANGED, 2-52, 5-50             SYSMSTIME, 9-3
   SYSCLOSE2, 2-53                    SYSMTIME, 2-58
   SYSCOLNAME, 2-53                   SYSNOFILOP, 2-58, 2-67
   SYSCORESS, 2-53                    SYSNOPSI, 2-58
   SYSCUSTDMI, 2-53                   SYSNOSEG, 2-58, D-1
   SYSCVTERR, 2-38                    SYSNOSEGP, 2-58, D-1
   SYSCVTMSG, 2-38                    SYSNOXCHAN, 2-58, 2-67
   SYSDAMAGE, 2-53, 5-32              SYSNOYMD, 2-58, 3-8
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-22
   Revision 4


   SYSNREC, 2-59                        $SQRT, 2-36
   SYSNRETRY, 2-59, 5-40                $STDEV, 2-35
   SYSOVF, 2-29, 2-59                   $TEXTL, 2-38
   SYSOVFMSG, 2-30                      $TEXTR, 2-38
   SYSOVFP, 2-29, 2-59                  $TOT, 2-34
   SYSPAGE, 2-59, 9-3, 9-8              $VDATE, 2-49
   SYSPCCOL, 2-59                       $WDAY, 2-47
     with DIF files, 12-8               $YDAY, 2-47
     with WKS files, 12-25              $YEAR, 2-46
   SYSPCRESET, 2-59                     definition of, 2-33
     with DIF files, 12-8             System variables
     with WKS files, 12-25              and commands, I-1
   SYSPCROW, 2-60                       assigning values for, 2-63
     with DIF files, 12-8               default values for, 2-63
     with WKS files, 12-25              definition of, 2-51
   SYSPPN, 2-60                         description of, 2-51
   SYSPROT20, 2-60, 3-24                in reports, 9-3
   SYSRECLOCK, 2-60, 5-48               list of, 2-51
   SYSRECMODE, 2-60, 4-30               printing values for, 2-63
   SYSRECNO, 2-60, 9-3                  table of, 2-64
     in GETREC, 4-30                  SYSTENQ, 2-61, 5-40
   SYSREP1, 2-60, 9-3, 9-33           SYSTEXTDOT, 2-23, 2-61, 4-14,
   SYSREP2, 2-60, 9-3, 9-33             4-28
   SYSREP3, 2-60, 9-33                SYSTIME, 2-61, 9-3
   SYSREPMODE, 2-60, 9-3, 9-8, 9-11   SYSTOPIID, 2-62
   SYSREPSYNC, 2-60, 9-3              SYSTOPSID, 2-62
   SYSRESET, 2-60, 5-38               SYSTRAPUP3, 2-62, 5-45
   SYSRNGMSG, 2-61, 3-15              SYSTRETRY, 2-62, 5-40
   SYSSCRDEV, 2-61, 4-58              SYSUPROG, 2-62
   SYSSCRFILE, 2-61                   SYSUPROJ, 2-62
   SYSSFDFLAG, 2-61                   SYSUSERADR, 7-32
   SYSSWEDSRT, 2-61                   SYSUSERD1, 2-62
   System functions                   SYSUSERD2, 2-62
     $BDAYS, 2-47                     SYSUSERD3, 2-62
     $DATE, 2-37                      SYSUSERI1, 2-62
     $DATEJUL, 2-49                   SYSUSERI2, 2-62
     $DAY, 2-47                       SYSUSERI3, 2-62
     $DINT, 2-37                      SYSUSERR1, 2-63
     $EXP, 2-36                       SYSUSERR2, 2-63
     $FMONTH, 2-47                    SYSUSERR3, 2-63
     $INT, 2-37                       SYSUSERT10, 2-63
     $JULDATE, 2-49                   SYSUSERT40, 2-63
     $LMONTH, 2-47                    SYSUSERT5, 2-63
     $LOG, 2-36                       SYSUSRADRP, 7-32
     $LOG10, 2-36                     SYSWRITE20, 2-63, 5-33
     $MAX, 2-35                           
     $MDYDATE, 2-47                   T (tab) format, 6-23
     $MEAN, 2-35                      TECO
     $MIN, 2-35                         command, 7-18
     $MOD, 2-36                           automatic execution of, 7-19
     $MONTH, 2-46                         prompt, 7-18
     $REAL, 2-37                          syntax of, 7-18
     $SQ, 2-36                          exiting from, 7-18
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-23
   Revision 4


   Terminal                               in PRINT command, 4-51
     output to, 4-47                      in reports, 9-12
   TEXT                                   storing values of, 8-22
     data fields, 3-7                   group, 9-12
     data type                          in PRINT command, 4-51
       definition of, 3-5               mixed, 4-53
   Text comparison, 4-13                pure, 4-53
   Text conversion functions, 2-38      simple, 4-53
     $TEXT, 2-38                      TR error messages, E-39
     $TEXTL, 2-38                     TRACE mode, 2-20
     $TEXTR, 2-38                     TRADLT, 3-44B
   Text editor                        TRANSACT command, 5-18
     prompt used by, 2-16               additive attributes in, 5-30
     using within System 1022, 7-18     APPLIED clause of, 5-23
   Text format, 6-10                    BUFFER option of, 5-29
   Text functions, 2-38                 collections with, 4-45
   Text left, 2-38                      CORE option of, 5-29
   Text literals                        CUSTDMI option of, 5-29
     entering, 2-15                     defaults for, 5-30
   Text references                      delimited-field input with,
     indirect, 2-16                       3-20
   Text right, 2-38                     DUPLICATES MASTER clause of,
   Text string                            5-25
     @TTY to add, 2-17                  DUPLICATES TRANSACT clause of,
     inserting in command files,          5-25
       2-18                             errors in, 3-44A, 5-28
     truncating, 2-38                   examples of, 5-19, 5-31
   TEXTL function, 2-38                 NOCHANGE BLANKS clause, 5-26
   TEXTR function, 2-38                 NODME option of, 5-29
   THEN statement in PL1022             SET clause with, 5-20
     equivalent to GOTO, 8-11           SORTED option, 5-27
   time                                 SYNC clause of, 5-25
     specifications for                 syntax of, 5-27
       table of, C-1                    UNAPPLIED clause of, 5-24
   TIME DESCRIPTORs                   Transaction
     table of, C-1                      additive, 5-30
   TMPFILE command, 7-29                APPLIED, 5-23
   TOPS-10                              definition of, 5-18
     Non-Standard                       example of, 5-19, 5-31
       SYSNOFILOP for, 2-58             fields in, 5-21
       SYSNOXCHAN for, 2-58             locators in, 5-19, 5-21
     segmentation in, D-1               master records in, 5-21
     using from System 1022, 7-30       matching masters in, 5-23
   TOPS-20                              multiple matches in, 5-25
     segmentation in, D-1               overview of, 5-18
     using from System 1022, 7-30       partial, 5-26
   TOT function, 2-34                   records for, 5-20
   Totals                               sorted mode in, 5-22
     -list, 4-51                        UNAPPLIED, 5-24
       functions, 4-51                  unmatched masters in, 5-24
     functions, 2-34                    with ASCII data file, 5-26
       $TOT, 2-34                       with SIXBIT data file, 5-26
       definition of, 2-33            transaction
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-24
   Revision 4


     error messages for, E-39           buffer allocation for, 7-23
   TRAPIG, 3-44B                        commands for, 5-1
   TRAPLY, 3-44B                        efficiency of, 7-23
   TRINVI, 3-44A                        incomplete, 5-32
   TRMDUP, 3-44B                        large-scale, 5-7
   TRRANG, 3-44B                          commands for, 5-7
   TRTDUP, 3-44B                          efficiency of, 5-7, 5-12
   TRUNAP, 3-44B                        mode for, 5-8
   TRUNCATE clause                      of large data sets, 5-18
     in DMD, 3-29                       SET BUFFER command for, 7-23
   TYPAGE command                       simultaneous, 5-36
     in reports, 9-10                     attempts at, 5-40
   TYPE command, 4-56                     consistency in, 5-44
     compared to PRINT command,           ENQ system for, 5-40
       4-56                               protection for, 5-45
     in reports, 9-7                      record-level locking for,
     syntax of, 4-56                        5-46
   Typing files, 7-32                     retry system for, 5-39
                                        TRANSACT command for, 5-18
   UNAPPLIED transactions, 5-24       updating
   Unbundled data sets, 3-2             error messages for, E-28A
     advantages of, 3-37              UPDE. label
     compared to bundled, 3-37          with SYSTRAPUP3, 2-62, 5-45
     creating, 3-45                   UPTO command, 5-6
     DUMP command for, 3-52             collections with, 4-45
     OPEN command with, 8-32            syntax of, 5-6
     overlapping attributes with,     USE command, 2-16
       3-36                             syntax of, 2-16
   UNDELETE command, 5-4              User-id
     after DFIND command, 5-4           in ADMIT command, 11-1
   Underflow                          USERCALL command, 7-32
     conditions of, 2-29                syntax of, 7-32
     definition of, 2-28                  
     suppressing messages for, 2-30   Values
   UNI clause                           in FIND command, 4-10
     of JOIN command, 4-36                definition of, 4-13
   Unidirectional JOIN, 4-36            in key tables, 4-13
   UNKEY command, 5-11                  restrictions on text, 4-13
     collections with, 4-45           VALUES command, 4-59
     purpose of, 5-9                    collections with, 4-45
   UP error messages, E-28A             COLUMN keyword of, 4-60
   UP3 error handling                   COUNT keyword of, 4-60
     SYSTRAPUP3 for, 2-62, 5-45         ON clause of, 4-60
   UPDATE command, 5-8                  syntax of, 4-59
     ALLOW option of, 5-8               SYSID keyword in, 4-60
     EXIT command with, 5-8             VALUES keyword of, 4-60
     OFF option of, 5-8               Variables
     ON option of, 5-8                  accepted from terminal, 8-21
     PREVENT option of, 5-8             assigning values to, 8-20
     QUIT command with, 5-8             data type of, 8-18
     syntax of, 5-8                       DATE, 8-18
   Updating                               DOUBLE INTEGER, 8-18
     audit trails for, 10-10              INTEGER, 8-18
   SYSTEM 1022 COMMANDS AND USER-SETTABLE SYSTEM VARIABLES  Page Index-25
   Revision 4


       REAL, 8-18                     
       TEXT, 8-18                     
     defining, 8-18                   
     erasing, 8-22                    
     in 1022 commands, 8-23           
     in compiled pl1022, 8-39         
     in PL1022, 8-17                  
     redefining, 8-20                 
     System                           
       definition of, 2-51            
       table of, 2-51                 
   VDATE function, 2-49               
   Versions of System 1022, 5-6,      
     7-15                             
                                      
   warning messages                   
     list of, F-1                     
   WDAY function, 2-47                
   WHILE statement, 8-12              
     DBSET command with, 8-29         
     ending, 8-12                     
     in PL1022, 8-12                  
   Wildcarding                        
     on TOPS-10, 11-6                 
   Wildcards                          
     in search expressions, 4-14      
   WKS files, 12-9                    
     $ format, 12-17                  
     data type conversion, 12-12      
     data-positioning options,        
       12-25                          
     keyboard macros, 12-22           
     L format, 12-14                  
     non-L formats, 12-17             
     print formats, 12-13             
     printing to, 12-12               
     Slash (/) format, 12-17          
     X format, 12-17                  
   Word-aligned data files            
     definition of, 3-27              
                                      
   X format, 6-23, 12-4               
     with WKS files, 12-17            
   XOR operator, 4-17                 
                                      
   YDAY function, 2-47                
   YEAR function, 2-46                
                                      
   Zero division, 2-28                
     handling of, 2-30                
     suppressing messages for, 2-31   
                                      
    d@#